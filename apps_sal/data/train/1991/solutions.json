["class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        sloc = sorted([(x,i) for i,x in enumerate(locations)])\n        froutes = [[0]*n for _ in range(fuel+1) ]\n        st,fn = -1,-1\n        for i in range(n):\n            if sloc[i][1] == start:\n                st = i\n            if sloc[i][1] == finish:\n                fn = i\n        froutes[fuel][st] = 1\n        f0 = fuel\n        while fuel > 0:\n            for i, cnt in enumerate(froutes[fuel]):\n                if cnt > 0:\n                    for j in range(i-1, -1, -1):\n                        dist = sloc[i][0] - sloc[j][0]\n                        if dist <= fuel:\n                            froutes[fuel - dist][j] += cnt\n                        else:\n                            break\n                    for j in range(i+1, n):\n                        dist = sloc[j][0] - sloc[i][0]\n                        if dist <= fuel:\n                            froutes[fuel - dist][j] += cnt\n                        else:\n                            break\n            fuel -= 1\n        res = 0\n        for i in range(f0+1):\n            res += froutes[i][fn]\n        return res % (10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        count = 0\n        mod = 10**9+7\n        n = len(locations)\n        s_l = locations[start]\n        f_l = locations[finish]\n        locations.sort()\n        start = locations.index(s_l) \n        finish = locations.index(f_l)\n        \n        import functools\n        @functools.lru_cache(None)\n        def DFS(cur_city,cur_fuel):\n            if cur_fuel < abs(locations[cur_city]-locations[finish]):\n                return 0\n            if cur_city == finish:\n                c = 1\n            else:\n                c = 0\n            i = bisect.bisect_left(locations,locations[cur_city]-cur_fuel)\n            j = min(n-1,bisect.bisect_left(locations,locations[cur_city]+cur_fuel))\n            for nxt in range(i,cur_city):\n                c += DFS(nxt,cur_fuel - abs(locations[cur_city]-locations[nxt]))\n            for nxt in range(cur_city+1,j+1):\n                c += DFS(nxt,cur_fuel - abs(locations[cur_city]-locations[nxt]))\n            return c % mod\n        \n        return DFS(start,fuel)\n                    \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        count = 0\n        mod = 10**9+7\n        n = len(locations)\n        s_l = locations[start]\n        f_l = locations[finish]\n        locations.sort()\n        start = locations.index(s_l) \n        finish = locations.index(f_l)\n        \n        import functools\n        @functools.lru_cache(None)\n        def DFS(cur_city,cur_fuel):\n            if cur_fuel < abs(locations[cur_city]-locations[finish]):\n                return 0\n            i = bisect.bisect_left(locations,locations[cur_city]-cur_fuel)\n            j = min(n-1,bisect.bisect_left(locations,locations[cur_city]+cur_fuel))\n            \n            return (1*(cur_city == finish) + sum( DFS(nxt,cur_fuel-abs(locations[cur_city]-locations[nxt])) for nxt in range(i,j+1) if (nxt != cur_city) ))%mod\n\n        \n        return DFS(start,fuel)\n                    \n", "class Solution:\n    def countRoutes(self, a: List[int], s: int, e: int, f: int) -> int:\n        @lru_cache(None)\n        def dfs(i, f):\n            if f < 0: return 0            \n            ans = int(i == e)\n            for j in range(len(a)):\n                if j != i: ans += dfs(j, f-abs(a[i] - a[j]))\n            return ans\n        return dfs(s, f) % (10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        if (not locations) or fuel <= 0:\n            return 0\n        \n        \n        route_dict = {f:{} for f in range(fuel,-1,-1) }\n        route_dict[fuel][start]=1\n        \n        total_route = 0\n        \n        for f in range(fuel,0,-1):\n            for i,num_route in list(route_dict[f].items()):\n                for j in range(len(locations)):\n                    if j!=i:\n                        d = abs(locations[i]-locations[j])\n                        if f >= d:\n                            if not j in route_dict[f-d]:\n                                route_dict[f-d][j] = num_route\n                            else:\n                                route_dict[f-d][j] += num_route\n                            \n        \n        for f in route_dict:\n            if finish in route_dict[f]:\n                total_route += route_dict[f][finish]\n                \n        return total_route%(10**9 +7)\n\n                        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @functools.lru_cache(None)\n        def dp(start , fuel):\n            if fuel < 0: return 0\n            #if abs(locations[start] - locations[finish])> fuel: return 0\n            res = 0\n            if start == finish:\n                res += 1\n            for i in range(len(locations)):\n                if i!=start:\n                    res += dp(i,fuel-abs(locations[i]-locations[start]))\n            return res % (10**9+7)\n        return dp(start,fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        @lru_cache(None)\n        def dp(city, fuel):\n            ans = 0\n            if city == finish:\n                ans += 1\n            for i, c in enumerate(locations):\n                if i == city:\n                    continue\n                cost = abs(c - locations[city])\n                if cost <= fuel:\n                    ans += dp(i, fuel - cost)\n                    ans %= MOD\n            return ans % MOD\n        \n        return dp(start, fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        @functools.lru_cache(None)\n        def solve(i, f):\n            ans = 1 if i == finish else 0\n            for j, npos in enumerate(locations):\n                cost = abs(npos - locations[i])\n                if i != j and cost <= f:\n                    ans = (ans + solve(j, f - cost)) % MOD\n            return ans\n        return solve(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def step(loc, fuel_left):\n            if fuel_left < 0:\n                return 0\n            \n            ans = int(loc == locations[finish])\n            for dest in locations:\n                if dest != loc:\n                    ans = (ans + step(dest, fuel_left - abs(dest - loc))) % (10 ** 9 + 7)\n            return ans\n        \n        return step(locations[start], fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        MOD = 1000000007\n        @lru_cache(None)\n        def go(pos, fuel):\n            #print(pos)\n            temp = 0\n            if fuel < 0:\n                return 0\n            ans = 0\n            if pos == finish:\n                 ans +=1\n            for i in range(n):\n                if i == pos:\n                    continue\n                ans += (go(i, fuel - abs(locations[pos]-locations[i])))\n            return ans%MOD\n        return go(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dic = {}\n        for i, l in enumerate(locations):\n            dic[l]=i\n        idxes = sorted(dic.keys())\n        MOD = 10**9+7\n        from functools import lru_cache\n        @lru_cache(None)\n        def dp(i,k):\n            if i == finish:\n                res = 1\n            else:\n                res = 0 \n           \n            L = bisect.bisect_left(idxes,locations[i]-k)\n            R = bisect.bisect_right(idxes,locations[i]+k)\n            if L==R==i:\n                return res \n            for j in range(L,R):\n                if dic[idxes[j]] !=i:\n                    res+=dp(dic[idxes[j]],k-abs(locations[i]-idxes[j]))%MOD\n            return res \n        return dp(start,fuel)%MOD", "from functools import lru_cache\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(None)\n        def dp(j, f):\n            # print(j, f)\n            summ = 0\n            for idx, loc in enumerate(locations):\n                if idx == j: continue\n                step = abs(loc - locations[j])\n                if step < f:\n                    if idx == start:    summ += 1\n                    summ += dp(idx, f-step)\n                elif step == f and idx == start:\n                    summ += 1\n            return summ\n        \n        return (dp(finish, fuel)) % (10**9+7) + (1 if start == finish else 0)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        N = len(locations)\n        \n        @functools.lru_cache(None)\n        def dfs(u, f):\n            ans = 0\n            if u == finish:\n                ans += 1\n            if f <= 0:\n                return ans\n            for v in range(N):\n                if u == v:\n                    continue\n                cost = abs(locations[v] - locations[u])\n                if cost <= f:\n                    ans += dfs(v, f - cost) % MOD\n            return ans\n        \n        return dfs(start, fuel) % MOD", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dfs(i, f):\n            res = 1 if i == e_idx else 0\n            for j in range(i - 1, -1, -1):\n                df = locations[i] - locations[j]\n                if df > f:\n                    break\n                res += dfs(j, f - df)\n            for j in range(i + 1, len(locations)):\n                df = locations[j] - locations[i]\n                if df > f:\n                    break\n                res += dfs(j, f - df)\n            return res\n            \n            \n        s_loc, e_loc = locations[start], locations[finish]\n        locations.sort()\n        s_idx, e_idx = locations.index(s_loc), locations.index(e_loc)\n        return dfs(s_idx, fuel) % (10 ** 9 + 7)\n        \n", "\nMODNUM = 1000000007\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(None)\n        def dp(i, j, f):\n            if f <= 0:\n                return 0\n            \n            res = 1 if i != j and abs(locations[i] - locations[j]) <= f else 0\n            N = len(locations)\n            for k in range(N):\n                if k == j:\n                    continue\n                dkj = abs(locations[k] - locations[j])\n                if dkj < f:\n                    res = (res + dp(i, k, f - dkj)) % MODNUM\n            \n            return res\n    \n        return dp(start, finish, fuel) + (1 if (start == finish) else 0)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @functools.lru_cache(None)\n        def solve(s, e, f):\n            res = 0 if s != e else 1\n            for i, v in enumerate(locations):\n                if i == s:\n                    continue\n                cost = abs(locations[s] - locations[i])\n                if cost > f:\n                    continue\n                res += solve(i, e, f - cost)\n            return res\n        return solve(start, finish, fuel) % int(1e9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        from functools import lru_cache\n        \n        @lru_cache(None)\n        def recurse(fuel, curr_city):\n            if fuel == 0 and curr_city == finish:\n                return 1\n            if fuel == 0:\n                return 0 \n            \n            array = []\n            for index, city_val in enumerate(locations):\n                if curr_city != index:\n                    fuel_left = fuel - abs(locations[curr_city] - city_val)\n                    if fuel_left >= 0:\n                        array.append(recurse(fuel_left, index))\n                        \n            if curr_city != finish:\n                return sum(array)\n            else:\n                return sum(array)+1\n            \n        return recurse(fuel,start) % (10**9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10 ** 9 + 7\n        @lru_cache(None)\n        def dp(u, fuel):\n            ans = +(u == finish)\n            du = locations[u]\n            for v, dv in enumerate(locations):\n                if v != u:\n                    delta = abs(du - dv)\n                    if fuel-delta >= 0:\n                        ans += dp(v, fuel - delta)\n                        ans %= mod\n            return ans\n        return dp(start, fuel)", "from functools import lru_cache\n\nclass Solution:\n    def countRoutes(self, loc: List[int], start: int, finish: int, fuel: int) -> int:\n        l = len(loc)\n        MAX = 10**9 + 7\n        @lru_cache(None)\n        def inner(curr, lf):\n            #print(curr, lf)\n            if curr == finish and lf == 0:\n                return 1\n            if lf <= 0:\n                return 0\n            ans = int(curr == finish)\n            for i in range(l):\n                if i == curr:\n                    continue\n                ans += inner(i, lf-abs(loc[i]-loc[curr]))\n            return ans % MAX\n        \n        return inner(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        f = [[0 for j in range(n)] for i in range(fuel + 1)]\n        # s_index = -1\n        # e_index = -1\n        # for i, loc in enumerate(locations):\n        #     if (loc == start):\n        #         s_index = i\n        #     elif (loc == finish):\n        #         e_index = i\n        # print(f)\n        # print(n, fuel,s_index, e_index)\n        # print(n, fuel,start, finish)\n        LARGE = int(1e9 + 7)\n        f[fuel][start] = 1\n        for v in range(fuel, -1, -1):\n            for i, loc1 in enumerate(locations):\n                # print(v, i)\n                if (f[v][i] > 0):\n                    for j, loc2 in enumerate(locations):\n                        if (j != i):\n                            update_fuel = v - abs(loc1 - loc2)\n                            if (update_fuel >= 0):\n                                f[update_fuel][j] += f[v][i] % LARGE\n        result = sum([f[i][finish] for i in range(fuel)])\n        if (start == finish):\n            result += 1\n        return result % LARGE", "class Solution:\n    @functools.lru_cache(None)\n    def core(self, start, finish, fuel):\n        #what is your next hop?\n        if fuel < 0: \n            return 0\n        elif abs(self.locs[start] - self.locs[finish]) > fuel:\n            return 0\n        elif fuel == 0: \n            return 1 if start == finish else 0\n        else:\n            #hop to a third party\n            i = start - 1\n            cntr = 1 if start == finish else 0\n            while i >= 0 :\n                #first hop\n                cost = self.locs[start] - self.locs[i]\n                if (2 * cost > fuel and finish >= start) or cost > fuel:\n                    break\n                cntr +=  self.core(i, finish, fuel - cost)\n                cntr %= self.mod\n                i -= 1\n                pass\n            \n            i = start + 1\n            while i < len(self.locs):\n                cost = self.locs[i] - self.locs[start]\n                if (2 * cost > fuel and finish <= start) or cost > fuel:\n                    break\n                cntr += self.core(i, finish, fuel - cost)\n                cntr %= self.mod\n                i += 1\n                pass\n            #print(\\\"%d -> %d (%d) : %d\\\" % (start, finish, fuel, cntr))\n            return cntr\n        pass\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.mod = 1000000007\n        self.locs = locations\n        s = locations[start]\n        d = locations[finish]\n        self.locs.sort()\n        start = self.locs.index(s)\n        finish = self.locs.index(d)\n        return self.core(start, finish, fuel)", "class Solution:\n    def countRoutes(self, a: List[int], s: int, e: int, f: int) -> int:\n        @lru_cache(None)\n        def dfs(i, f):\n            if f < 0: return 0            \n            ans = int(i == e)\n            for j in range(len(a)):\n                if j == i: continue\n                dist = abs(a[i] - a[j])\n                ans += dfs(j, f-dist)\n            return ans\n        return dfs(s, f) % (10**9+7)", "from functools import lru_cache\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(maxsize=None)\n        def dfs(idx, f):\n            cur = 0\n            if f < 0:\n                return cur\n            if idx == finish:\n                cur += 1\n            for i in range(len(locations)):\n                if i != idx:\n                    cur += dfs(i, f-abs(locations[i]-locations[idx]))\n            return cur\n        \n        return dfs(start, fuel) % (10 ** 9 + 7)\n", "from functools import lru_cache\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        start_pos = locations[start]\n        end_pos = locations[finish]\n        #locations.sort()\n        N = len(locations)\n        \n        \n        \n        \n        @lru_cache(None)\n        def route(x,f):\n            \n            if abs(end_pos-x)>f:\n                return 0\n            \n            if end_pos==x:\n                ans = 1\n            else:\n                ans = 0\n            \n            for y in locations:\n                if x!=y:\n                    ans+=route(y,f-abs(x-y))\n                \n            return ans\n            \n            \n            \n        return route(start_pos,fuel)%(10**9+7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        mod = 10**9+7\n        @lru_cache(None)\n        def dfs(i, f):\n            if f < 0:\n                return 0\n            ans = i == finish\n            for j in range(n):\n                if i != j:\n                    ans += dfs(j, f - abs(locations[i] - locations[j]))\n            return ans % mod\n        return dfs(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        N = len(locations)\n        mod = (10**9)+7\n        @lru_cache(None)\n        def rec(cur, rem):\n            if rem <= 0:\n                return cur == finish and rem == 0\n            ans = (cur == finish)\n            for i in range(N):\n                if i == cur:\n                    continue\n                ans += rec(i, rem - abs(locations[cur] - locations[i]))\n                \n            return ans%mod\n        \n        return rec(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def fn(n, x): \n            \\\"\\\"\\\"Return all possible routes from n to finish with x fuel.\\\"\\\"\\\"\n            \n            if x < 0:\n                return 0\n            ans = 0\n            if n == finish:\n                ans += 1\n            \n            for i in range(len(locations)):\n                if i != n:\n                    ans += fn(i, x - (abs(locations[n] - locations[i])))\n            return ans\n        return fn(start, fuel) % 1_000_000_007\n", "from functools import lru_cache as l\nclass Solution:\n    def countRoutes(self, a: List[int], s: int, t: int, fuel: int) -> int:\n        # d = [x:i for i,x in enumerate(a)]\n        n = len(a)\n        @l(None)\n        def dp(i, f):\n            if f<0:\n                return 0\n            \n            # cur = a[i]\n            ans = 0\n            if i == t:\n                ans += 1\n            for j in range(n):\n                if j != i:\n                    ans += dp(j, f - abs(a[i]-a[j]))\n            return ans\n        \n        return (dp(s, fuel)%(10**9+7))", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # n = position, x = fuel\n        @lru_cache(None)\n        def helper(n, x): \n            \\\"\\\"\\\"Return all possible routes from n to finish with x fuel.\\\"\\\"\\\"\n            if x < 0: \n                return 0\n            res = 0\n            if n == finish:\n                res += 1\n            for next_position in range(len(locations)): \n                if next_position != n: \n                    res += helper(next_position, x-abs(locations[n] - locations[next_position]))\n            return res\n        \n        return helper(start, fuel) % 1_000_000_007", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10**9 + 7\n        @lru_cache(None)\n        def fn(n, x): \n            if x < 0: return 0 \n            ans = 0\n            if n == finish: ans += 1\n            for nn in range(len(locations)): \n                if nn != n: ans += fn(nn, x-abs(locations[n] - locations[nn]))\n            return ans \n        \n        return fn(start, fuel) % MOD", "from collections import defaultdict\nclass Solution:\n   \n   \n    \n        \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def f(start, end):\n            return abs(locations[start]-locations[end])\n        \n        @lru_cache(None)\n        def dfs(start, finish, fuel):\n            ret = 0\n            for i in range(len(locations)):\n                if (i== start):\n                    continue\n                f1 = fuel - f(start, i)\n                if f1>=0:\n                    if i == finish:\n                        ret +=1\n                    if (f(i,finish)<=f1):\n                        ret += dfs(i, finish, f1)\n            return ret\n    \n        \n        ret = 0\n        if (start==finish):\n            ret = 1\n\n        ret += dfs(start, finish, fuel)\n        return ret%(10**9+7)\n            \n        \n        \n        \n        \n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(None)\n        def fn(n, x): \n            \\\"\\\"\\\"Return all possible routes from n to finish with x fuel.\\\"\\\"\\\"\n            if x < 0: return 0 # not going anywhere without fuel \n            ans = 0\n            if n == finish: ans += 1\n            for nn in range(len(locations)): \n                if nn != n: ans += fn(nn, x-abs(locations[n] - locations[nn]))\n            return ans \n        \n        return fn(start, fuel) % 1_000_000_007", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # n = position, x = fuel\n        @lru_cache(None)\n        def helper(n, x): \n            \\\"\\\"\\\"Return all possible routes from n to finish with x fuel.\\\"\\\"\\\"\n            if x < 0: \n                return 0\n            res = 0\n            if n == finish:\n                res += 1\n            for next_position in range(len(locations)): \n                if next_position != n: \n                    res += helper(next_position, x-abs(locations[n] - locations[next_position]))\n            return res\n        \n        return helper(start, fuel) % (10**9 + 7)", "import functools\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(maxsize=None)\n        def s(city, left):\n            if left < 0:\n                return 0\n            l = locations[city]\n            p, q = bisect_left(locations, l - left), bisect_right(locations, l + left)\n            return (sum(s(i, left - abs(l - locations[i])) for i in range(p, q) if i != city) + (1 if city == finish else 0)) % MOD\n            \n        sp, fp = locations[start], locations[finish]\n        locations.sort()\n        start, finish = bisect_left(locations, sp), bisect_left(locations, fp)\n        MOD = 10 ** 9 + 7\n        return s(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(None)\n        def dp(cur, fuel) :\n            if fuel == 0 and cur == start:\n                return 1\n            \n            if fuel <=0:\n                return 0\n            ways = cur == start\n            \n            for i in range(len(locations)):\n                if i !=cur :\n                    ways += dp(i,   fuel -  abs(locations[i] - locations[cur]))\n            return ways % (10**9+7)\n        \n        return dp(finish, fuel)\n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        L = len(locations)\n        \n        @lru_cache(None)\n        def move(loc, remaining):\n            if remaining < 0:\n                return 0\n            \n            ans = 0\n            if loc == finish:\n                ans += 1\n            \n            for i in range(L):\n                if i == loc:\n                    continue\n                \n                ans += move(i, remaining - abs(locations[i] - locations[loc]))\n            \n            return ans\n        \n        return move(start, fuel) % 1000000007\n    \n    \n    def countRoutes2(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # bottom up\n        dp = defaultdict(dict)\n                \n        for j in range(0, fuel+1):\n            for i in range(len(locations)):\n                if i == finish:\n                    ans = 1\n                else:\n                    ans = 0\n            \n                for k in range(len(locations)):\n                    if k != i:\n                        f = j - abs(locations[i]-locations[k])\n                        if f >= 0:\n                            ans += dp[k][f]    \n                dp[i][j] = ans % 1000000007\n        \n        return dp[start][fuel]\n    \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        L = len(locations)\n        \n        @lru_cache(None)\n        def move(loc, remaining):\n            #if remaining == 0:\n             #   return 0\n            \n            ans = 0\n            if loc == finish:\n                ans += 1\n            \n            for i in range(L):\n                f = remaining\n                if i == loc:\n                    continue\n                    \n                cost = locations[i] - locations[loc]\n                if cost < 0:\n                    cost = -cost\n                f -= cost\n               \n                if f < 0:\n                    continue\n               \n                ans += move(i, f)\n            \n            return ans\n        \n        return move(start, fuel) % 1000000007\n    \n    def countRoutes2(self, l: List[int], start: int, fin: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dfs(i: int, f: int) -> int:\n            if f < 0:\n                return 0\n            \n            ans = 0\n            if i == fin:\n                ans = 1\n                \n            ans += sum(0 if i == j else dfs(j, f - abs(l[j] - l[i])) for j in range(len(l)))\n        \n        return dfs(start, fuel) % 1000000007", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # Note that my first approach was to use dfs - see my earliest submission\n        # It gave correct results, but failed TLE.\n        \n        # From looking at discussion, it was clear dp works best.\n        # Create blank dp grid with [fuel][location]\n        # begin at point [starting fuel][starting location] = 1\n        # iterate from biggest locations, starting fuel, reducing\n        # location by 1 each time, then reducing fuel\n        # if you encounter a 0 in dp, ignore it\n        # But otherwise, calculate the locations you can move to \n        # -- ignoring moving back to that same location --\n        # and in each of those locations, with the reduced fuel amount,\n        # add in the value that was in the dp grid that got you there.\n        # After doing all of that, add up the values of dp grid\n        # for each point in the column for location finish.\n        \n        dp = [[0 for j in range(len(locations))] for i in range(fuel + 1)]\n        dp[fuel][start] = 1\n        \n        for i in range(fuel, -1, -1):\n            for j in range(len(locations)-1, -1, -1):\n                if dp[i][j] == 0:\n                    continue\n                for st in range(len(locations)):\n                    if st != j:\n                        if i >= abs(locations[st] - locations[j]):\n                            dp[i-abs(locations[st]-locations[j])][st] += dp[i][j]\n        total = 0\n        for i in range(fuel+1):\n            total += dp[i][finish]\n        return total % (10**9 + 7)\n        \n        \n        \n        '''for i in range(fuel+1):\n            dp[i][finish] = 1\n        for i in range(1, fuel + 1): # i is amount of fuel\n            for j in range(len(locations)): # j is start location\n                if i < abs(locations[j] - locations[finish]):\n                    dp[i][j] = 0\n                elif i == abs(locations[j] - locations[finish]):\n                    dp[i][j] = 1\n                else:\n                    total = 0\n                    print(f\\\"fuel {i} and location {j}\\\")\n                    for st in range(len(locations)):\n                        print(f\\\"next location is {st}\\\")\n                        if abs(locations[st] - locations[j]) >= i:\n                            print(\\\"at 0\\\")\n                            \n                            total += dp[i - abs(locations[j] - locations[st])][st]\n                            if st == finish:\n                                total += 1\n                            #print(\\\"total is now \\\", total)\n                    print(\\\"final total is \\\", total)\n                    dp[i][j] = total\n        print(dp)\n        return dp[fuel][start]'''\n        \n                \n        \n        '''from functools import lru_cache\n        \n        @lru_cache\n        def dfs(start, fuel):\n            #print(\\\"dfs called with start, fuel: \\\", start, fuel)\n            total = 0\n            if start == finish:\n                total += 1\n            if fuel == 0:\n                return total\n            for city in range(len(locations)):\n                if city != start:\n                    if abs(locations[start]-locations[city]) <= fuel:\n                        #print(f\\\"arrived at {city} from {start}\\\")\n                        #if city == finish:\n                        #    res[0] += 1\n                        newFuel = fuel - abs(locations[start]-locations[city])\n                        #print(f\\\"newFuel is {newFuel}\\\")\n                        if newFuel >= 0: \n                            if city != finish:\n                                if fuel >= abs(locations[city]-locations[finish]):\n                                    total += dfs(city, newFuel)\n                            else:\n                                total += dfs(city, newFuel)\n            return total\n        \n        res = dfs(start, fuel)\n        return res % (10**9 + 7)'''\n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(None)\n        def dp(i, f):\n            if f<0: return 0\n            return (sum(dp(j, f-abs(locations[i]-locations[j])) \n                      for j in range(len(locations)) if i!=j) + (i==finish))%(10**9+7);\n        \n        return dp(start, fuel);\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @functools.lru_cache(None)\n        def dp(city, left):\n            if left < 0:\n                return 0\n            return (1 if city==finish else 0) + sum([dp(dest, left-abs(locations[dest]-locations[city]))\\\\\n                for dest in range(len(locations)) if dest!=city])%(10**9+7)\n        return dp(start, fuel)", "class Solution:\n    def countRoutes(self, a: List[int], s: int, e: int, f: int) -> int:\n        n = len(a)\n        @lru_cache(None)\n        def dfs(i, f):\n            if f < 0: return 0            \n            ans = int(i == e)\n            for j in range(n):\n                if j == i: continue\n                dist = abs(a[i] - a[j])\n                ans += dfs(j, f-dist)\n            return ans\n        return dfs(s, f) % (10**9+7)", "class Solution:\n    def countRoutes(self, A: List[int], start: int, finish: int, fuel: int) -> int:\n        n, mod = len(A), 10 ** 9 + 7\n        @functools.lru_cache(None)\n        def dfs(i, f):\n            ret = 1 if i == finish else 0\n            for j in range(n):\n                if i != j and abs(A[i] - A[j]) <= f:\n                    ret += dfs(j, f - abs(A[i] - A[j]))\n            return ret\n        return dfs(start, fuel) % mod", "class Solution:\n    def countRoutes(self, locs: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dfs(i: int, f: int) -> int:\n            res = 1 if i == finish else 0\n            for j in range(len(locs)):\n                if i != j and f >= abs(locs[j] - locs[i]):\n                    res += dfs(j, f - abs(locs[j] - locs[i]))\n            return res % 1000000007\n        return dfs(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        start_pos = locations[start]\n        finish_pos = locations[finish]\n        \n        locations.sort()\n        for i,location in enumerate(locations):\n            if location == start_pos:\n                start = i\n            if location == finish_pos:\n                finish = i\n        print(locations)\n        print((start, finish, fuel))\n                \n        @lru_cache(None)\n        def dfs(i,j,f):\n            if f < 0:\n                return 0\n            if abs(locations[i] - locations[j]) > f:\n                return 0\n            \n            l = locations[i] - f\n            r = locations[i] + f\n            li = bisect.bisect_left(locations,  l)\n            ri = bisect.bisect_right(locations, r)\n            \n            ans = 1 if i == j else 0\n            for k in range(li, ri):\n                if k != i:\n                    ans += dfs(k, j, f - abs(locations[i] - locations[k]))\n            return ans\n        \n        return dfs(start, finish, fuel) % (10 ** 9 + 7)\n", "class Solution:\n    def countRoutes(self, loc: List[int], s: int, f: int, fuel: int) -> int:\n        n=len(loc)\n        \n        @lru_cache(None)\n        def t(s,f,fuel):\n\n            if fuel<0:\n                return 0\n\n            ct=s==f\n\n            for i in range(n):\n                if i!=s:\n                    ct+=t(i,f,fuel-abs(loc[s]-loc[i]))\n            return ct\n\n        return t(s,f,fuel)%(10**9+7)\n", "#ways @ i, rem is equal to all possible routes \nclass Solution:\n    def countRoutes(self, A: List[int], start: int, finish: int, fuel: int) -> int:\n        N = len(A)\n        MOD = 10**9 + 7\n        @functools.lru_cache(None)\n        def dp(i,rem):\n            if rem == 0:\n                return 0\n            ways = 0\n            for j in range(N):\n                deltaF = rem - abs(A[i] - A[j])\n                if  i != j  and deltaF >= 0:\n                    ways = (ways + dp(j, deltaF)) % MOD\n                    if j == finish:\n                        ways = (ways + 1) % MOD\n            return ways\n        return dp(start, fuel) + (1 if start == finish else 0)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10**9+7\n        @lru_cache(None)\n        def dp(curr,fuel):\n            # print(curr,fuel)\n            nonlocal mod\n            if fuel < 0:\n                return 0\n            ans = 0\n            if curr == finish:\n                ans += 1\n            if fuel < 0:\n                return 0\n            for i in range(len(locations)):\n                if i == curr or fuel < abs(locations[i]-locations[curr]):\n                    continue\n                ans += dp(i,fuel - abs(locations[i]-locations[curr]))\n            return ans\n        return dp(start,fuel)%mod\n        # return ans\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # create blank dp grid with [fuel][location]\n        # begin at point [starting fuel][starting location] = 1\n        # iterate from biggest locations, starting fuel, reducing\n        # location by 1 each time, then reducing fuel\n        # if you encounter a 0 in dp, ignore it\n        # But otherwise, calculate the locations you can move to \n        # -- ignoring moving back to that same location --\n        # and in each of those locations, with the reduced fuel amount,\n        # add in the value that was in the dp grid that got you there.\n        # After doing all of that, add up the values of dp grid\n        # for each point in the column for location finish.\n        \n        dp = [[0 for j in range(len(locations))] for i in range(fuel + 1)]\n        dp[fuel][start] = 1\n        \n        for i in range(fuel, -1, -1):\n            for j in range(len(locations)-1, -1, -1):\n                if dp[i][j] == 0:\n                    continue\n                for st in range(len(locations)):\n                    if st != j:\n                        if i >= abs(locations[st] - locations[j]):\n                            dp[i-abs(locations[st]-locations[j])][st] += dp[i][j]\n        total = 0\n        for i in range(fuel+1):\n            total += dp[i][finish]\n        return total % (10**9 + 7)\n        \n        \n        \n        '''for i in range(fuel+1):\n            dp[i][finish] = 1\n        for i in range(1, fuel + 1): # i is amount of fuel\n            for j in range(len(locations)): # j is start location\n                if i < abs(locations[j] - locations[finish]):\n                    dp[i][j] = 0\n                elif i == abs(locations[j] - locations[finish]):\n                    dp[i][j] = 1\n                else:\n                    total = 0\n                    print(f\\\"fuel {i} and location {j}\\\")\n                    for st in range(len(locations)):\n                        print(f\\\"next location is {st}\\\")\n                        if abs(locations[st] - locations[j]) >= i:\n                            print(\\\"at 0\\\")\n                            \n                            total += dp[i - abs(locations[j] - locations[st])][st]\n                            if st == finish:\n                                total += 1\n                            #print(\\\"total is now \\\", total)\n                    print(\\\"final total is \\\", total)\n                    dp[i][j] = total\n        print(dp)\n        return dp[fuel][start]'''\n        \n                \n        \n        '''from functools import lru_cache\n        \n        @lru_cache\n        def dfs(start, fuel):\n            #print(\\\"dfs called with start, fuel: \\\", start, fuel)\n            total = 0\n            if start == finish:\n                total += 1\n            if fuel == 0:\n                return total\n            for city in range(len(locations)):\n                if city != start:\n                    if abs(locations[start]-locations[city]) <= fuel:\n                        #print(f\\\"arrived at {city} from {start}\\\")\n                        #if city == finish:\n                        #    res[0] += 1\n                        newFuel = fuel - abs(locations[start]-locations[city])\n                        #print(f\\\"newFuel is {newFuel}\\\")\n                        if newFuel >= 0: \n                            if city != finish:\n                                if fuel >= abs(locations[city]-locations[finish]):\n                                    total += dfs(city, newFuel)\n                            else:\n                                total += dfs(city, newFuel)\n            return total\n        \n        res = dfs(start, fuel)\n        return res % (10**9 + 7)'''\n        \n", "class Solution:\n    def countRoutes(self, loc: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def get(cur, left):\n            if left < 0: return 0\n            return (sum([get(i, left-abs(loc[i]-loc[cur])) for i in range(len(loc)) if i != cur]) + (cur==finish)) % 1000000007\n        return get(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        @lru_cache(None)\n        def helper(ind,f):\n            ret = 0\n            if ind == finish:\n                ret += 1\n            for i in range(n):\n                if i!=ind and abs(locations[i]-locations[ind])<=f:\n                    ret += helper(i,f-abs(locations[i]-locations[ind]))\n            return ret\n        return helper(start,fuel) % (10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        kMod = 1e9+7\n        @lru_cache(None)\n        def dp(i, f):\n            if (f < 0): return 0\n            # if (i == finish): return 1\n            \n            return (sum([dp(j, f - abs(locations[j] - locations[i])) for j in range(n) if j != i]) + (i==finish))%kMod\n        return int(dp(start, fuel))\n", "import functools\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @functools.lru_cache(None)\n        def doit(start, fuel):\n            if fuel < 0:\n                return 0\n            ans = 0\n            if start == finish and fuel >= 0:\n                ans += 1\n                \n            for i in range(len(locations)):\n                if i != start and fuel >= abs(locations[i] - locations[start]):\n                    ans += doit(i, fuel - abs(locations[i] - locations[start]))\n            \n            return ans % 1000000007\n        \n        return doit(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dfs(i: int, f: int) -> int:\n            if f < 0:\n                return 0\n            \n            return (1 if i == finish else 0) + sum(0 if i == j else dfs(j, f - abs(locations[j] - locations[i])) for j in range(len(locations)))\n        return dfs(start, fuel) % 1000000007\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @functools.lru_cache(None)\n        def dp(start , fuel):\n            if fuel < 0: return 0\n            if abs(locations[start] - locations[finish])> fuel: return 0\n            res = 0\n            if start == finish:\n                res += 1\n            for i in range(len(locations)):\n                if i!=start:\n                    res += dp(i,fuel-abs(locations[i]-locations[start]))\n            return res % (10**9+7)\n        return dp(start,fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        dp = [[0] * (fuel + 1) for _ in range(n)]\n        dp[start][fuel] = 1  # init\n\n        # State transition: dp[i][f] = sum{dp[j][f + d]} where d = abs(location[i]-location[j]), i != j\n        for f in range(fuel, 0, -1):\n            for i in range(0, n):\n                if dp[i][f] == 0 or abs(locations[i] - locations[finish]) > f:\n                    continue\n                for j in range(0, n):\n                    d = abs(locations[i] - locations[j])\n                    if i == j or d == 0 or d > f:\n                        continue\n                    dp[j][f - d] = (dp[j][f - d] + dp[i][f]) % 1_000_000_007\n\n        return sum(dp[finish]) % 1_000_000_007", "from functools import lru_cache\n\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        \n        @lru_cache(None)\n        def DP(cur, fuel):\n            if fuel < 0:\n                return 0\n            return (int(cur == finish) + sum(\n                DP(nxt, fuel - abs(locations[cur] - locations[nxt]))\n                for nxt in range(len(locations))\n                if nxt != cur\n            )) % MOD\n\n        return DP(start, fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.MOD = 10**9 + 7\n        \n        @functools.lru_cache(None)\n        def dfs(i, left):\n            if left < 0:\n                return 0\n            \n            ret = 1 * (i == finish)\n            \n            return (sum(dfs(j, left - abs(locations[j] - locations[i])) \\\\\n                       for j in range(len(locations)) \\\\\n                       if i != j) + ret) % self.MOD\n            \n        return dfs(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        m = [[0 for i in range(n)] for j in range(n)]\n        for i in range(n):\n            for j in range(i+1,n):\n                cost = abs(locations[i]-locations[j])\n                m[i][j] = cost\n                m[j][i] = cost\n        mod = int(1e9+7)\n        memo = [[-1 for i in range(n)] for j in range(fuel+1)]\n        def DFS(start,finish,f):\n            if memo[f][start]!=-1:\n                return memo[f][start]\n            if f<0:\n                return 0\n            res = 0\n            if start==finish:\n                res +=1\n            for i in range(n):\n                if i!=start and m[start][i]<=f:\n                    res =(res+ DFS(i,finish,f-m[start][i]))%mod\n            memo[f][start]  = res\n            return res\n        return DFS(start,finish,fuel)\n            \n        \n", "from collections import Counter, defaultdict, OrderedDict, deque\nfrom bisect import bisect_left, bisect_right \nfrom functools import reduce, lru_cache \nfrom typing import List \nimport itertools \nimport math \nimport heapq \nimport string\ntrue = True\nfalse = False\nMIN, MAX, MOD = -0x3f3f3f3f, 0x3f3f3f3f, 1000000007\n#\n# @lc app=leetcode id=1575 lang=python3\n#\n# [1575] Count All Possible Routes\n#\n# https://leetcode.com/problems/count-all-possible-routes/description/\n#\n# algorithms\n# Hard (59.30%)\n# Total Accepted:    1.7K\n# Total Submissions: 2.8K\n# Testcase Example:  '[2,3,6,8,4]\\\n1\\\n3\\\n5'\n#\n# You are given an array of distinct positive integers locations\u00a0where\n# locations[i] represents the position of city i. You are also given\u00a0integers\n# start,\u00a0finish\u00a0and\u00a0fuel\u00a0representing the starting city, ending city, and the\n# initial amount of fuel you have, respectively.\n# \n# At each step, if you are at city\u00a0i, you can pick any city\u00a0j\u00a0such that j != i\n# and\u00a00 <= j < locations.length\u00a0and move to city j.\u00a0Moving from city i to city\n# j reduces the amount of fuel you have by\u00a0|locations[i] - locations[j]|.\n# Please notice that |x|\u00a0denotes the absolute value of x.\n# \n# Notice that\u00a0fuel\u00a0cannot become negative at any point in time, and that you\n# are allowed to visit any city more than once (including start\u00a0and\u00a0finish).\n# \n# Return the count of all possible routes from\u00a0start\u00a0to\u00a0finish.\n# \n# Since the answer\u00a0may be too large,\u00a0return it modulo\u00a010^9 + 7.\n# \n# \n# Example 1:\n# \n# \n# Input: locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5\n# Output: 4\n# Explanation:\u00a0The following are all possible routes, each uses 5 units of\n# fuel:\n# 1 -> 3\n# 1 -> 2 -> 3\n# 1 -> 4 -> 3\n# 1 -> 4 -> 2 -> 3\n# \n# \n# Example 2:\n# \n# \n# Input: locations = [4,3,1], start = 1, finish = 0, fuel = 6\n# Output: 5\n# Explanation: The following are all possible routes:\n# 1 -> 0, used fuel = 1\n# 1 -> 2 -> 0, used fuel = 5\n# 1 -> 2 -> 1 -> 0, used fuel = 5\n# 1 -> 0 -> 1 -> 0, used fuel = 3\n# 1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5\n# \n# \n# Example 3:\n# \n# \n# Input: locations = [5,2,1], start = 0, finish = 2, fuel = 3\n# Output: 0\n# Explanation: It's impossible to get from 0 to 2 using only 3 units of fuel\n# since the shortest route needs 4 units of fuel.\n# \n# Example 4:\n# \n# \n# Input: locations = [2,1,5], start = 0, finish = 0, fuel = 3\n# Output: 2\n# Explanation:\u00a0There are two possible routes, 0 and 0 -> 1 -> 0.\n# \n# Example 5:\n# \n# \n# Input: locations = [1,2,3], start = 0, finish = 2, fuel = 40\n# Output: 615088286\n# Explanation: The total number of possible routes is 2615088300. Taking this\n# number modulo 10^9 + 7 gives us 615088286.\n# \n# \n# \n# Constraints:\n# \n# \n# 2 <= locations.length <= 100\n# 1 <= locations[i] <= 10^9\n# All integers in\u00a0locations\u00a0are\u00a0distinct.\n# 0 <= start, finish <\u00a0locations.length\n# 1 <= fuel <= 200\n# \n# \n#\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dp(i, f):\n            if f < 0: return 0 \n            if f == 0: return 1 if i == finish else 0\n            ans = 1 if i == finish else 0\n            for j in range(0, len(locations)):\n                if j != i and f >= abs(locations[j] - locations[i]):\n                    ans += dp(j, f - abs(locations[i] - locations[j])) % MOD \n            \n            return ans % MOD \n        return dp(start, fuel)\n\n        \n\nsol = Solution()\n\n\nlocations, start, finish, fuel = [2,3,6,8,4], 1, 3, 5\n# locations, start, finish, fuel = [4,3,1], 1, 0, 6\n# locations, start, finish, fuel = [5,2,1], 0, 2, 3\n# locations, start, finish, fuel = [2,1,5], 0, 0, 3\n# locations, start, finish, fuel = [1,2,3], 0, 2, 40\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        \n        @lru_cache(maxsize=None)\n        def dp(cur, finish, fuel):\n            if fuel < 0:\n                return 0\n            ans = 1 if cur == finish else 0\n            for nextCity, val in enumerate(locations):\n                if nextCity != cur:\n                    ans += dp(nextCity, finish, fuel - abs(val - locations[cur]))\n            return ans % (10 ** 9 + 7)\n        return dp(start, finish, fuel)", "from functools import lru_cache\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10**9 + 7\n        @lru_cache(None)\n        def dfs(curr, fuel):\n            if fuel < 0:\n                return 0\n            \n            res = 1 if curr == finish else 0\n            for i, loc in enumerate(locations):\n                if i == curr:\n                    continue\n                fuel_used = abs(loc - locations[curr])\n                res += dfs(i, fuel - fuel_used)\n            return res % MOD\n        \n        res = dfs(start, fuel)\n        return res % MOD\n                \n                \n            \n", "class Solution:\n    def countRoutes(self, locations, start: int, finish: int, fuel: int) -> int:\n        def dfs(index,current_fuel):\n            if not current_fuel and index==finish: return 1\n            paths=index==finish\n            for i,n in enumerate(locations):\n                if i!=index:\n                    tmp_fuel=current_fuel-abs(locations[index]-n)\n                    if (i,tmp_fuel) in memo: paths+=memo[(i,tmp_fuel)]\n                    elif tmp_fuel>=0:paths+=dfs(i,tmp_fuel)\n            memo[(index,current_fuel)]=paths\n            return paths\n        memo={}\n        return dfs(start,fuel)%(10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        M = 1000000007\n        @lru_cache(None)\n        def f(idx, fuel):\n            if fuel < 0: return 0\n            cnt = 1 if idx == start else 0\n            for i, val in enumerate(locations):\n                if i == idx: continue\n                if abs(val - locations[idx]) <= fuel:\n                    cnt = (cnt + f(i, fuel-abs(val-locations[idx]))) % M\n            return cnt % M\n        \n        return f(finish, fuel)\n", "class Solution:\n  def countRoutes(self, x: List[int], start: int, finish: int, fuel: int) -> int:    \n    @lru_cache(None)\n    def dp(i, f):\n      if f < 0: return 0\n      return (sum(dp(j, f - abs(x[i] - x[j])) \n                 for j in range(len(x)) if i != j) + (i == finish)) % (10**9 + 7)\n    return dp(start, fuel)\n", "sys.setrecursionlimit(1000000)\n\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        start, finish = locations[start], locations[finish]\n        if abs(finish - start) > fuel:\n            return 0\n        locations = [x for x in locations if abs(x - start) <= fuel]\n\n        @lru_cache(None)\n        def dfs(u, fuel):\n            res = 0\n            if u == finish:\n                res += 1\n            for v in locations:\n                if v != u:\n                    cost = abs(v - u)\n                    if cost <= fuel:\n                        res += dfs(v, fuel - cost)\n            return res % MOD\n\n        return dfs(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        return foo(locations, start, finish, fuel)\n\nfrom functools import lru_cache\ndef foo(cities, start, end, f):\n    n = len(cities)\n    @lru_cache(maxsize=None)\n    def bar(i, f):\n        rv = 0\n        if f < 0:\n            return 0\n        if i == end:\n            rv += 1\n        return rv + sum(bar(j, f - abs(cities[j] - cities[i])) for j in range(n) if i != j)\n    return bar(start, f) % (10**9 + 7)", "from functools import lru_cache\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        \\\"\\\"\\\"\n        @lru_cache(None)\n        def dp(i, fuel):\n            if fuel < 0: return\n            \n            if i == finish:\n                self.ans += 1\n                \n            for k, v in enumerate(locations):\n                if k != i:\n                    dp(k, fuel - abs(v - locations[i]))\n                \n            \n        self.ans = 0\n        dp(start, fuel)\n        return self.ans % (10**9 + 7)\n        \\\"\\\"\\\"\n        \n        \n        @lru_cache(None)\n        def dp(i, fuel):\n            if fuel < 0: return 0\n            \n            res = 0\n            if i == finish:\n                res += 1\n                \n            res += sum(dp(k, fuel - abs(v - locations[i])) for k, v in enumerate(locations) if k != i)\n            \n            return res\n        \n        return dp(start, fuel) % (10**9 + 7)\n        ", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10**9 + 7\n        @lru_cache(None)\n        def dfs(i, j, f):\n            res = 0\n            if i == j:\n                res += 1\n            if f < 0:\n                return 0\n            for k in range(len(locations)):\n                if i == k:\n                    continue\n                res += dfs(k, j, f - abs(locations[k] - locations[i]))\n            return res\n        return dfs(start, finish, fuel) % mod", "class Solution:\n    def countRoutes(self, loc: List[int], start: int, finish: int, fuel: int) -> int:\n        @functools.lru_cache(None)\n        def helper(i, f):\n            if i == finish:\n                return 1 + sum(helper(j, f-abs(loc[i]-loc[j])) for j in range(len(loc)) if (j != i) and (f >= abs(loc[i]-loc[j])))\n            return sum(helper(j, f-abs(loc[i]-loc[j])) for j in range(len(loc)) if (j != i) and (f >= abs(loc[i]-loc[j])))\n        return helper(start, fuel) % (10**9 + 7)", "class Solution:\n    \\\"\\\"\\\"\n    @lru_cache(None)\n    def dfs(i: int, f: int) -> int:\n        ans = 1 if i==finish else 0\n        for j in range(len(locations)):\n            diff = abs(locations[j]-locations[i])\n            if j==i:\n                continue\n            elif diff<=f:\n                ans += dfs(j, f-diff)                 \n        return ans\n\n    return dfs(start, fuel) % (10**9+7)\n    \\\"\\\"\\\"\n    def countRoutes(self, l: List[int], start: int, fin: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dfs(i: int, f: int) -> int:\n            return 0 if f < 0 else (1 if i == fin else 0) + sum(0 if i == j else dfs(j, f - abs(l[j] - l[i])) for j in range(len(l)))\n        return dfs(start, fuel) % 1000000007\n", "from functools import lru_cache\nimport bisect\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10**9+7\n        \n        start_pos = locations[start]\n        finish_pos = locations[finish]\n        \n        locations.sort()\n        i = bisect.bisect_left(locations,start_pos)\n        j = bisect.bisect_left(locations,finish_pos)\n        n = len(locations)\n\n        @lru_cache(None)\n        def ways(i,j,fuel):\n            if fuel < abs(locations[i]-locations[j]): return 0\n            res = 0\n            l = r = 1\n            if i == j: res += 1\n            while i-l >= 0:\n                if fuel - abs(locations[i-l]-locations[j]) < 0: break\n                res += ways(i-l,j,fuel-abs(locations[i-l]-locations[i]))\n                res %= mod\n                l += 1\n            while i+r < n:\n                if fuel - abs(locations[i+r]-locations[j]) < 0: break\n                res += ways(i+r,j,fuel-abs(locations[i+r]-locations[i]))\n                res %= mod\n                r += 1\n            return res%mod\n            \n        return ways(i,j,fuel)", "class Solution:\n    def countRoutes(self, locations, start: int, finish: int, fuel: int) -> int:\n        def dfs(index,current_fuel):\n            if not current_fuel and index==finish: return 1\n            paths=index==finish\n            for i,n in enumerate(locations):\n                if i==index: continue\n                tmp_fuel=current_fuel-abs(locations[index]-n)\n                if (i,tmp_fuel) in memo: paths+=memo[(i,tmp_fuel)]\n                elif tmp_fuel>=0:paths+=dfs(i,tmp_fuel)\n            memo[(index,current_fuel)]=paths\n            return paths\n        memo={}\n        return dfs(start,fuel)%(10**9+7)", "from functools import lru_cache\n\nclass Solution:\n    M = 10**9 + 7\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(maxsize=None)\n        def R(dest, f):\n            if f > 0:\n                return (sum(R(i, f - abs(locations[i] - locations[dest]))\n                            for i in range(len(locations)) if i != dest)\n                        + int(dest == start)\n                       ) % self.M\n            return int(f == 0 and dest == start)\n        \n        return R(finish, fuel)", "class Solution:\n    def countRoutes(self, l: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dfs(i: int, f: int) -> int:\n            return 0 if f < 0 else (1 if i == finish else 0) + sum(0 if i == j else dfs(j, f - abs(l[j] - l[i])) for j in range(len(l)))\n        return dfs(start, fuel) % 1000000007", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        m = len(locations)\n        n = fuel+1\n        dp = [[0]*n for _ in range(m)]\n        dp[start][fuel] = 1\n        \n        for fuel in reversed(range(1, n)):\n            for end in range(m):\n                if dp[end][fuel] > 0:\n                    for nxt in range(m):\n                        cost = abs(locations[end] - locations[nxt])\n                        if fuel >= cost and end != nxt:\n                            dp[nxt][fuel-cost] += dp[end][fuel]\n\n        return sum(dp[finish]) % (int(1e9) + 7)", "sys.setrecursionlimit(1000000)\n\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        start, finish = locations[start], locations[finish]\n        if abs(finish - start) > fuel:\n            return 0\n        locations = [x for x in locations if abs(x - start) <= fuel]\n        # print(start, finish)\n\n        @lru_cache(None)\n        def dfs(u, fuel):\n            res = 0\n            if u == finish:\n                res += 1\n            for v in locations:\n                if v != u:\n                    cost = abs(v - u)\n                    if cost <= fuel:\n                        res += dfs(v, fuel - cost)\n            return res % MOD\n\n        return dfs(start, fuel)", "from functools import lru_cache\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        \\\"\\\"\\\"\n        def dp(i, fuel):\n            if fuel < 0: return\n            if i == finish:\n                self.ans += 1\n                \n            for k, v in enumerate(locations):\n                if k != i:\n                    dp(k, fuel - abs(v - locations[i]))\n                \n            \n        self.ans = 0\n        dp(start, fuel)\n        return self.ans % (10**9 + 7)\n        \\\"\\\"\\\"\n        \n        \n        \n        \n        @lru_cache(None)\n        def dp(i, fuel):\n            if fuel < 0: return 0\n            \n            res = 0\n            if i == finish:\n                res += 1\n                \n            res += sum(dp(k, fuel - abs(v - locations[i])) for k, v in enumerate(locations) if k != i)\n            \n            return res\n        \n        return dp(start, fuel) % (10**9 + 7)\n        ", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dfs(i: int, f: int) -> int:\n            return 0 if f < 0 else (1 if i == finish else 0) + sum(0 if i == j else dfs(j, f - abs(locations[j] - locations[i])) for j in range(len(locations)))\n        return dfs(start, fuel) % 1000000007\n        # dp = [[-1 for _ in range(fuel+1)] for _ in locations]\n        # def search(start, fuel):\n        #     if fuel == 0:\n        #         if start == finish:\n        #             return 1\n        #         return 0\n        #     if dp[start][fuel] != -1:\n        #         return dp[start][fuel]\n        #     dp[start][fuel] = 1 if start == finish else 0\n        #     for i in range(len(locations)):\n        #         left = fuel - abs(locations[i] - locations[start])\n        #         if i != start and left >= 0:\n        #             dp[start][fuel] += search(i, left) \n        #     return dp[start][fuel] % 1000000007\n        # return search(start, fuel) % 1000000007\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10**9 + 7\n        \n        @functools.lru_cache(maxsize=None)\n        def dp(city: int, tank: int) -> int:\n            return ((1 if city == finish else 0) + sum(dp(i, tank - abs(locations[city] - locations[i])) for i in range(len(locations)) if i != city)) % MOD if tank >= 0 else 0\n        \n        return dp(start, fuel)", "class Solution:\n    def countRoutes(self, A, s: int, e: int, fuel) -> int:\n        @lru_cache(None)\n        def dfs(i: int, f: int) -> int:\n            return 0 if f < 0 else (1 if i == e else 0) + sum(0 if i == j else dfs(j, f - abs(A[j] - A[i])) for j in range(len(A)))\n        return dfs(s, fuel) % 1000000007", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[-1]*(fuel+1) for i in range(len(locations))]\n        def dfs(start,fuel):\n            if fuel<0:\n                return 0\n            if dp[start][fuel]>-1:\n                return dp[start][fuel]\n            if start==finish:\n                res=1\n            else:\n                res=0\n            for i in range(len(locations)):\n                if i!=start:\n                    res+=dfs(i,fuel-abs(locations[i]-locations[start]))\n            dp[start][fuel]=res%(10**9+7)  \n            return dp[start][fuel]\n             \n        return dfs(start,fuel)\n    \n    \n", "class Solution:\n    def countRoutes(self, l: List[int], start: int, fin: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dfs(i: int, f: int) -> int:\n            if f < 0:\n                return 0\n            return (1 if i == fin else 0) + sum(0 if i == j else dfs(j, f - abs(l[j] - l[i])) for j in range(len(l)))\n                                                 \n        return dfs(start, fuel) % 1000000007", "class Solution:\n    def countRoutes(self, l: List[int], start: int, fin: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dfs(i: int, f: int) -> int:\n            return 0 if f < 0 else (1 if i == fin else 0) + sum(0 if i == j else dfs(j, f - abs(l[j] - l[i])) for j in range(len(l)))\n\n        return dfs(start, fuel) % 1000000007\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(None)\n        def dfs(i: int, f: int) -> int:\n            return 0 if f < 0 else (1 if i == finish else 0) + sum(0 if i == j else dfs(j, f - abs(locations[j] - locations[i])) for j in range(len(locations)))\n\n        return dfs(start, fuel) % 1000000007", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        R = 10 ** 9 + 7\n        N = len(locations)\n        \n        @functools.lru_cache(maxsize=None)\n        def dp(i, fuel):\n            res = 1 if i == finish else 0\n            for j in range(N):\n                if j != i:\n                    cost = abs(locations[i] - locations[j])\n                    if fuel >= cost:\n                        res = (res + dp(j, fuel - cost)) % R\n            return res\n        \n        return dp(start, fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        from functools import lru_cache\n        @lru_cache(None)\n        def solve(curCity,fuel):\n            if fuel<0:\n                return 0\n            ans = 1 if curCity==finish else 0\n            for nextCity in range(0,len(locations)):\n                if nextCity!=curCity:\n                    ans = (ans+solve(nextCity,fuel-abs(locations[curCity]-locations[nextCity])))%(1000000007)\n            return ans\n        return solve(start,fuel)", "sys.setrecursionlimit(1000000)\n\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        start, finish = locations[start], locations[finish]\n        if abs(finish - start) > fuel:\n            return 0\n        locations = [x for x in locations if abs(x - start) <= fuel]\n\n        @lru_cache(None)\n        def dfs(u, fuel):\n            res = 1 if u == finish else 0\n            for v in locations:\n                if v != u:\n                    cost = abs(v - u)\n                    if cost <= fuel:\n                        res += dfs(v, fuel - cost)\n            return res % MOD\n\n        return dfs(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dfs(i: int, f: int) -> int:\n            return 0 if f < 0 else (1 if i == finish else 0) + sum(0 if i == j else dfs(j, f - abs(locations[j] - locations[i])) for j in range(len(locations)))\n        return dfs(start, fuel) % 1000000007", "from functools import lru_cache\n\nclass Solution:\n    def countRoutes(self, A: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(None)\n        def helper(i, fuel):\n            if fuel < 0:\n                return 0\n            \n            res = 0\n            if i == finish:\n                res += 1\n                \n            for nxt in range(len(A)):\n                if nxt != i:\n                    res = (res + helper(nxt, fuel - abs(A[i] - A[nxt]))) % 1000000007\n            return res\n\n        return helper(start, fuel)\n", "class Solution:\n    # https://leetcode.com/problems/count-all-possible-routes/discuss/851114/Simple-Python-code-with-explanation\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        from functools import lru_cache\n        @lru_cache(None)\n        \n        def helper(loc, fuel):\n            if loc == finish and fuel == 0:\n                return 1\n            elif loc != finish and fuel == 0:\n                return 0\n            \n            s = 0\n            if loc == finish:\n                s = 1\n            for i in range(length):\n                if i == loc:\n                    continue\n                dist = abs(locations[i]-locations[loc])\n                if dist <= fuel:\n                    s = (s + helper(i, fuel-dist)) % MOD\n            return s\n        \n        MOD = 10**9 + 7\n        length = len(locations)\n        return helper(start, fuel)", "class Solution:\n    def countRoutes(self, l: List[int], start: int, fin: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dfs(i: int, f: int) -> int:\n            return 0 if f < 0 else (1 if i == fin else 0) + sum(0 if i == j else dfs(j, f - abs(l[j] - l[i])) for j in range(len(l)))\n        return dfs(start, fuel) % 1000000007", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        mod = 10**9 + 7\n        @lru_cache(None)\n        def go(x, remain):\n            #print(x, remain)\n                \n            if remain < 0:\n                return 0\n            \n            ret = 0\n            if x == finish:\n                ret = 1\n                    \n            for i in range(0, n):\n                if i == x:\n                    continue\n                ret += go(i,remain - abs(locations[x] - locations[i]))\n                ret %= mod\n                \n            return ret % mod\n        \n        ans = go(start, fuel) % mod\n        \n        return ans\n                \n        \n        \n", "class Solution:\n    def countRoutes(self, l: List[int], st: int, fin: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dfs(i, f):\n            return 0 if f < 0 else (1 if i == fin else 0) + sum(0 if i == j else dfs(j, f - abs(l[i]-l[j]) ) for j in range(len(l)))\n        return dfs(st, fuel) % 1000000007\n", "class Solution:\n    def countRoutes(self, l: List[int], st: int, fin: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dfs(i, f):\n            return 0 if f < 0 else (1 if i == fin else 0) + sum(0 if i == j else dfs(j, f - abs(l[i]-l[j]) ) for j in range(len(l)))\n        return dfs(st, fuel) % 1000000007\n        \n        \n    # def countRoutes(self, l: List[int], start: int, fin: int, fuel: int) -> int:\n    #     @lru_cache(None)\n    #     def dfs(i: int, f: int) -> int:\n    #         return 0 if f < 0 else (1 if i == fin else 0) + sum(0 if i == j else dfs(j, f - abs(l[j] - l[i])) for j in range(len(l)))\n    #     return dfs(start, fuel) % 1000000007        \n", "class Solution:\n    def countRoutes(self, l: List[int], start: int, fin: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dfs(i: int, f: int) -> int:\n            return 0 if f < 0 else (1 if i == fin else 0) + sum(0 if i == j \\\\\n                            else dfs(j, f - abs(l[j] - l[i])) for j in range(len(l)))\n        return dfs(start, fuel) % 1000000007", "class Solution:\n    def countRoutes(self, locations, start: int, finish: int, fuel: int) -> int:\n        def dfs(index,current_fuel):\n            if not current_fuel and index==finish: return 1\n            paths=index==finish\n            for i,n in enumerate(locations):\n                if i^index:\n                    tmp_fuel=current_fuel-abs(locations[index]-n)\n                    if (i,tmp_fuel) in memo: paths+=memo[(i,tmp_fuel)]\n                    elif tmp_fuel>=0:paths+=dfs(i,tmp_fuel)\n            memo[(index,current_fuel)]=paths\n            return paths\n        memo={}\n        return dfs(start,fuel)%(10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        ln = len(locations)\n        mod = 10**9 + 7\n        @functools.lru_cache(None)\n        def dp(cur, fuel):\n            if fuel < 0:return 0\n            ans = 1 if cur == finish else 0\n            \n            for city in range(ln):\n                if city != cur:\n                    ans += dp(city, fuel - abs(locations[city] - locations[cur]))\n                    ans %= mod\n            \n            return ans\n        \n        return dp(start, fuel)", "class Solution:\n    #1575\n    #1575\n    def countRoutes(self, locations: 'List[int]', start: int, finish: int, fuel: int) -> int:\n        MOD = 1000000007\n        sp,ep = locations[start], locations[finish]\n        locations.sort()\n        s, e = locations.index(sp), locations.index(ep)\n        if s > e: s,e=e,s\n        N = len(locations)\n        @functools.lru_cache(None)\n        def helper(i, f):\n            if i!=e and locations[e]-locations[i] <= f:\n                res = 1\n            else:\n                res = 0\n            k = i-1\n            while k>=0 and locations[i]+locations[e]-2*locations[k] <= f:\n                res += helper(k, f-(locations[i]-locations[k]))\n                k -= 1\n            k = i + 1\n            while k<N and locations[k]-locations[i]+abs(locations[k]-locations[e]) <= f:\n                res += helper(k, f-(locations[k]-locations[i]))\n                k += 1\n            return res%MOD\n        return helper(s,fuel) + (s==e)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        import sys\n        sys.setrecursionlimit(10**9)\n\\t\\t\n        M = 10**9+7\n        @lru_cache(None)\n        def helper(curr_city, curr_fuel):\n            if curr_fuel<0:\n                return 0 \n            \n            ans = 0\n            if curr_city==finish:\n                ans += 1\n            \n            for i in range(len(locations)):\n                if i!=curr_city:\n                    ans += helper(i, curr_fuel - abs(locations[i]-locations[curr_city]))\n                    ans %= M\n            \n            return ans\n        \n        return helper(start, fuel)\n        ", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        N, R = len(locations), 10**9 + 7\n        dp = [[-1] * (fuel + 1) for _ in range(N)]\n\n        def _dfs(p, f):\n            if dp[p][f] < 0:\n                dp[p][f] = 0\n                for q in range(N):\n                    if q == p: continue\n                    left = f - abs(locations[p] - locations[q])\n                    if left < abs(locations[finish] - locations[q]):\n                        continue\n                    dp[p][f] += _dfs(q, left)\n                dp[p][f] += 1 if p == finish else 0\n            return dp[p][f] % R\n\n        return _dfs(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        n = len(locations)\n\n        \n        graph = defaultdict(list)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                cost = abs(locations[i] - locations[j])\n                graph[i].append((j, cost))\n                graph[j].append((i, cost))\n                \n                \n                \n        @lru_cache(None)\n        def dfs(i, budget):\n            if budget < 0:\n                return 0\n            \n            res = 1 if i == finish else 0\n            if budget == 0:\n                return res\n            \n            for nei, cost in graph[i]:\n                res += dfs(nei, budget - cost)\n                res %= MOD\n                \n            return res         \n                \n        \n        res = dfs(start, fuel)\n        \n        return res % MOD", "class Solution:\n    def countRoutes(self, arr: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(arr)\n        mod = 10**9+7\n        @lru_cache(None)\n        def f(curr, fu):\n            ans = int(curr == finish)\n            for i in range(n):\n                if i != curr:\n                    if abs(arr[i] - arr[curr]) <= fu:\n                        ans += f(i, fu - abs(arr[i] - arr[curr]))\n                        ans %= mod\n            return ans\n        return f(start, fuel)\n                    \n                \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10**9 + 7\n        \n        @functools.lru_cache(maxsize=None)\n        def dp(city: int, tank: int) -> int:\n            if tank < 0:\n                return 0\n            answer = (1 if city == finish else 0)\n            for i in range(len(locations)):\n                if i != city:\n                    answer += dp(i, tank - abs(locations[city] - locations[i]))\n                    answer %= MOD\n            return answer\n        \n        return dp(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[-1] * (fuel + 1) for _ in range(len(locations))]\n        def f(cur, cur_fuel):\n            if dp[cur][cur_fuel] != -1:\n                return dp[cur][cur_fuel]\n            \n            total = 1 if cur == finish else 0\n            for i, location in enumerate(locations):\n                if i == cur:\n                    continue\n                dist = abs(locations[i] - locations[cur])\n                if dist <= cur_fuel:\n                    total += f(i, cur_fuel - dist)\n            dp[cur][cur_fuel] = total\n\n            return total \n        return f(start, fuel) % 1_000_000_007\n                    \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[0 for x in range(len(locations))] for _ in range(fuel+1)]\n\n        #At the begining there is one way of getting to start point without using any fuel\n        dp[0][start] = 1\n\n        for i in range(1,fuel+1):\n            for j in range(len(locations)):\n                #k is origin from where I go to location j\n                for k in range(len(locations)):\n                    if j!=k:\n                        need = abs(locations[j]-locations[k])\n                        if need <= i:\n                            dp[i][j] += dp[i-need][k]\n\n        ans = 0\n        #Sum up over all paths leading to finish, for every possible amount of fuel\n        for i in range(fuel+1):\n            ans += dp[i][finish]\n\n        return ans % (10**9 + 7)\n\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        M = 10**9+7\n        @lru_cache(None)\n        def helper(curr_city, curr_fuel):\n            if curr_fuel<0:\n                return 0 \n            \n            ans = 0\n            if curr_city==finish:\n                ans += 1\n            \n            for i in range(len(locations)):\n                if i!=curr_city:\n                    ans += helper(i, curr_fuel - abs(locations[i]-locations[curr_city]))\n                    ans %= M\n            \n            return ans\n        \n        return helper(start, fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(maxsize=None)\n        def count(start: int, fuel: int, MOD=10**9+7)->int:\n            #print(start, fuel)\n            if fuel < 0:\n                return 0\n            elif fuel == 0 and start == finish:\n                return 1\n            else:\n                ways = 1 if start == finish else 0\n                for i, loc in enumerate(locations):\n                    if i != start:\n                        ways = (ways+count(i, fuel-abs(loc-locations[start])))%MOD\n                #print(ways)\n                return ways\n            \n        return count(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(None)\n        def dfs(x, y, f):\n            if abs(A[x] - A[y]) > f:\n                return 0\n            ret = 0\n            if abs(A[x] - A[y]) <= f:\n                ret += 1\n            for mid in range(n):\n                g = abs(A[mid] - A[x]) + abs(A[mid] - A[y])\n                if mid == x or g > f:\n                    continue\n                ret += dfs(mid, y, f - abs(A[mid] - A[x]))\n                if mid == y:\n                    ret -= 1\n                ret %= MOD\n            return ret\n                \n        A = locations\n        n = len(A)\n        MOD = 10 ** 9 + 7\n        return dfs(start, finish, fuel)\n\n\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10**9 + 7\n        \n        @functools.lru_cache(maxsize=None)\n        def dp(city: int, tank: int) -> int:\n            nonlocal finish\n            if tank < 0:\n                return 0\n            answer = (1 if city == finish else 0)\n            for i in range(len(locations)):\n                if i != city:\n                    answer += dp(i, tank - abs(locations[city] - locations[i]))\n                    answer %= MOD\n            return answer\n        \n        return dp(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @functools.lru_cache(None)\n        def dp(start , fuel):\n            if fuel < 0: return 0\n            if abs(locations[start] - locations[finish])> fuel: return 0\n            return sum([dp(i,fuel-abs(locations[i]-locations[start])) for i in range(len(locations)) if i!=start]) + (start==finish)\n        return dp(start,fuel) % (10**9+7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        N = len(locations)\n        mod = (10**9)+7\n        \n        @lru_cache(None)\n        def rec(cur, rem):\n            if rem < 0:\n                return 0\n            ans = (cur == finish)\n            for i in range(N):\n                if i == cur:\n                    continue\n                nxt_rem = rem - abs(locations[cur] - locations[i])\n                ans += rec(i, nxt_rem)\n                if ans >= mod:\n                    ans -= mod\n            return ans\n        \n        return rec(start, fuel)", "class Solution:\n    def countRoutes(self, loc: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def get(cur, left):\n            if left < 0: return 0\n            res = 0\n            if cur == finish: res += 1\n            \n            for i in range(len(loc)):\n                if i == cur: continue\n                res += get(i, left - abs(loc[i] - loc[cur]))\n                res %= 1000000007\n            \n            return res\n        return get(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        @functools.lru_cache(None)\n        def dp(i, f):\n            ans = 0 if i != finish else 1\n            for j in range(n):\n                if i == j: continue\n                ff = abs(locations[i] - locations[j])\n                if f >= ff:\n                    ans += dp(j, f - ff)\n            return ans % (10 ** 9 + 7)\n        return dp(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        def go(pos, f, dp):\n            if f == 0:\n                return 1 if pos == finish else 0\n            if dp[pos][f] > -1:\n                return dp[pos][f]\n            ans = 1 if pos == finish else 0\n            for idx, loc in enumerate(locations):\n                if idx != pos:\n                    c = abs(locations[pos]-loc)\n                    ans += go(idx, f-c, dp) if f >= c else 0\n            dp[pos][f] = ans\n            return ans\n        \n        memo = [[-1]*(fuel+1) for _ in locations]\n        memo[finish][0] = 1\n        return go(start, fuel, memo) % (1000000007)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        N = len(locations)\n        mod = 1000000007\n\n        @lru_cache(None)\n        def dfs(city, fuel):\n            c = int(city == finish)\n            for i in range(N):\n                if i != city:\n                    cost = abs(locations[i]-locations[city])\n                    if cost <= fuel:\n                        c = (c + dfs(i, fuel-cost)) % mod\n            return c\n\n        return dfs(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # memo = {}\n        @lru_cache(None)\n        def dfs(start, finish, fuel):\n            if fuel < 0:\n                return 0\n            # if start in memo:\n            #     return memo[start]\n\n            routes = 1 if start == finish else 0\n            for i, location  in enumerate(locations):\n                if i == start:\n                    continue\n\n                routes += dfs(i, finish, fuel - abs(locations[i] - locations[start]))\n\n            # memo[start] = routes\n            return routes\n        \n        return dfs(start, finish, fuel) % (10**9 + 7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        def go(pos, f, dp):\n            if f == 0:\n                return 1 if pos == finish else 0\n            if dp[pos][f] > -1:\n                return dp[pos][f]\n            ans = 1 if pos == finish else 0\n            for idx, loc in enumerate(locations):\n                if idx != pos:\n                    c = abs(locations[pos]-loc)\n                    ans += go(idx, f-c, dp) if f >= c else 0\n            dp[pos][f] = ans\n            return ans\n        \n        memo = [[-1]*(fuel+1) for _ in locations]\n        memo[finish][0] = 1\n        return go(start, fuel, memo) % (10**9+7)\n", "import sys\nfrom functools import lru_cache\nsys.setrecursionlimit (10**6)\n\n\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def chal(st,fi,x):\n            if(x<0):\n                return 0\n            if(st==fi):\n                ans=1\n            else:\n                ans=0\n            for i in range(0,len(locations)):\n                if(i!=st):\n                    ans+=chal(i,fi,x-abs(locations[i]-locations[st]))%(10**9+7)\n            return ans %(10**9+7)\n        return chal(start,finish,fuel)\n", "import functools\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @functools.lru_cache(10**9)\n        def findRoutes(start, finish, fuel, n):\n            r=0\n            if(fuel<0): return 0\n            if(start == finish): r+=1\n            for i in range(n):\n                if(i != start):\n                    r += findRoutes( i, finish, fuel - abs(locations[i]-locations[start]), n)\n            return r\n        return findRoutes (start, finish, fuel,len(locations)) % (10**9 + 7)", "class Solution:\n    \\\"\\\"\\\"\n    You are given an array of distinct positive integers locations where locations[i] \n    represents the position of city i. You are also given integers start, finish and fuel\n    representing the starting city, ending city, and the initial amount of fuel you have,\n    respectively.\n\n    At each step, if you are at city i, you can pick any city j such that j != i and \n    0 <= j < locations.length and move to city j. Moving from city i to city j reduces\n    the amount of fuel you have by |locations[i] - locations[j]|. Please notice that |x|\n    denotes the absolute value of x.\n\n    Notice that fuel cannot become negative at any point in time, and that you are allowed\n    to visit any city more than once (including start and finish).\n\n    Return the count of all possible routes from start to finish.\n\n    Since the answer may be too large, return it modulo 10^9 + 7.\n\n    Example 1:\n\n    Input: locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5\n    Output: 4\n    Explanation: The following are all possible routes, each uses 5 units of fuel:\n    1 -> 3\n    1 -> 2 -> 3\n    1 -> 4 -> 3\n    1 -> 4 -> 2 -> 3\n\n    Example 2:\n\n    Input: locations = [4,3,1], start = 1, finish = 0, fuel = 6\n    Output: 5\n    Explanation: The following are all possible routes:\n    1 -> 0, used fuel = 1\n    1 -> 2 -> 0, used fuel = 5\n    1 -> 2 -> 1 -> 0, used fuel = 5\n    1 -> 0 -> 1 -> 0, used fuel = 3\n    1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5\n    \n    Example 3:\n\n    Input: locations = [5,2,1], start = 0, finish = 2, fuel = 3\n    Output: 0\n    Explanation: It's impossible to get from 0 to 2 using only 3 units of fuel since the shortest \n                 route needs 4 units of fuel.\n    \n    Example 4:\n\n    Input: locations = [2,1,5], start = 0, finish = 0, fuel = 3\n    Output: 2\n    Explanation: There are two possible routes, 0 and 0 -> 1 -> 0.\n    \n    Example 5:\n\n    Input: locations = [1,2,3], start = 0, finish = 2, fuel = 40\n    Output: 615088286\n    Explanation: The total number of possible routes is 2615088300. Taking this number \n                 modulo 10^9 + 7 gives us 615088286.\n\n    Constraints:\n\n    2 <= locations.length <= 100\n    1 <= locations[i] <= 10^9\n    All integers in locations are distinct.\n    0 <= start, finish < locations.length\n    1 <= fuel <= 200\n\n    Idea: Solve with dynamic programming in O(n^3 * F) where n = number of cities, F = fuel\n          N[i,j,f] = number of ways to get from i to j using f units of fuel\n          \n          N[i,j,f] = 0 if |locations[i] - locations[j]| > f\n          \n          If |locations[i] - locations[j]| == f, we can either go directly from i to j, or\n          stop at any (or none) of the locations in between the two, so \n          \n          N[i,j,f] = 2**B(i,j) where B(i,j) = number of locations between i and j\n                                            = |Rank(i) - Rank(j)| - 1\n          \n          Otherwise (distance < f):\n          \n          (A) We can go from i to k (k != i) and from k to j -> N[k,j,f-d(i,k)]\n          \n          N[i,j,f] = sum_{k != i} N[k,j,f-d(i,k)]\n          \n          Special case i == j, f >= 0:\n          \n          N[i,i,f] = 1 + sum_{k != i} N[k,i,f-d(i,k)]\n          \n          REVIEW\n    \\\"\\\"\\\"\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        N = dict()\n        n = len(locations)\n        # Compute the rank of each location\n        order = list(range(n))\n        order.sort(key = lambda x: locations[x])\n        ranks = [0]*n\n        for i in range(n):\n            ranks[order[i]] = i        \n        def computeNumber(i, j, f, locations, ranks, N):\n            distij = abs(locations[i] - locations[j])\n            if distij > f:\n                return 0\n            if distij == f:\n                if i == j:\n                    return 1\n                else:\n                    return 2**(abs(ranks[i]-ranks[j])-1)\n            if (i, j, f) not in N:\n                allWays = 0 if i != j else 1\n                for k in range(len(locations)):\n                    d = abs(locations[i] - locations[k])\n                    if d <= f and k != i:\n                        allWays += computeNumber(k,j,f-d,locations,ranks,N)\n                N[(i,j,f)] = allWays\n            return N[(i,j,f)]\n        sol =  computeNumber(start, finish, fuel, locations, ranks, N) % (10**9 + 7)\n        return sol", "class Solution:\n    def countRoutes(self, loc: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(None)\n        def dp(i, gas):\n            if gas < abs(loc[i]-loc[finish]):\n                return 0\n            \n            ans = 0\n            if i == finish:\n                ans += 1\n                \n            for nxt in range(len(loc)):\n                if nxt != i:\n                    ans += dp(nxt, gas-abs(loc[i]-loc[nxt]))\n            \n            return ans\n        \n        res = dp(start, fuel)\n        \n        return res % (10**9+7)\n            \n            \n            \n            \n            \n            \n", "class Solution:\n    def countRoutes(self, locacs: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[-1]*(fuel+1) for _ in range(len(locacs))]\n        def go(at, f):\n            if f <= 0:\n                return 1 if at == finish else 0\n            if dp[at][f] >= 0:\n                return dp[at][f]\n            ans = 1 if at == finish else 0\n            for to, loc in enumerate(locacs):\n                if to == at:\n                    continue\n                c = abs(locacs[at]-loc)\n                ans += go(to, f-c) if f >= c else 0\n            dp[at][f] = ans\n            return ans\n        return go(start, fuel) % (10**9+7)\n\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(None)\n        def go(i, f):\n            if f < 0:\n                return 0\n            if f == 0:\n                if i == finish:\n                    return 1\n                return 0\n            \n            count = 0\n            if i == finish:\n                count += 1\n                \n            for j in range(len(locations)):\n                if i != j:\n                    count += go(j, f - abs(locations[i] - locations[j]))\n            return count\n        \n        return go(start, fuel) % (10 ** 9 + 7)\n", "from functools import lru_cache\n\nclass Solution:\n    \n    @lru_cache(None)\n    def dp(self, start, fuel):\n        r = 0\n        if fuel < 0: return 0\n        if start == self.finish: r+= 1\n        for l in self.locations:\n            if start == l: continue\n            r += self.dp(l, fuel - abs(start - l))\n        #print(start, fuel, r, self.finish)\n        return r\n    \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        #print(\\\"===\\\")\n        self.finish = locations[finish]\n        self.locations = locations\n        return self.dp(locations[start], fuel) % (10**9 + 7)\n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n\n        n = len(locations)\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(used, node):\n                if used > fuel: return 0\n                #\u5230\u8fbe\u4e86\u7ec8\u70b9\uff0c\u8981\u52a0\u4e00\n                res = 1 if node == finish else 0\n                \n                #\u5c31\u7b97\u5230\u8fbe\u4e86\u7ec8\u70b9\u4e5f\u4e0d\u80fdreturn\uff0c\u8fd8\u5f97\u7ee7\u7eed\u8dd1\n                for nxt in range(n):\n                    if node == nxt: continue\n                    nused = used + abs(locations[node] - locations[nxt])\n                    res += dp(nused, nxt) % MOD\n                return res\n            \n        return dp(0, start) % MOD", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n\n        n = len(locations)\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(used, node):\n                if used > fuel: return 0\n                res = 1 if node == finish else 0\n                    \n                for nxt in range(n):\n                    if node == nxt: continue\n                    nused = used + abs(locations[node] - locations[nxt])\n                    res += dp(nused, nxt) % MOD\n                return res\n            \n            \n        return dp(0, start) % MOD", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[-1 for _ in range(fuel+1)] for _ in locations]\n        def search(start, fuel):\n            if fuel == 0:\n                if start == finish:\n                    return 1\n                return 0\n            if dp[start][fuel] != -1:\n                return dp[start][fuel]\n            dp[start][fuel] = 1 if start == finish else 0\n            for i in range(len(locations)):\n                left = fuel - abs(locations[i] - locations[start])\n                if i != start and left >= 0:\n                    dp[start][fuel] += search(i, left) \n            return dp[start][fuel] % 1000000007\n        search(start, fuel)\n        return dp[start][fuel] % 1000000007", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        if abs(locations[start] - locations[finish]) > fuel: return 0\n        mod = 10**9 + 7\n        \n        @lru_cache(None)\n        def dfs(node, fu):\n            an = 0\n            if node == finish:\n                an += 1\n            for i in range(len(locations)):\n                if i != node and abs(locations[node] - locations[i])<= fu:\n                    an += dfs(i,fu - abs(locations[node] - locations[i]))\n            return an\n        return dfs(start,fuel)%mod\n                \n", "from functools import lru_cache\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10 ** 9 + 7\n        @lru_cache(None)\n        def dfs(pos, f):\n            out = 0\n            if pos == finish:\n                out += 1\n            for i, x in enumerate(locations):\n                if i != pos and f >= abs(x - locations[pos]):\n                    out += dfs(i, f - abs(x - locations[pos]))\n                    out %= mod\n            return out\n        \n        return dfs(start, fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        modulo = 10 ** 9 + 7\n        n = len(locations)\n        start_pos, finish_pos = locations[start], locations[finish]\n        locations.sort()\n        start = locations.index(start_pos)\n        finish = locations.index(finish_pos)\n        # print()\n        # print(locations)\n        # print(start, finish)\n        @lru_cache(None)\n        def dp(cur, fuel):\n            res = 0\n            if cur == finish:\n                res += 1\n            for nxt in range(cur + 1, n):\n                if nxt < 0 or nxt >= n:\n                    continue\n                if abs(locations[nxt] - locations[cur]) > fuel:\n                    break\n                res += dp(nxt, fuel - abs(locations[nxt] - locations[cur]))\n            for nxt in range(cur - 1, -1, -1):\n                if nxt < 0 or nxt >= n:\n                    continue\n                if abs(locations[nxt] - locations[cur]) > fuel:\n                    break\n                res += dp(nxt, fuel - abs(locations[nxt] - locations[cur]))\n            # print(cur, fuel, res)\n            return res % modulo\n        return dp(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        \n        memo={}\n        def dfs(x,left_fuel):\n            if (x,left_fuel) in memo:\n                return memo[(x,left_fuel)]\n            s=0\n            if x==finish:\n                s+=1\n            for i in range(len(locations)):\n                if x==i:\n                    continue\n                needed=abs(locations[x]-locations[i])\n                #print(needed,left_over)\n                if left_fuel>=needed:\n                    s+=dfs(i,left_fuel-needed)\n                \n            \n            memo[(x,left_fuel)]=s\n            return s\n            \n        return dfs(start,fuel)%((10**9)+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        start_pos = locations[start]\n        finish_pos = locations[finish]\n        \n        locations.sort()\n        for i,location in enumerate(locations):\n            if location == start_pos:\n                start = i\n            if location == finish_pos:\n                finish = i\n                \n        @lru_cache(None)\n        def dfs(i,j,f):\n            if f < 0:\n                return 0\n            if abs(locations[i] - locations[j]) > f:\n                return 0\n            \n            l = locations[i] - f\n            r = locations[i] + f\n            li = bisect.bisect_left(locations,  l)\n            ri = bisect.bisect_right(locations, r)\n            \n            ans = 1 if i == j else 0\n            for k in range(li, ri):\n                if k != i:\n                    ans += dfs(k, j, f - abs(locations[i] - locations[k]))\n            return ans\n        \n        return dfs(start, finish, fuel) % (10 ** 9 + 7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(None)\n        def fn(n, x): \n            \\\"\\\"\\\"Return all possible routes from n to finish with x fuel.\\\"\\\"\\\"\n            if x < 0: return 0 # not going anywhere without fuel \n            ans = 0\n            if n == finish: ans += 1\n            for nn in range(len(locations)): \n                if nn != n: ans += fn(nn, x-abs(locations[n] - locations[nn]))\n            return ans \n        \n        return fn(start, fuel) % 1_000_000_007\n\n# class Solution:\n#     def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n#         self.sol = [[-1]*(fuel+1)]*len(locations)\n#         self.dfs(start, fuel, locations, finish, 0)\n#         print(self.sol)\n    \n#     def dfs(self, current, fuel, locations, end, local_ans):\n#         print(self.sol)\n#         if fuel<0:\n#             return 0\n#         if self.sol[current][fuel]==-1:\n#             ans = 1 if current==end else 0\n#             for index, i in enumerate(locations):\n#                 if index==current:\n#                     continue\n#                 cost = abs(locations[current]-i)\n#                 a = self.dfs(index, fuel-cost, locations, end, local_ans)\n#                 ans = ans + a\n#             print(ans)\n#             self.sol[current][fuel] = ans\n#         return self.sol[current][fuel]\n\n\n    \n    \n# private long solve(int[] locations, int curCity, int e, long[][] dp, int fuel) {\n#         // 4. There is no further way left.\n#         if (fuel < 0) return 0;\n#         if (dp[curCity][fuel] != -1) return dp[curCity][fuel];\n#         // 3. Now, if we have atleast 1 way of reaching `end`, add 1 to the answer. But don't stop right here, keep going, there might be more ways :)\n#         long ans = (curCity == e) ? 1 : 0;\n#         for (int nextCity = 0; nextCity < locations.length; ++nextCity) {\n#             // 1. Visit all cities except `curCity`.\n#             if (nextCity != curCity) {\n#                 // 2. Continue this process recursively.\n#                 ans = (ans + solve(locations, nextCity, e, dp, fuel - Math.abs(locations[curCity] - locations[nextCity]))) % 1000000007;\n#             }\n#         }\n#         return dp[curCity][fuel] = ans;\n#     }", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        ans =0 \n        MOD = 10**9+7\n        \n        def fun(ind,arr,rem,target):\n            \n            if dp[ind][rem]!=None:\n                return dp[ind][rem]\n            \n            cnt = 0\n            if ind ==target:\n                cnt+=1\n            \n            for i,val in enumerate(arr):\n                if i==ind:\n                    continue\n                if abs(arr[ind]-val)<=rem:\n                    cnt+=fun(i,arr,rem-abs(arr[ind]-val),target)\n            dp[ind][rem] =cnt%(10**9+7)\n            return dp[ind][rem]\n        dp = [[None]*(1+fuel) for _ in range(len(locations))]\n        return fun(start,locations,fuel,finish)", "class Solution:\n    def countRoutes(self, a: List[int], start: int, finish: int, fuel: int) -> int:\n        mod=10**9+7\n        ans=0\n        start=a[start]\n        finish=a[finish]\n        @lru_cache(None)\n        def solve(c,f):\n            if f<0:\n                return 0\n            ans=0\n            if c==finish:\n                ans+=1\n            for x in a:\n                if x==c:\n                    continue\n                ans+=solve(x,f-abs(x-c))\n            return ans%mod\n\n        return solve(start,fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # \u4f7f\u7528DP\u8bb0\u5fc6\u6570\u636e\uff0c\u53ef\u4ee5\u5728\u65f6\u95f4\u590d\u6742\u5ea6\u4e0d\u90a3\u4e48\u9ad8\u7684\u524d\u63d0\u4e0b\u89e3\u51b3\u95ee\u9898\n        # dp\u4f5c\u4e3a\u7f13\u5b58\u6570\u636e\uff0c\u5b58\u50a8\u4e86\u5230\u8fbe\u5f53\u524d\u5730\u70b9\u548c\u5269\u4f59\u71c3\u6599\u53ef\u4ee5\u5230\u8fbe\u7ec8\u70b9\u7684\u8def\u5f84\u6570\n        # dp\u7684\u884cid\u4e3a\u5730\u70b9\n        # dp\u7684\u5217id\u4e3a\u5269\u4f59\u71c3\u6599\n        dp = [[-1]*(fuel+1) for _ in range(len(locations))]\n        \n        def route(st, ed, fuel):\n            if dp[st][fuel] > -1: return dp[st][fuel]\n            res = 0 if st!= ed else 1\n            for i in range(len(locations)):\n                if i != st and fuel-abs(locations[st]-locations[i]) >=0:\n                    res += route(i, ed, fuel-abs(locations[st]-locations[i]))\n            dp[st][fuel] = res % 1000000007\n            return dp[st][fuel]\n        # print(dp)\n        return route(start, finish, fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        N = len(locations)\n        @lru_cache(None)\n        def dp(i, fuel):\n            if fuel < 0: \n                return 0\n            \n            return int(i == finish) + sum(dp(k, fuel - abs(locations[i] - locations[k])) \n                       for k in range(N) \n                       if k != i) % (10**9 + 7)\n        \n        return dp(start, fuel)\n            \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        def helper(c, f):\n            if (c, f) not in d:\n                t = c == finish\n                if f > 0:\n                    for i in range(len(locations)):\n                        u = abs(locations[i] - locations[c])\n                        if i != c and u <= f:\n                            t += helper(i, f - u)\n                d[c, f] = t % 1_000_000_007\n            return d[c, f]\n        d = {}\n        return helper(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        cache = {}\n\n        def dp(i, fuel):\n            if (i, fuel) in cache:\n                return cache[(i, fuel)]\n\n            count = 1 if i == finish else 0\n\n            for j in range(len(locations)):\n                if i != j:\n                    dist = abs(locations[i] - locations[j])\n                    if dist <= fuel:\n                        count += dp(j, fuel - dist)\n\n            cache[(i, fuel)] = count\n            return count\n\n        return dp(start, fuel) % (10**9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = {}\n        \n        def recursive(curr, fuel):\n\n            if (curr, fuel) in dp:\n                return dp[curr, fuel]\n            \n            count = 1 if curr == finish else 0\n            \n            for c in range(len(locations)):\n                fuelRequired = abs(locations[c] - locations[curr])\n                \n                if c != curr and fuel >= fuelRequired:\n                    count += recursive(c, fuel - fuelRequired)\n\n            dp[curr, fuel] = count % (10**9 + 7)\n            \n            return dp[curr, fuel]\n        \n        return recursive(start, fuel)", "class Solution:\n    @lru_cache(1024*1024)\n    def helper(self, fuel_left, curr, target):\n        su = 0\n        # if fuel_left < 0:\n        #     return 0\n        if curr == target:\n            su += 1\n        for i in range(len(self.locations)):\n            if i == curr: continue\n            spent = abs(self.locations[curr] - self.locations[i])\n            if fuel_left >= spent:\n                su += self.helper(fuel_left - spent, i, target)\n        # print('fuel_left =', fuel_left)\n        # print('here =', self.locations[curr])\n        # print('ans =', su)\n        return su\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.locations = locations\n        # self.street = sorted(locations)\n        # self.count = 0\n        return self.helper(fuel, start, finish) % (1000000007)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = {}\n        \n        def recursive(curr, fuel):\n            key = (curr, fuel)\n            count = 0\n\n            if key in dp:\n                return dp[key]\n            \n            elif curr == finish:\n                count += 1\n            \n            for c in range(len(locations)):\n                fuelRequired = abs(locations[c] - locations[curr])\n                \n                if c != curr and fuel >= fuelRequired:\n                    count += recursive(c, fuel - fuelRequired)\n\n            dp[key] = count\n            \n            return dp[key]\n        \n        return recursive(start, fuel) % (10**9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        '''n = len(locations)\n        dp = [[0] * (fuel + 1) for _ in range(n)]\n        ds = locations[start]\n        de = locations[finish]\n        locations.sort()'''\n        mod = 10 ** 9 + 7\n        n = len(locations)\n        @lru_cache(None)\n        def dfs(cur, remain):\n            if abs(locations[finish] - locations[cur]) > remain:\n                return 0\n            res = 0\n            if cur == finish:\n                res = 1\n            for i in range(n):\n                if i == cur:\n                    continue\n                temp =  abs(locations[i] - locations[cur])\n                if temp <= remain:\n                    res = (res + dfs(i, remain - temp)) % mod\n            return res\n        return dfs(start, fuel)", "from collections import Counter, defaultdict, OrderedDict, deque\nfrom bisect import bisect_left, bisect_right\nfrom functools import reduce, lru_cache\nfrom typing import List\nimport itertools\nimport math\nimport heapq\nimport string\ntrue = True\nfalse = False\nMIN, MAX, MOD = -0x3f3f3f3f, 0x3f3f3f3f, 1000000007\n\n\n#\n# @lc app=leetcode id=1575 lang=python3\n#\n# [1575] Count All Possible Routes\n#\n# https://leetcode.com/problems/count-all-possible-routes/description/\n#\n# algorithms\n# Hard (59.30%)\n# Total Accepted:    1.7K\n# Total Submissions: 2.8K\n# Testcase Example:  '[2,3,6,8,4]\\\n1\\\n3\\\n5'\n#\n# You are given an array of distinct positive integers locations\u00a0where\n# locations[i] represents the position of city i. You are also given\u00a0integers\n# start,\u00a0finish\u00a0and\u00a0fuel\u00a0representing the starting city, ending city, and the\n# initial amount of fuel you have, respectively.\n#\n# At each step, if you are at city\u00a0i, you can pick any city\u00a0j\u00a0such that j != i\n# and\u00a00 <= j < locations.length\u00a0and move to city j.\u00a0Moving from city i to city\n# j reduces the amount of fuel you have by\u00a0|locations[i] - locations[j]|.\n# Please notice that |x|\u00a0denotes the absolute value of x.\n#\n# Notice that\u00a0fuel\u00a0cannot become negative at any point in time, and that you\n# are allowed to visit any city more than once (including start\u00a0and\u00a0finish).\n#\n# Return the count of all possible routes from\u00a0start\u00a0to\u00a0finish.\n#\n# Since the answer\u00a0may be too large,\u00a0return it modulo\u00a010^9 + 7.\n#\n#\n# Example 1:\n#\n#\n# Input: locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5\n# Output: 4\n# Explanation:\u00a0The following are all possible routes, each uses 5 units of\n# fuel:\n# 1 -> 3\n# 1 -> 2 -> 3\n# 1 -> 4 -> 3\n# 1 -> 4 -> 2 -> 3\n#\n#\n# Example 2:\n#\n#\n# Input: locations = [4,3,1], start = 1, finish = 0, fuel = 6\n# Output: 5\n# Explanation: The following are all possible routes:\n# 1 -> 0, used fuel = 1\n# 1 -> 2 -> 0, used fuel = 5\n# 1 -> 2 -> 1 -> 0, used fuel = 5\n# 1 -> 0 -> 1 -> 0, used fuel = 3\n# 1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5\n#\n#\n# Example 3:\n#\n#\n# Input: locations = [5,2,1], start = 0, finish = 2, fuel = 3\n# Output: 0\n# Explanation: It's impossible to get from 0 to 2 using only 3 units of fuel\n# since the shortest route needs 4 units of fuel.\n#\n# Example 4:\n#\n#\n# Input: locations = [2,1,5], start = 0, finish = 0, fuel = 3\n# Output: 2\n# Explanation:\u00a0There are two possible routes, 0 and 0 -> 1 -> 0.\n#\n# Example 5:\n#\n#\n# Input: locations = [1,2,3], start = 0, finish = 2, fuel = 40\n# Output: 615088286\n# Explanation: The total number of possible routes is 2615088300. Taking this\n# number modulo 10^9 + 7 gives us 615088286.\n#\n#\n#\n# Constraints:\n#\n#\n# 2 <= locations.length <= 100\n# 1 <= locations[i] <= 10^9\n# All integers in\u00a0locations\u00a0are\u00a0distinct.\n# 0 <= start, finish <\u00a0locations.length\n# 1 <= fuel <= 200\n#\n#\n#\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int,\n                    fuel: int) -> int:\n        @lru_cache(None)\n        def dp(i, f):\n            if f < 0: return 0\n            if f == 0: return 1 if i == finish else 0\n            ans = 1 if i == finish else 0\n            for j in range(0, len(locations)):\n                if j != i and f >= abs(locations[j] - locations[i]):\n                    ans += dp(j, f - abs(locations[i] - locations[j])) % MOD\n\n            return ans % MOD\n\n        return dp(start, fuel)\n\n\nsol = Solution()\n\nlocations, start, finish, fuel = [2, 3, 6, 8, 4], 1, 3, 5\n# locations, start, finish, fuel = [4,3,1], 1, 0, 6\n# locations, start, finish, fuel = [5,2,1], 0, 2, 3\n# locations, start, finish, fuel = [2,1,5], 0, 0, 3\nlocations, start, finish, fuel = [1, 2, 3], 0, 2, 40\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10**9 + 7\n        \n        def dfs(i, f, dp):\n            key = (i,f)\n            if key in dp:\n                return dp[key]\n            ans = 1 if i == finish else 0\n            li = locations[i]\n            for j, l in enumerate(locations):\n                if j == i:\n                    continue\n                cost = abs(l-li)\n                if cost > f:\n                    continue\n                ans = (ans + dfs(j, f-cost, dp)) % mod\n            dp[key] = ans\n            return ans\n        \n        return dfs(start, fuel, {})", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        memo = {}\n        def dfs(u, fuel):\n            if (u, fuel) in memo:\n                return memo[u, fuel]\n            ans = 1 if u == finish else 0\n            for v in range(len(locations)):\n                cost = abs(locations[u] - locations[v])\n                if cost > 0 and cost <= fuel:\n                    ans += dfs(v, fuel - cost)\n            ans %= 1000000007\n            memo[u, fuel] = ans\n            return ans\n        \n        return dfs(start, fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        memo = {}\n        def dfs(u, fuel):\n            if (u, fuel) in memo:\n                return memo[u, fuel]\n            \n            ans = 1 if u == finish else 0\n            for v in range(len(locations)):\n                cost = abs(locations[u] - locations[v])\n                if cost > 0 and cost <= fuel:\n                    ans += dfs(v, fuel - cost)\n            ans %= 1000000007\n            memo[u, fuel] = ans\n            return ans\n        \n        return dfs(start, fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[-1 for _ in range(fuel+1)] for _ in locations]\n        def search(start, fuel):\n            if fuel == 0:\n                if start == finish:\n                    return 1\n                return 0\n            if dp[start][fuel] != -1:\n                return dp[start][fuel]\n            dp[start][fuel] = 1 if start == finish else 0\n            for i in range(len(locations)):\n                left = fuel - abs(locations[i] - locations[start])\n                if i != start and left >= 0:\n                    dp[start][fuel] += search(i, left) \n            return dp[start][fuel] % 1000000007\n        return search(start, fuel) % 1000000007", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        def dist(i, j):\n            return abs(locations[i] - locations[j])\n        @functools.lru_cache(None)\n        def dp(i, fuel):\n            if fuel < dist(i, finish):\n                return 0\n            return sum([dp(j, fuel - dist(i, j)) for j in range(len(locations)) if i != j]) + (i == finish)\n        return dp(start, fuel) % (10 ** 9 + 7)", "class Solution:\n    def helper(self, locations, index, finish, fuelLeft, cache):\n        if (index, fuelLeft) in cache:\n            return cache[(index, fuelLeft)]\n        \n        result = 0\n        if index == finish and fuelLeft >= 0:\n            result += 1\n        \n        for i in range(len(locations)):\n            if i == index:\n                continue\n            \n            fuelUsed = abs(locations[index] - locations[i])\n            if fuelLeft >= fuelUsed:\n                result += self.helper(locations, i, finish, fuelLeft - fuelUsed, cache)\n        \n        cache[(index, fuelLeft)] = result\n        return result\n    \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        result = self.helper(locations, start, finish, fuel, {})\n        return result % (10**9+7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        memo = {}\n        def dfs(u, fuel):\n            if (u, fuel) in memo:\n                return memo[u, fuel]\n            ans = 1 if u == finish else 0\n            for v in range(len(locations)):\n                cost = abs(locations[u] - locations[v])\n                if cost > 0 and cost <= fuel:\n                    ans += dfs(v, fuel - cost)\n            ans %= 1000000007\n            memo[u, fuel] = ans\n            return ans\n        \n        return dfs(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = {}\n        \n        def recursive(curr, fuel):\n            count = 0\n\n            if (curr, fuel) in dp:\n                return dp[curr, fuel]\n            \n            elif curr == finish:\n                count += 1\n            \n            for c in range(len(locations)):\n                fuelRequired = abs(locations[c] - locations[curr])\n                \n                if c != curr and fuel >= fuelRequired:\n                    count += recursive(c, fuel - fuelRequired)\n\n            dp[curr, fuel] = count % 1000000007\n            \n            return dp[curr, fuel]\n        \n        return recursive(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        md=10**9+7\n        # dp[i][j]...vertex i,fuel j\n        n=len(locations)\n        dp=[[0]*(fuel+1) for _ in range(n)]\n        dp[start][0]=1\n        for j in range(fuel):\n            for i in range(n):\n                pre=dp[i][j]%md\n                if pre==0:continue\n                for ni in range(n):\n                    if i==ni:continue\n                    nj=j+abs(locations[i]-locations[ni])\n                    if nj>fuel:continue\n                    dp[ni][nj]+=pre\n        ans=sum(dp[finish])%md\n        return ans\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        if abs(locations[start]-locations[finish])>fuel: return 0\n        lc = len(locations)\n        mod = 10**9+7\n        @lru_cache(None)\n        def rec_dp(s,e,rem):\n            \n            if rem<0 or abs(locations[s]-locations[e])>rem:\n                return 0\n            if s==e and rem==0: return 1\n            re = 0 if s!=e else 1\n            for i in range(lc):\n                if i!=s:\n                    used = abs(locations[s]-locations[i])\n                    re+=rec_dp(i,e,rem-used)\n            return re%mod\n        \n        return rec_dp(start,finish,fuel)", "from functools import lru_cache\n\nMODULO = 10**9 + 7\n\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n\n        @lru_cache(maxsize=None)\n        def dp(start_pos, fuel_remaining):\n            if fuel_remaining < 0:\n                return 0\n\n            ways = 1 if start_pos == finish else 0\n\n            if fuel_remaining == 0:\n                return ways\n\n            for i in range(len(locations)):\n                if i == start_pos:\n                    continue\n\n                fuel_wasted = abs(locations[i] - locations[start_pos])\n                ways = (ways + dp(i, fuel_remaining - fuel_wasted)) % MODULO\n\n            return ways\n\n        return dp(start, fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = {}\n        \n        def recursive(curr, fuel):\n            count = 0\n\n            if (curr, fuel) in dp:\n                return dp[curr, fuel]\n            \n            elif curr == finish:\n                count += 1\n            \n            for c in range(len(locations)):\n                fuelRequired = abs(locations[c] - locations[curr])\n                \n                if c != curr and fuel >= fuelRequired:\n                    count += recursive(c, fuel - fuelRequired)\n\n            dp[curr, fuel] = count % (10**9 + 7)\n            \n            return dp[curr, fuel]\n        \n        return recursive(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dp(i, j):\n            if j < 0:\n                return 0\n            if i == finish:\n                return 1 + sum(dp(k, j - abs(locations[i] - locations[k])) for k in range(len(locations)) if k != i)\n            else:\n                return sum(dp(k, j - abs(locations[i] - locations[k])) for k in range(len(locations)) if k != i)\n        return dp(start, fuel) % ((10 ** 9) + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # dynamic programming\n        MOD = pow(10,9)+7\n        N = len(locations)\n        @lru_cache(None)\n        def dfs(cur, fuel):\n            # cur to finissh with fuel\n            if fuel <0:\n                return 0\n            ans = 0\n            if cur == finish:\n                ans += 1\n            for i, loc in enumerate(locations):\n                if i==cur:\n                    continue\n                if fuel>= abs(locations[i] - locations[cur]):\n                    ans += dfs(i, fuel - abs(locations[i] - locations[cur]))%MOD\n                    ans %= MOD\n            ans%=MOD\n            return ans\n        return dfs(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        dic = []\n        \n        n = len(locations)\n        \n        for i in range(n):\n            \n            dic.append([None]*(fuel+1))\n            \n        \n        def dp(l,s,f,fuel,dic,n):\n\n            if(fuel == 0):\n                if(s == f):\n                    return 1\n                return 0\n            \n            if(dic[s][fuel] != None):\n                return dic[s][fuel]\n            \n            \n            number = 0\n            \n            if(s == f):\n                number = 1\n            \n            for i in range(n):\n                \n                if(i != s):\n                    if(abs(l[i]-l[s]) <= fuel):\n                        number += dp(l,i,f,fuel-abs(l[i]-l[s]), dic, n)\n            \n            dic[s][fuel] = number\n            \n            return number\n        \n        return dp(locations,start,finish,fuel,dic,n)%1000000007\n", "from functools import lru_cache\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(None)\n        def h(start, finish, fuel):\n            if fuel < 0:\n                return 0\n            res = start == finish\n            for i in range(len(locations)):\n                if i != start:\n                    res += h(i, finish, fuel - abs(locations[i] - locations[start]))\n            return res        \n        \n        return h(start, finish, fuel) % (10**9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        \n        @lru_cache(None)\n        def dp(fuel_left, curr_loc):\n            if fuel_left < 0:\n                return 0\n            \n            ways = 0\n            if fuel_left >= 0 and curr_loc == finish:\n                ways = 1\n            \n            for i in range(len(locations)):\n                if i != curr_loc:\n                    ways += dp(fuel_left - abs(locations[curr_loc] - locations[i]), i) % MOD\n            \n            return ways % MOD\n        \n        return dp(fuel, start) % MOD", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        mod = 10**9 + 7\n        dp = [[-1] * (fuel+1) for _ in range(n)]\n        \n        def dfs(s, remain):\n            if remain < 0:\n                return 0\n            if dp[s][remain] != -1:\n                return dp[s][remain]\n            res = 0\n            if s == finish:\n                res += 1\n            for i in range(n):\n                if i != s:\n                    res += dfs(i, remain - abs(locations[i] - locations[s]))\n            dp[s][remain] = res\n            return res\n                    \n        \n        return dfs(start, fuel) % mod", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        DP = [[-1] * len(locations) for _ in range(fuel + 1)]\n    \n        ans = self.dfs(locations,start,finish,fuel,DP,start) % (10**9 + 7)\n        \n        return ans\n    \n    def dfs(self, locations, start, finish, fuel, DP, cur):\n        paths = 0\n        if cur == finish and fuel >= 0:\n            paths += 1\n        \n        for i in range(len(locations)):\n            if i == cur:\n                continue\n                \n                \n            if fuel - abs(locations[i] - locations[cur]) < 0:\n                continue\n            \n            if DP[fuel - abs(locations[i] - locations[cur])][i] == -1:\n                DP[fuel - abs(locations[i] - locations[cur])][i] = self.dfs(locations, start, finish,\n                                                                            fuel - abs(locations[i] - locations[cur]), \n                                                                            DP, i)\n            paths += DP[fuel - abs(locations[i] - locations[cur])][i]\n            \n        return paths\n                \n            \n", "class Solution:\n  def countRoutes(self, x: List[int], start: int, finish: int, fuel: int) -> int:    \n    @lru_cache(None)\n    def dp(i, f): # ways to reach |finsh| from |i| with |f| fuel.\n      if f < 0: return 0\n      return (sum(dp(j, f - abs(x[i] - x[j])) \n                 for j in range(len(x)) if i != j) + (i == finish)) % (10**9 + 7)\n    return dp(start, fuel)\n", "from functools import lru_cache\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dp(cur, fuel):\n            res = int(cur == finish)\n            for i in range(cur - 1, -1, -1):\n                if locations[cur] - locations[i] > fuel:\n                    break\n                res += dp(i, fuel - (locations[cur] - locations[i]))\n            for i in range(cur + 1, len(locations)):\n                if locations[i] - locations[cur] > fuel:\n                    break\n                res += dp(i, fuel - (locations[i] - locations[cur]))\n            return res % MOD\n        MOD = 10 ** 9 + 7\n        start_loc, finish_loc = locations[start], locations[finish]\n        locations.sort()\n        start = locations.index(start_loc)\n        finish = locations.index(finish_loc)\n        return dp(start, fuel)", "class Solution:\n    def countRoutes(self, A: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        mod = 10 ** 9 + 7\n        \n        d = {}\n        t = {}\n        for i, ele in enumerate(A):\n            d[i] = ele\n            t[ele] = i\n        \n        nums = sorted(A)\n        \n        @lru_cache(None)\n        def dp(i, j, f):\n            if not f:\n                return i == j\n            loc = d[i]\n            l, r = bisect.bisect_left(nums, loc - f), bisect.bisect_right(nums, loc + f)\n            res = (1 if i == j else 0)\n            for ele in nums[l:r]:\n                if ele != loc:\n                    res += dp(t[ele], j, f - abs(ele - loc)) % mod\n            return res\n        \n        return dp(start, finish, fuel) % mod", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        m = 10 ** 9 + 7\n        n = len(locations)\n        dp = [[-1 for _ in range(fuel+1)] for _ in range(n)]\n        return self.helper(locations, start, finish, dp, fuel)\n        \n    def helper(self, locations, curr, end, dp, fuel):\n        if fuel < 0:\n            return 0\n        if dp[curr][fuel] != -1:\n            return dp[curr][fuel]\n        if curr == end:\n            res = 1\n        else:\n            res = 0\n\n        for nxt in range(len(locations)):\n            if nxt != curr:\n                res += self.helper(locations, nxt, end, dp, fuel-abs(locations[curr]-locations[nxt]))\n        dp[curr][fuel] = res % (10 ** 9 + 7)\n        return dp[curr][fuel]", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[-1]*(fuel+1) for _ in range(len(locations))]\n        \n        def route(st, ed, fuel):\n            if fuel < 0: return 0\n            if dp[st][fuel] > -1: return dp[st][fuel]\n            res = 0 if st!= ed else 1\n            for i in range(len(locations)):\n                if i != st:\n                    res += route(i, ed, fuel-abs(locations[st]-locations[i]))\n            dp[st][fuel] = res % 1000000007\n            return dp[st][fuel]\n        # print(dp)\n        return route(start, finish, fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10**9+7\n        memo = {}\n        def solve(pos, fuel):\n            if fuel == 0:\n                return pos == finish \n            elif (pos, fuel) in memo:\n                return memo[(pos, fuel)]\n            \n\n            ret = pos == finish\n            for i in range(len(locations)):\n                if i != pos:\n                    cost = abs(locations[i]-locations[pos])\n                    if cost <= fuel:\n                        ret += solve(i, fuel-cost) % mod\n                        \n            memo[(pos, fuel)] = ret % mod\n            return ret % mod\n        \n        return solve(start, fuel)\n", "class Solution:\n    def countRoutes(self, A: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10**9 + 7\n        @functools.lru_cache(None)\n        def f(i, fu):\n            res = int(i == finish)\n            for j, p in enumerate(A):\n                d = abs(p - A[i])\n                if j != i and d <= fu:\n                    res = (res + f(j, fu - d)) % MOD\n            return res\n        return f(start, fuel) % MOD", "from typing import List\nimport functools\n\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n\n        @functools.lru_cache(None)\n        def foo(loc, f):\n            print(loc,f)\n            res = 1 if loc==finish else 0\n            for i in range(len(locations)):\n                if i != loc:\n                    temp = f - abs(locations[loc] - locations[i])\n                    if temp >= 0:\n                        res = (res + foo(i, temp)) % MOD\n            return res% MOD\n\n        return foo(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        '''\n        [2,3,6,8,4]\n        start = 1\n        fin = 3\n        fuel = 5\n        \n        '''\n        ref = defaultdict(list)\n        # for i in range(len(locations)):\n        #     for j in range(len(locations)):\n        #         if i == j: continue\n        #         ref[locations[i]].append((locations[j], abs(locations[i]-locations[j])))\n        #     ref[locations[i]].sort()\n        \n        from functools import lru_cache\n        finish = locations[finish]\n        MOD = 10**9 + 7\n        mycache = {}\n        def solve(pos, rfuel):           \n            # print(pos, rfuel)\n            if (pos,rfuel) in mycache: return mycache[(pos, rfuel)]\n            sol = 0\n            if pos == finish:\n                sol += 1\n            for it in locations:\n                if it == pos: continue\n                tup = (it, abs(pos - it))\n                if tup[1] <= rfuel:\n                    sol += solve(tup[0], rfuel - tup[1])\n            mycache[(pos, rfuel)] = sol % MOD\n            return sol\n        \n        solve(locations[start], fuel)\n        # print(locations)\n        # print('mycache', mycache)\n        return mycache[(locations[start], fuel)] % MOD", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        DP = [[-1 for j in range(fuel + 1)] for j in range(n)]\n        return self.helper(locations, start, finish, DP, fuel) % (10 ** 9 + 7)\n        \n    def helper(self, locations, curr, end, DP, fuel):\n        if fuel < 0:\n            return 0\n\n        if DP[curr][fuel] != -1:\n            return DP[curr][fuel]\n        ans = 1 if curr == end else 0\n        for next_ in range(len(locations)):\n            if next_ != curr:\n                ans += self.helper(locations, next_, end, DP, fuel - abs(locations[next_] - locations[curr]))\n        DP[curr][fuel] = ans\n        return ans", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10**9 + 7\n        N = len(locations)\n        \n        @lru_cache(None)\n        def dp(curr, fuelLeft):\n            ans = int(curr == finish)\n            \n            for nxt in range(N):\n                if nxt != curr:\n                    f = abs(locations[nxt]-locations[curr])\n                    \n                    if f <= fuelLeft:\n                        ans = (ans + dp(nxt, fuelLeft - f)) % MOD\n            \n            return ans\n        \n        return dp(start, fuel)", "def count_all_possible_routes(locations, start, finish, fuel):\n    loc_count = len(locations)\n    dp_store = [[-1] * (fuel + 1) for loc in range(loc_count)]\n\n    # print('*' * 80)\n    # print('iron man dp_store', dp_store)\n\n    def count_all_possible_routes_recur(curr_loc, rem_fuel):\n        if rem_fuel < 0:\n            return 0\n        if dp_store[curr_loc][rem_fuel] > -1:\n            return dp_store[curr_loc][rem_fuel]\n        ans = 0\n        if curr_loc == finish:\n            ans += 1\n        for city, pos in enumerate(locations):\n            if city == curr_loc:\n                continue\n            ans += count_all_possible_routes_recur(\n                city, rem_fuel - (abs(pos - locations[curr_loc])))\n        dp_store[curr_loc][rem_fuel] = ans\n        return ans\n\n    return count_all_possible_routes_recur(start, fuel) % ((10 ** 9 ) + 7)\n\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        return count_all_possible_routes(locations, start, finish, fuel)", "from functools import lru_cache\nfrom collections import defaultdict\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        cost = defaultdict(list)\n        for i, c1 in enumerate(locations):\n            for c2 in locations:\n                cost[i].append(abs(c1 - c2))\n    \n        @lru_cache(None)\n        def dp(position, f):\n            ret = 0 if position != finish else 1\n            for dst, c in enumerate(cost[position]):\n                if f >= c and dst != position:\n                    ret = (ret + dp(dst, f - c)) % 1000000007\n            return ret\n        return dp(start, fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        fuelReduce = lambda x, y: abs(x - y)\n\n        @lru_cache(None)\n        def dfs(city, fuel):\n            if fuel < 0:\n                return 0\n            ans = 0\n            if city == finish:\n                ans = ans + 1\n            for next in range(len(locations)):\n                if city != next:\n                    ans = ans + dfs(next, fuel - fuelReduce(locations[city], locations[next]))\n            return ans\n        return dfs(start, fuel) % (10 ** 9 + 7)\n\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        def getLocations(location, fuel):\n            if (location, fuel) in mem:\n                return mem[(location, fuel)]\n            if fuel < 0:\n                return 0\n            ans = 0\n            if location == locations[finish]:\n                ans = 1\n            \n            for newLoc in locations:\n                if newLoc != location:\n                    ans += getLocations(newLoc, fuel - abs(location - newLoc))\n            mem[(location, fuel)] = ans\n            \n            return ans\n        mem = {}\n        return getLocations(locations[start], fuel) % (10**9 +7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        dp = [[-1] * (fuel + 1) for _ in range(n)]\n        return self.dfs(start, finish, fuel, dp, locations)\n    \n    def dfs(self, start, finish, fuel, dp, locations):\n        if fuel < 0:\n            return 0\n        if dp[start][fuel] > -1:\n            return dp[start][fuel]\n        \n        if start == finish:\n            res = 1\n        else:\n            res = 0\n        \n        n = len(locations)\n        for i in range(n):\n            if i == start:\n                continue\n            else:\n                res += self.dfs(i, finish, fuel - abs(locations[i] - locations[start]), dp, locations)\n            \n        dp[start][fuel] = res % (10 ** 9 + 7)\n        \n        return dp[start][fuel]", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        def cost(i, j):\n            return abs(locations[i]-locations[j])\n        \n        @lru_cache(None)\n        def dfs(i, f):\n            if f < 0:\n                return 0\n            ans = (i==finish)\n            for j in range(len(locations)):\n                if j != i:\n                    ans += dfs(j, f-cost(i, j))\n            return ans\n        \n        return dfs(start, fuel) % (10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # DFS\n        self.N = len(locations)\n        self.finish = finish\n        self.M = dict()\n        def dfs(i, f):\n            if (i, f) not in self.M:\n                res = 0\n                if i == self.finish:\n                    res += 1\n                for j in range(self.N):\n                    if j != i and f >= abs(locations[i] - locations[j]) + abs(locations[finish] - locations[j]):\n                        res += dfs(j, f - abs(locations[i] - locations[j]))\n                self.M[(i, f)] = res\n            return self.M[(i, f)]\n        \n        return dfs(start, fuel) % (10**9 + 7) ", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mem = {}\n        MOD = 10**9 + 7\n        \n        def dp(i,gas):\n            if gas < 0: return 0\n            if (i,gas) in mem: return mem[(i, gas)]\n            \n            res = 0\n            if i == finish:\n                res += 1\n            \n            for j in range(len(locations)):\n                dist = abs(locations[j] - locations[i])\n                if i == j or dist > gas: continue\n                res += dp(j, gas-dist)\n            \n            mem[(i,gas)] = res % MOD\n            return res\n        \n        return dp(start, fuel) % MOD\n\n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        cost = lambda i, j: abs(locations[i] - locations[j])\n        \n        @lru_cache(maxsize=None)\n        def dfs(i, f):\n            if f < 0:\n                return 0\n            total = 0\n            if i == finish:\n                total += 1\n            for j in range(len(locations)):\n                if i == j:\n                    continue\n                total += dfs(j, f - cost(i,j))\n            return total\n        \n        return dfs(start, fuel) % (10**9 + 7)\n                \n            \n                \n", "class Solution:\n\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        dp = [[-1]*(fuel+1) for _ in range(n)]\n        return self.dfs(start, finish, fuel, dp, locations)\n\n    def dfs(self, start, finish, fuel, dp, locations):\n        if fuel<0:\n            return 0\n        if dp[start][fuel]>-1:\n            return dp[start][fuel]\n        if start==finish:\n            res = 1\n        else:\n            res = 0\n\n        n = len(locations)\n        for i in range(n):\n            if i==start:\n                continue\n            else:\n                res = res + self.dfs(i, finish, fuel-abs(locations[i]- locations[start]), dp, locations)\n        dp[start][fuel] = res % (1000_000_000+7)\n  \n        return dp[start][fuel]", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[-1] * 201 for _ in range(101)]\n        MOD = 1000000007\n        def helper(pos, left):\n            if left < 0:\n                return 0\n            if dp[pos][left] != -1:\n                return dp[pos][left]\n            ans = 1 if pos == finish else 0\n            for i, loc in enumerate(locations):\n                if i != pos and left - abs(loc - locations[pos]) >= 0:\n                    ans += helper(i, left - abs(loc - locations[pos]))\n            ans %= MOD\n            dp[pos][left] = ans\n            return ans\n        return helper(start, fuel)\n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        ans =0 \n        MOD = 10**9+7\n        \n        def fun(ind,arr,rem,target):\n            if (ind,rem) in dp:\n                return dp[ind,rem]\n            cnt = 0\n            if ind ==target:\n                cnt+=1\n            \n            for i,val in enumerate(arr):\n                if i==ind:\n                    continue\n                if abs(arr[ind]-val)<=rem:\n                    cnt+=fun(i,arr,rem-abs(arr[ind]-val),target)\n            dp[ind,rem] =cnt%(10**9+7)\n            return dp[ind,rem]\n        dp = {}\n        return fun(start,locations,fuel,finish)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        start, finish = locations[start], locations[finish]\n        locations.sort()\n        start, finish = locations.index(start), locations.index(finish)\n        n = len(locations)\n        @lru_cache(None)\n        def dp(i, f):\n            res = 0\n            if i == finish:\n                res = 1\n            if f == 0:\n                return res\n            for j in range(1, i + 1):\n                ff = locations[i] - locations[i - j]\n                if ff <= f:\n                    res = (res + dp(i - j, f - ff)) % MOD\n                else:\n                    break\n            for j in range(1, n - i):\n                ff = locations[i + j] - locations[i]\n                if ff <= f:\n                    res = (res + dp(i + j, f - ff)) % MOD\n                else:\n                    break\n            return res   \n        \n        return dp(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        N, R = len(locations), 10**9 + 7\n        dp = [[-1] * (fuel + 1) for _ in range(N)]\n\n        def _dfs(p, f):\n            cost = abs(locations[finish] - locations[p])\n            if cost > f: return 0\n            # if cost == f: return 1\n            if dp[p][f] < 0:\n                dp[p][f] = sum(\n                    _dfs(q, f - abs(locations[p] - locations[q]))\n                    for q in range(N) if q != p)\n                dp[p][f] += 1 if p == finish else 0\n            return dp[p][f] % R\n\n        return _dfs(start, fuel)", "class Solution:\n    \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        '''\n        f(s, cost) # \u5230\u8fbecity_s\u65f6\uff0c \u5269\u4f59\u7684cost\n        '''\n        def cost(i, j): return abs(locations[i]-locations[j])\n        n, MOD = len(locations), 10**9+7\n        \n        @functools.lru_cache(None)\n        def solve(s, fuel):\n            if fuel < 0: return 0\n            ans = 1 if s == finish else 0\n            for t in range(n):\n                if s == t: continue\n                ans += solve(t, fuel-cost(s, t))\n            return ans % MOD\n        \n        return solve(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        def cost(i, j):\n            return abs(locations[i]-locations[j])\n        \n        @lru_cache(None)\n        def dfs(i, fuel):\n            if fuel < 0:\n                return 0\n            ans = 0\n            if finish == i:\n                ans += 1\n                \n            for j in range(len(locations)):\n                if i == j:\n                    continue\n                ans += (dfs(j, fuel-cost(i, j)))\n                \n            return ans\n        \n        return dfs(start, fuel) % (10**9+7)", "from collections import deque\nclass Solution:\n    def rec(self, curr, finish, fuel_left, dp, locations, p):\n        cnt = 0\n        if curr == finish:\n            cnt = 1\n        \n        n = len(locations)\n        for i in range(n):\n            if i!=curr and fuel_left - abs(locations[i] - locations[curr]) >= 0:\n                if dp[fuel_left - abs(locations[i] - locations[curr])][i] != -1:\n                    cnt = (cnt + dp[fuel_left - abs(locations[i] - locations[curr])][i])%p\n                else:\n                    cnt = (cnt + self.rec(i, finish, fuel_left - abs(locations[i] - locations[curr]), dp, locations, p))%p\n        \n        dp[fuel_left][curr] = cnt % p\n        return cnt % p\n        \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        p = 1000000007\n        dp = [[-1 for i in range(n)] for j in range(fuel+1)]\n        \n        return self.rec(start, finish, fuel, dp, locations, p)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        cost = lambda i, j: abs(locations[i] - locations[j])\n        \n        @lru_cache(maxsize=None)\n        def dfs(i, f):\n            if f < 0:\n                return 0\n            total = 0\n            if i == finish:\n                total += 1\n            for j in range(len(locations)):\n                if i == j:\n                    continue\n                total += dfs(j, f - cost(i,j))\n            return total\n        \n        return dfs(start, fuel) % (10**9 + 7)\n                \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        \n        cost = lambda i, j: abs( locations[i] - locations[j] )\n        \n        # --------------------------------------\n        \n        @lru_cache(None)\n        def dfs(cur, remain_fuel):\n            \n            if remain_fuel < 0:\n                # base case aka stop condition\n                return 0\n            \n            # general case:\n            return sum( dfs(next_city, remain_fuel - cost(cur, next_city) )for next_city in range(len(locations) ) if cur != next_city ) + ( cur == finish )\n\n        # --------------------------------------\n        constant = ( 10 ** 9 + 7 )\n        return dfs(cur=start, remain_fuel=fuel) % constant\n", "class Solution:\n    def countRoutes(self, L: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        cost = lambda x, y: abs(L[x] - L[y])\n        ways = {}\n        \n        def numWays(s, f):\n            if (s, f) not in ways:\n                \n                if f < cost(s, finish):\n                    return 0\n\n                total = 0\n                for u in range(len(L)):\n                    if u != s:\n                        total += numWays(u, f - cost(s, u))\n\n                ways[(s, f)] = total + (s == finish)\n            return ways[(s, f)]\n            \n        return numWays(start, fuel) % (10 ** 9 + 7)\n            \n        \n", "from collections import Counter, defaultdict, OrderedDict, deque\nfrom bisect import bisect_left, bisect_right\nfrom functools import reduce, lru_cache\nfrom typing import List\nimport itertools\nimport math\nimport heapq\nimport string\ntrue = True\nfalse = False\nMIN, MAX, MOD = -0x3f3f3f3f, 0x3f3f3f3f, 1000000007\n\n\n#\n# @lc app=leetcode id=1575 lang=python3\n#\n# [1575] Count All Possible Routes\n#\n# https://leetcode.com/problems/count-all-possible-routes/description/\n#\n# algorithms\n# Hard (59.30%)\n# Total Accepted:    1.7K\n# Total Submissions: 2.8K\n# Testcase Example:  '[2,3,6,8,4]\\\n1\\\n3\\\n5'\n#\n# You are given an array of distinct positive integers locations\u00a0where\n# locations[i] represents the position of city i. You are also given\u00a0integers\n# start,\u00a0finish\u00a0and\u00a0fuel\u00a0representing the starting city, ending city, and the\n# initial amount of fuel you have, respectively.\n#\n# At each step, if you are at city\u00a0i, you can pick any city\u00a0j\u00a0such that j != i\n# and\u00a00 <= j < locations.length\u00a0and move to city j.\u00a0Moving from city i to city\n# j reduces the amount of fuel you have by\u00a0|locations[i] - locations[j]|.\n# Please notice that |x|\u00a0denotes the absolute value of x.\n#\n# Notice that\u00a0fuel\u00a0cannot become negative at any point in time, and that you\n# are allowed to visit any city more than once (including start\u00a0and\u00a0finish).\n#\n# Return the count of all possible routes from\u00a0start\u00a0to\u00a0finish.\n#\n# Since the answer\u00a0may be too large,\u00a0return it modulo\u00a010^9 + 7.\n#\n#\n# Example 1:\n#\n#\n# Input: locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5\n# Output: 4\n# Explanation:\u00a0The following are all possible routes, each uses 5 units of\n# fuel:\n# 1 -> 3\n# 1 -> 2 -> 3\n# 1 -> 4 -> 3\n# 1 -> 4 -> 2 -> 3\n#\n#\n# Example 2:\n#\n#\n# Input: locations = [4,3,1], start = 1, finish = 0, fuel = 6\n# Output: 5\n# Explanation: The following are all possible routes:\n# 1 -> 0, used fuel = 1\n# 1 -> 2 -> 0, used fuel = 5\n# 1 -> 2 -> 1 -> 0, used fuel = 5\n# 1 -> 0 -> 1 -> 0, used fuel = 3\n# 1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5\n#\n#\n# Example 3:\n#\n#\n# Input: locations = [5,2,1], start = 0, finish = 2, fuel = 3\n# Output: 0\n# Explanation: It's impossible to get from 0 to 2 using only 3 units of fuel\n# since the shortest route needs 4 units of fuel.\n#\n# Example 4:\n#\n#\n# Input: locations = [2,1,5], start = 0, finish = 0, fuel = 3\n# Output: 2\n# Explanation:\u00a0There are two possible routes, 0 and 0 -> 1 -> 0.\n#\n# Example 5:\n#\n#\n# Input: locations = [1,2,3], start = 0, finish = 2, fuel = 40\n# Output: 615088286\n# Explanation: The total number of possible routes is 2615088300. Taking this\n# number modulo 10^9 + 7 gives us 615088286.\n#\n#\n#\n# Constraints:\n#\n#\n# 2 <= locations.length <= 100\n# 1 <= locations[i] <= 10^9\n# All integers in\u00a0locations\u00a0are\u00a0distinct.\n# 0 <= start, finish <\u00a0locations.length\n# 1 <= fuel <= 200\n#\n#\n#\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int,\n                    fuel: int) -> int:\n        @lru_cache(None)\n        def dp(i, f):\n            if f < 0: return 0\n            if f == 0: return i == finish\n            ans = 1 if i == finish else 0\n            for j in range(0, len(locations)):\n                if j != i and f >= abs(locations[j] - locations[i]):\n                    ans += dp(j, f - abs(locations[i] - locations[j])) % MOD\n\n            return ans % MOD\n\n        return dp(start, fuel)\n\n\nsol = Solution()\n\nlocations, start, finish, fuel = [2, 3, 6, 8, 4], 1, 3, 5\n# locations, start, finish, fuel = [4,3,1], 1, 0, 6\n# locations, start, finish, fuel = [5,2,1], 0, 2, 3\n# locations, start, finish, fuel = [2,1,5], 0, 0, 3\nlocations, start, finish, fuel = [1, 2, 3], 0, 2, 40\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        def helper(curr,fuelLeft,memo,locations,finish,mod):\n            if (curr, fuelLeft) in memo:\n                return memo[curr,fuelLeft]\n            ret = 0\n            if curr == finish:\n                ret += 1\n            \n            for i, loc in enumerate(locations):\n                if curr != i:\n                    candidFuel = fuelLeft - abs(locations[curr]-loc)\n                    if candidFuel > 0:\n                        ret = (ret+helper(i, candidFuel,memo,locations,finish,mod))%mod\n                    elif candidFuel == 0 and i==finish:\n                        ret += 1\n            \n            memo[curr,fuelLeft] = ret%mod\n            return ret\n        \n        return helper(start,fuel,{},locations,finish,10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # Dynamic Programming\n        mod = 10**9 + 7\n        \n        @lru_cache(None)\n        def count_paths(index, fuel):\n            total = 0\n            \n            if fuel < 0:\n                return 0\n            \n            if index==finish:\n                total += 1\n            current = locations[index]\n            for next_index, x in enumerate(locations):\n                if next_index != index:\n                    total += count_paths(next_index, max(-1,fuel-abs(current-x)))\n            \n            return total\n        answer = count_paths(start,fuel)\n        return answer%mod\n            \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        x = locations[start]\n        y = locations[finish]\n        locations.sort()\n        u = bisect.bisect_left(locations, x)\n        v = bisect.bisect_left(locations, y)\n        \n        MOD = int(1e9) + 7\n        \n        @lru_cache(None)\n        def f(x, left):\n            lb = bisect.bisect_left(locations, locations[x] - left)\n            rb = bisect.bisect_right(locations, locations[x] + left)\n            \n            ret = int(x == v)\n            for i in range(lb, rb):\n                if i != x:\n                    ret += f(i, left - abs(locations[i] - locations[x]))\n                    ret %= MOD\n            return ret\n        \n        return f(u, fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        mydict = {}\n        def func(city, myfuel):\n            #print('travel to', city, 'fuel', myfuel)\n            if myfuel < 0:\n                return 0\n            if myfuel == 0:\n                if city == locations[finish]:\n                    return 1\n                else:\n                    return 0\n            tmp = 0\n            for i in locations:\n                if i != city:\n                    if (i, myfuel - abs(i-city)) in mydict:\n                        tmp += mydict[(i, myfuel - abs(i-city))]\n                    else:\n                        tmp += func(i, myfuel - abs(i-city))\n            if city == locations[finish]:\n                tmp = tmp + 1\n            mydict[(city, myfuel)] = tmp\n            return tmp\n        \n        count = func(locations[start], fuel)\n        #print(mydict)\n        return (count) % (10**9 + 7)\n        \n                \n", "class Solution:\n    def search(self, locations, start, finish, fuel):\n        if (start, fuel) in self.memo:\n            return self.memo[(start, fuel)]\n        count=0\n        if start==finish:\n            count+=1\n        for i,loc in enumerate(locations):\n            dist=abs(locations[start]-loc)\n            if i==start or dist>fuel:\n                continue\n            count+=self.search(locations, i, finish, fuel-dist)\n        self.memo[(start, fuel)]=count%(10**9+7)\n        return self.memo[(start, fuel)]\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.memo={}\n        return self.search(locations, start, finish, fuel)\n", "MOD = 10**9 + 7\nclass Solution:\n    def countRoutes(self, A: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(A)\n        \n        @lru_cache(None)\n        def dfs(i, k):\n            res = int(i == finish)\n            for j in range(n):\n                if i == j:\n                    continue\n                if abs(A[i] - A[j]) > k:\n                    continue\n                res += dfs(j, k - abs(A[i] - A[j]))\n                res %= MOD\n            return res\n        \n        return dfs(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        cost = lambda i,j: abs(locations[i]-locations[j])\n        @lru_cache(None)\n        def dfs(i, f):\n            if f<0: return 0 \n            return sum([dfs(j,f-cost(i,j)) for j in range(len(locations)) if j != i]) + (i==finish)\n        return dfs(start, fuel) % (10**9+7)\n", "MOD = int(1e9 + 7)\n\nclass Solution:\n    def num_routes(self, start, finish, fuel):\n        min_fuel = abs(self.loc[start] -self.loc[finish])\n        if fuel < min_fuel:\n            return 0\n        if fuel == 0:\n            return 1 if start == finish else 0\n        \n        try:\n            return self.cache[(start, finish, fuel)]\n        except KeyError:\n            ret = 1 if start == finish else 0\n            for first_stop in range(len(self.loc)):\n                if first_stop == start:\n                    continue\n                first_fuel = abs(self.loc[start] - self.loc[first_stop])\n                if fuel < first_fuel:\n                    continue\n                ret = (ret + self.num_routes(first_stop, finish, fuel - first_fuel)) % MOD\n            self.cache[(start, finish, fuel)] = ret\n            return ret\n        \n    def countRoutes(self, locations, start, finish, fuel):\n        self.loc = locations\n        self.cache = {}\n        return self.num_routes(start, finish, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[-1 for i in range(len(locations))] for j in range(fuel+1)]\n        \n        out = self.helper(locations,start,finish,fuel,dp,start)\n        \n        return out%1000000007\n    \n    def helper(self,locations,start,finish,fuel,dp,index):\n        if(fuel<0):\n            return 0\n        \n        if(dp[fuel][index]!=-1):\n            return dp[fuel][index]\n        \n        if(index==finish):\n            ans = 1\n            for i in range(len(locations)):\n                if(i!=index):\n                    ans+=self.helper(locations,start,finish,fuel-abs(locations[i]-locations[index]),dp,i)\n\n        else:\n            ans = 0\n            for i in range(len(locations)):\n                if(i!=index):\n                    ans+=self.helper(locations,start,finish,fuel-abs(locations[i]-locations[index]),dp,i)\n            \n                \n        dp[fuel][index] = ans  \n        return ans\n        \n", "class Solution:\n     def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n\n            \n        def dfs(i, fuel):\n            if fuel < 0:\n                return 0\n            elif fuel == 0:\n                return 1 if i == finish else 0\n\n            if (i, fuel) not in cache:\n                cnt = 1 if i == finish else 0\n                for j, cost in enumerate(locations):\n                    if j == i: continue\n                    remain = fuel - abs(cost - locations[i])\n                    if remain >= 0:\n                        cnt += dfs(j, remain)\n                cache[(i, fuel)] = cnt\n            return cache[(i, fuel)]\n        \n        cache = dict()\n        return dfs(start, fuel) % (10 ** 9 + 7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # O(fuel*n^2)\n        n = len(locations)\n        dp = [[-1] * (fuel + 1) for _ in range(n)]\n\n        def solve(current, fuel):\n            # 4. if there is no fuel left\n            if fuel < 0: return 0\n            if dp[current][fuel] != -1: return dp[current][fuel]\n            # 3. if current city is finish, add 1 to the ans and keep going further\n            ans = 1 if current == finish else 0\n            for next in range(n):\n                # 1. visit all cities except current\n                if next != current:\n                    # continue this process recursively\n                    ans = (ans + solve(next, fuel - abs(locations[current] - locations[next]))) % 1000000007\n            dp[current][fuel] = ans\n            return ans\n\n        return solve(start, fuel)", "def neigh(start,locations,fuel):\n    res=[]\n    n=len(locations)\n    for j in range(n):\n        i=locations[j]\n        if(j==start):\n            continue\n        if(abs(i-locations[start])<=fuel):\n            res.append(j)\n    return res\n    \nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        if(abs(locations[finish]-locations[start])>fuel):\n            # print(fuel,abs(locations[finish]-locations[start]))\n            return 0\n        n=len(locations)\n        dp=[[-1 for i in range(fuel+1)] for j in range(n)]\n        def dfs(start,fuel):\n            if(fuel<0):\n                return 0\n            if(dp[start][fuel]!=-1):\n                return dp[start][fuel]\n            neighs=neigh(start,locations,fuel)\n            # print(start,neighs,fuel)\n            count=0\n            if(start==finish):\n                count+=1\n            for i in neighs:   \n                count+=(dfs(i,fuel-abs(locations[start]-locations[i])))\n            dp[start][fuel]=count\n            return count\n        return dfs(start,fuel) % (pow(10,9)+7)\n        \n                \n            \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        cost = lambda a,b: abs(locations[a] - locations[b])\n        \n        N = len(locations)\n        @lru_cache(None)\n        def dfs(curr, fuel):\n            if fuel < 0:\n                return 0\n            \n            ans = 1 if curr == finish else 0\n            \n            return ans + sum(dfs(i, fuel - cost(curr, i)) for i in range(N) if i != curr)\n        \n        return dfs(start, fuel) % (10 ** 9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dfs(start, finish, fuel):\n            if abs(locations[start]-locations[finish])>fuel: return 0\n            res=1 if start==finish else 0\n            \n            for i, v in enumerate(locations):\n                if i==start: continue\n                res+=dfs(i, finish, fuel-abs(v-locations[start]))\n            return res\n            \n        mod=10**9+7\n        return dfs(start, finish, fuel)%mod", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        m = {}\n        for i,loc in enumerate(locations):\n            m[loc] = i\n        dp = [[0 for _ in range(len(locations))] for _ in range(fuel+1)]\n        dp[fuel][start] = 1\n        for f in range(fuel,-1,-1):\n            for i,c in enumerate(dp[f]):\n                if c > 0:\n                    for j,loc in enumerate(locations):\n                        if i != j and abs(locations[i]-loc) <= f:\n                            dp[f-abs(locations[i]-loc)][j] += c\n        # print(dp)\n        return sum([dp[i][finish] for i in range(fuel+1)]) % (10**9+7)\n", "import sys\nsys.setrecursionlimit(10**9)\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        M = 10**9+7\n        @lru_cache(None)\n        def helper(curr_city, curr_fuel):\n            if curr_fuel<0:\n                return 0 \n            \n            ans = 0\n            if curr_city==finish:\n                ans += 1\n            \n            for i in range(len(locations)):\n                if i!=curr_city:\n                    ans += helper(i, curr_fuel - abs(locations[i]-locations[curr_city]))\n                    ans %= M\n            \n            return ans\n        \n        return helper(start, fuel)\n    \n    \n    \n    \n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[-1 for i in range(fuel + 1)] for j in range(len(locations))]\n        for i in range(len(locations)):\n            if i == finish:\n                dp[i][0] = 1\n            else:\n                dp[i][0] = 0\n        \n        self.dfs(locations, start, fuel, finish, dp)\n        \n        return dp[start][fuel] % (10 ** 9 + 7)\n    \n    def dfs(self, locations, loc, fuel, finish, dp):\n        if dp[loc][fuel] != -1:\n            return\n        \n        if loc == finish:\n            dp[loc][fuel] = 1\n        else:\n            dp[loc][fuel] = 0\n            \n        for next_loc in range(len(locations)):\n            if next_loc == loc:\n                continue\n            if fuel >= abs(locations[loc] - locations[next_loc]):\n                fuel_res = fuel - abs(locations[loc] - locations[next_loc])\n                self.dfs(locations, next_loc, fuel_res, finish, dp)\n                dp[loc][fuel] += dp[next_loc][fuel_res]", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        cost = lambda i,j: abs(locations[i]-locations[j])\n        @lru_cache(None)\n        def dfs(i, f):\n            if f<0: return 0 \n            return sum([dfs(j,f-cost(i,j)) for j in range(len(locations)) if j != i]) + (i==finish)\n        return dfs(start, fuel) % (10**9+7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # \u4f7f\u7528DP\u8bb0\u5fc6\u6570\u636e\uff0c\u53ef\u4ee5\u5728\u65f6\u95f4\u590d\u6742\u5ea6\u4e0d\u90a3\u4e48\u9ad8\u7684\u524d\u63d0\u4e0b\u89e3\u51b3\u95ee\u9898\n        # dp\u4f5c\u4e3a\u7f13\u5b58\u6570\u636e\uff0c\u5b58\u50a8\u4e86\u5230\u8fbe\u5f53\u524d\u5730\u70b9\u548c\u5269\u4f59\u71c3\u6599\u53ef\u4ee5\u5230\u8fbe\u7ec8\u70b9\u7684\u8def\u5f84\u6570\n        # dp\u7684\u884cid\u4e3a\u5730\u70b9\n        # dp\u7684\u5217id\u4e3a\u5269\u4f59\u71c3\u6599\n        dp = [[-1]*(fuel) for _ in range(len(locations))]\n        \n        def route(st, ed, fuel):\n            if fuel < 0: return 0\n            if dp[st][fuel-1] > -1: return dp[st][fuel-1]\n            res = 0 if st!= ed else 1\n            for i in range(len(locations)):\n                if i != st:\n                    res += route(i, ed, fuel-abs(locations[st]-locations[i]))\n            dp[st][fuel-1] = res % 1000000007\n            return dp[st][fuel-1]\n        # print(dp)\n        return route(start, finish, fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        \n        cost = lambda i, j: abs( locations[i] - locations[j] )\n        \n        # --------------------------------------\n        \n        @lru_cache(None)\n        def dfs(cur, remain_fuel):\n            \n            if remain_fuel < 0:\n                # base case aka stop condition\n                return 0\n            \n            # general case:\n            return sum( dfs(next_city, remain_fuel - cost(cur, next_city) )for next_city in range(len(locations) ) if cur != next_city ) + ( cur == finish )\n\n        # --------------------------------------\n        constant = ( 10 ** 9 + 7 )\n        return dfs(cur=start, remain_fuel=fuel) % constant", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        cost = lambda i,j: abs(locations[i]-locations[j])\n        \n        @lru_cache(None)\n        def dfs(i, f):\n            if f<0: return 0 \n            return sum([dfs(j,f-cost(i,j)) for j in range(len(locations)) if j != i]) + (i==finish)\n        return dfs(start, fuel) % (10**9+7)\n\n# [1528,1529,1530,1531,1532,1533,1534,1535,1536,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628]\n# 50\n# 50\n# 200    \n    \n#         self.rout_dict = {}\n#         start_val, end_val = min(locations[start], locations[finish]), max(locations[start], locations[finish])\n        \n#         if end_val-start_val > fuel: \n#             return 0\n        \n#         def subRoutes(loc, start, end, fuel):\n#             if (loc[start], loc[end], fuel) in self.rout_dict:\n#                 return self.rout_dict[(loc[start], loc[end], fuel)]\n#             elif loc[end] - loc[start] == fuel:\n#                 self.rout_dict[(loc[start], loc[end], fuel)] = 2**(end-start-1)\n#                 return 2**(end-start-1)\n#             elif len(loc) == 1:\n#                 return 1\n#             else:\n#                 # scan possible interval\n#                 l_bound, r_bound = -1, len(loc)\n#                 for i in range(len(loc)):\n#                     if loc[start]+loc[end]-2*loc[i]> fuel:\n#                         l_bound = max(i, l_bound)\n#                     if loc[start]+loc[end]-2*loc[i]<-fuel:\n#                         r_bound = min(i, r_bound)\n                \n#                 l_bound += 1\n#                 next_loc = loc[l_bound:r_bound]\n#                 result = start==end\n#                 for i in range(len(next_loc)):\n#                     if not i == start-l_bound:\n#                         if i > end-l_bound:\n#                             result += subRoutes(next_loc, end-l_bound, i, fuel-abs(next_loc[i]-next_loc[start-l_bound]))\n#                         else:\n#                             result += subRoutes(next_loc, i, end-l_bound, fuel-abs(next_loc[i]-next_loc[start-l_bound]))\n                    \n#                 self.rout_dict[(loc[start], loc[end], fuel)] = result\n#                 return result\n                \n        \n#         loc = sorted(locations)\n#         for i in range(len(loc)):\n#             if loc[i] == start_val:\n#                 start_i = i\n#             if loc[i] == end_val:\n#                 end_i = i\n#                 break\n        \n#         result=subRoutes(loc, start_i, end_i, fuel)\n#         return result%(10**9+7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10**9 + 7\n        def dfs(cur, dp, f):\n            if f < 0:\n                return 0\n            if dp[cur][f] != -1:\n                return dp[cur][f]\n            route = 0\n            if cur == finish:\n                route = 1\n            for j in range(len(locations)):\n                if cur != j:\n                    route = (route + (dfs(j, dp, f - abs(locations[cur] - locations[j])))) % mod\n            dp[cur][f] = route\n            return route\n        \n        dp = [[-1 for _ in range(fuel + 1)] for _ in range(len(locations))]\n        return dfs(start, dp, fuel)\n            \n                    \n        \n                    \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        cost = lambda i,j: abs(locations[i]-locations[j])\n        @lru_cache(None)\n        def dfs(i, f):\n            if f<0: return 0 \n            return sum([dfs(j,f-cost(i,j)) for j in range(len(locations)) if j != i]) + (i==finish)\n        return dfs(start, fuel) % (10**9+7)", "from functools import lru_cache\n\nclass Solution(object):\n    def countRoutes(self, locations, start, finish, fuel):\n        \\\"\\\"\\\"\n        :type locations: List[int]\n        :type start: int\n        :type finish: int\n        :type fuel: int\n        :rtype: int\n        \\\"\\\"\\\"\n        \n        M = 10**9 + 7\n        n = len(locations)\n        \n        @lru_cache(None)\n        def ways(city_idx, fuel_left):\n            if fuel_left < 0 or abs(locations[city_idx] - locations[finish]) > fuel_left:\n                return 0\n            \n            temp = 0\n            \n            if city_idx == finish:\n                temp += 1\n            \n            for other_city in range(n):\n                if other_city == city_idx:\n                    continue\n                cost = abs(locations[other_city] - locations[city_idx])\n                new_fuel_left = fuel_left - cost\n                temp += ways(other_city, new_fuel_left)\n            \n            return temp\n                                       \n        return ways(start, fuel) % M\n        \n        ", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n                \n        cache = {}\n        \n        def process(start, fuel):\n            if not (start, fuel) in cache:\n                ans = 0\n                if fuel == 0:\n                    ans = 1 if start == finish else 0\n                else:\n                    if start == finish:\n                        ans += 1                  \n                    for i in range(n):\n                        if i != start and abs(locations[i]-locations[start]) <= fuel:\n                            ans += process(i, fuel-abs(locations[i]-locations[start]))\n                cache[(start, fuel)] = ans % (10 ** 9 + 7)\n            return cache[(start, fuel)]\n        \n        return process(start, fuel)\n", "class Solution1:\n    \n    def helper(self, cur_loc, fuel):\n        print(cur_loc, fuel)\n        if (cur_loc, fuel) in self.mem:\n            return self.mem[(cur_loc, fuel)]\n        \n        if fuel <= 0:\n            return 0\n        if cur_loc == self.finish and fuel == 0:\n            return 1\n            \n            \n        \n        ans = 0\n        for loc in self.locations:\n            if loc != cur_loc:\n                ans += self.helper(loc, fuel - abs())\n        ans = ans % (10**9 +7)    \n        self.mem[(cur_loc, fuel)] = ans\n        return ans\n        \n        \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        self.finish = finish\n        self.locations = locations\n        self.mem = {}\n        ans = self.helper(start, fuel)\n        \n        return ans\n        \n        \nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        \n        cost = lambda i, j: abs( locations[i] - locations[j] )\n        \n        # --------------------------------------\n        \n        @lru_cache(None)\n        def dfs(cur, remain_fuel):\n            \n            if remain_fuel < 0:\n                # base case aka stop condition\n                return 0\n            \n            # general case:\n            return sum( dfs(next_city, remain_fuel - cost(cur, next_city) )for next_city in range(len(locations) ) if cur != next_city ) + ( cur == finish )\n\n        # --------------------------------------\n        constant = ( 10 ** 9 + 7 )\n        return dfs(cur=start, remain_fuel=fuel) % constant", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mem = {}\n        def dfs(idx, currFuel):\n            key = (idx, currFuel)\n            if key in mem:\n                return mem[key]\n            if currFuel < 0:\n                return 0\n            res = 1 if idx == finish else 0\n            for i in range(len(locations)):\n                if i != idx: res += dfs(i, currFuel - abs(locations[idx]-locations[i]))\n            mem[key] = res\n            return mem[key]\n        return dfs(start, fuel) % (10**9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        cost = lambda i,j: abs(locations[i]-locations[j])\n        @lru_cache(None)\n        def dfs(i, f):\n            if f<0: return 0 \n            return sum([dfs(j,f-cost(i,j)) for j in range(len(locations)) if j != i]) + (i==start)\n        return dfs(finish, fuel) % (10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        \n        cost = lambda i, j: abs( locations[i] - locations[j] )\n        \n        @lru_cache(None)\n        def dfs(cur, remain_fuel):\n            \n            if remain_fuel < 0:\n                return 0\n\n            return sum( dfs(j, remain_fuel - cost(cur, j) )for j in range(len(locations) ) if cur != j ) + ( cur == finish )\n\n        # --------------------------------------\n        return dfs(cur=start, remain_fuel=fuel) % ( 10 ** 9 + 7 )", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[0 for _ in range(len(locations))] for _ in range(fuel+1)]\n        dp[fuel][start] = 1\n        for f in range(fuel,-1,-1):\n            for i,c in enumerate(dp[f]):\n                if c > 0:\n                    for j,loc in enumerate(locations):\n                        if i != j and abs(locations[i]-loc) <= f:\n                            dp[f-abs(locations[i]-loc)][j] += c\n        # print(dp)\n        return sum([dp[i][finish] for i in range(fuel+1)]) % (10**9+7)\n", "class Solution:\n    def dfs(self,cur,end,dp,locations,fuel):\n        if fuel<0:\n            return 0\n        if dp[cur][fuel]!=-1:\n            return dp[cur][fuel]\n        if cur==end:\n            ans=1\n        else:\n            ans=0\n    \n        for next_city in range(len(locations)):\n            if next_city!=cur:\n                ans=(ans+self.dfs(next_city,end,dp,locations,fuel-abs(locations[next_city]-locations[cur])))%1000000007\n        dp[cur][fuel]=ans\n        return ans\n                \n            \n            \n        \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n=len(locations)\n        dp=[[-1 for _ in range(fuel+1)]for _ in range(n)]\n        return self.dfs(start,finish,dp,locations,fuel)\n", "from functools import lru_cache\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        s, f = locations[start], locations[finish]\n        locations.sort()\n        # print(locations)\n        \n        maps = {}\n        for i, loc in enumerate(locations):\n            maps[loc] = i\n        \n        @lru_cache(maxsize=None)\n        def helper(l, r, fuel):\n            if l == r:  # goal to goal\n                count = 1  #  reach\n                for loc in locations:\n                    if loc != l and abs(loc - l) + abs(loc - r) <= fuel:\n                        n1 = 1\n                        n2 = helper(loc, r, fuel - abs(loc - l))\n                        count += n2\n                return count\n            if abs(r - l) > fuel:\n                # print(l, r, fuel, 0)\n                return 0\n            else:\n                count = 0  # directly go there\n                for loc in locations:\n                    if loc != l and abs(loc - l) + abs(loc - r) <= fuel:\n                        n1 = 1\n                        n2 = helper(loc, r, fuel - abs(loc - l))\n                        count += n2\n                # print(count)\n                # print(l, r, fuel, count)\n                return count\n            \n        return helper(s, f, fuel) % (10 ** 9 + 7)\n                    \n", "class Solution:\n    def countRoutes(self, A: List[int], start: int, end: int, fuel: int) -> int:\n        \n        mod = 10 ** 9 + 7\n        \n        cost = lambda a, b: abs(A[a] - A[b])\n        \n        @functools.lru_cache(None)\n        def route(start, fuel):\n            nonlocal end\n            \n            if fuel < 0:\n                return 0\n            \n            r = 1 if start == end else 0\n\n            for i in range(len(A)):\n                \n                if i == start:\n                    continue\n                \n                \n                r += route(i, fuel - cost(start, i)) % mod\n                    \n            return r % mod\n        \n        answer = route(start, fuel)\n        # print(route.cache_info())\n        # assert len(A) < 100\n        return answer\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        memo = {}\n        def f(i, fuel_remain):\n            if (i, fuel_remain) in memo:\n                return memo[(i, fuel_remain)]\n            \n            total = 0\n            for j in range(len(locations)):\n                if i == j or abs(locations[j] - locations[i]) > fuel_remain:\n                    continue\n                    \n                if j == finish:\n                    total += 1\n\n                total += f(j, fuel_remain - abs(locations[j] - locations[i]))\n            \n            memo[(i, fuel_remain)] = total\n            return total % (10**9 + 7)\n        \n        return f(start, fuel) + (1 if start == finish else 0)\n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        dp = [[-1]*(fuel+1) for _ in range(n)]\n        \n        def dfs(locations,p,finish,f,dp):\n            if f < 0:\n                return 0\n            if dp[p][f] != -1:\n                return dp[p][f]\n            res = 0\n            if p == finish:\n                res += 1\n            for i in range(n):\n                if i != p:\n                    res += dfs(locations,i,finish,f - abs(locations[i] - locations[p]),dp) % (10**9 + 7)\n            dp[p][f] = res\n            return res % (10**9 + 7)\n        \n        return dfs(locations,start,finish,fuel,dp)\n\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        def help(locations, cur, e, dp, fuel):\n            if fuel < 0:\n                return 0\n            if dp[cur][fuel] != -1:\n                return dp[cur][fuel]\n            ans = 1 if cur == e else 0\n            for next in range(len(locations)):\n                if next != cur:\n                    ans = (ans + help(locations, next, e, dp, fuel - abs(locations[cur] - locations[next]))) % 1000000007\n\n            dp[cur][fuel] = ans\n            return ans\n        \n        n = len(locations)\n        dp = [[-1] * (fuel + 1) for _ in range(n) ]\n        return help(locations, start, finish, dp, fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n\\t    cost = lambda i,j: abs(locations[i]-locations[j])\n\\t    @lru_cache(None)\n\\t    def dfs(i, f):\n\\t\\t    if f<0: return 0 \n\\t\\t    return sum([dfs(j,f-cost(i,j)) for j in range(len(locations)) if j != i]) + (i==finish)\n\\t    return dfs(start, fuel) % (10**9+7)\n\n        ", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(maxsize=None)\n        def traverse(curr: int, fuel: int) -> int:\n            if fuel < 0:\n                return 0\n            res = 0\n            if curr == finish:\n                res += 1\n                if fuel == 0:\n                    return res\n            for i, location in enumerate(locations):\n                if i != curr:\n                    res += traverse(i, fuel - abs(location - locations[curr]))\n            return res\n        return traverse(start, fuel) % (10**9 + 7)", "def solve(locations, curr, end, dp, fuel):\n    if(fuel< 0):\n        return 0\n    if(dp[curr][fuel]!=-1):\n        return dp[curr][fuel]\n    if(curr == end):\n        ans = 1\n    else:\n        ans = 0\n    for j in range(len(locations)):\n        if(j!=curr):\n            ans = (ans + solve(locations,  j, end, dp, fuel -abs(locations[j]- locations[curr])))% 1000000007\n    dp[curr][fuel] = ans\n    return dp[curr][fuel]\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp=[[-1 for i in range(fuel+1)] for j in range(len(locations))]\n        return solve(locations, start, finish, dp, fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n            \n        n = len(locations)\n        dp = [[-1] * (fuel + 1) for _ in range(n)]\n        ans = self.dfs(locations, start, finish, fuel, dp)\n        return (ans)\n\n    def dfs(self, location, curr_city, finish, fuel, dp):\n        if fuel < 0:\n            return 0\n        if dp[curr_city][fuel] != -1:\n            return dp[curr_city][fuel]\n        ans = 0\n        if curr_city == finish:\n            ans = 1\n        # even after adding to ans, continue processing\n        for next_city in range(len(location)):\n            if next_city == curr_city:\n                continue\n            else:\n                ans = ans +self.dfs(location, next_city, finish, fuel - abs(location[curr_city] - location[next_city]), dp) \n                ans %= 1000000007\n        dp[curr_city][fuel] = ans\n        return ans", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dp(i,left):\n            if left<0:\n                return 0\n            ret= i==finish\n            for ni in range(len(locations)):\n                if i==ni:\n                    continue\n                ret+=dp(ni,left-abs(locations[i]-locations[ni]))\n            return ret\n        return dp(start,fuel)%(10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        memo = {}\n        return self.dp(locations, start, finish, fuel, memo)\n        \n    def dp(self, locations, i, finish, fuel, memo) -> int:\n        # ran out of fuel return no possible routes to this location\n        if fuel < 0:  return 0\n        \n        if (i, fuel) in memo:\n            return memo[(i, fuel)]\n        \n        res = 0\n        \n        # if we have successfully traversed to the finish, we have found a route\n        if i == finish: res += 1\n        \n        for j in range(len(locations)):\n            # skip the current location we're at\n            if i == j:\n                continue\n            \n            # visit all other locations, subtracting the fuel we used to get here\n            res += self.dp(locations, j, finish, fuel - abs(locations[i] - locations[j]), memo)\n        \n        memo[(i, fuel)] = res % (10 ** 9 + 7)\n        return memo[(i, fuel)]\n\n        # ----------------------------------------------------------------\n        \\\"\\\"\\\"\n        cost = lambda i,j: abs(locations[i]-locations[j])\n        @lru_cache()\n        \n        def dfs(i, f):\n            if f < 0:  return 0\n            return sum([ dfs(j, f-cost(i,j)) \n                          for j in range(len(locations)) \n                           if j != i]) + (i==finish)\n        \n        return dfs(start, fuel) % (10**9+7) \n        \\\"\\\"\\\"\n        ", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        cost = lambda i,j: abs(locations[i]-locations[j])\n        @lru_cache(None)\n        def dfs(i, f):\n            if f<0: return 0 \n            return sum([dfs(j,f-cost(i,j)) for j in range(len(locations)) if j != i]) + (i==finish)\n        return dfs(start, fuel) % (10**9+7)\n\n    def countRoutes1(self, L: List[int], st: int, end: int, f: int) -> int:\n        M=10**9+7\n        res=0\n        def dfs(st,end,f):\n            for i,c in enumerate(L):\n                need=abs(c-L[st])\n                if need <= f:\n                    if i==end:\n                        res+=1\n                    else:\n                        if need<f: dfs(i,end,f-need)\n        dfs(st,end,f)\n        return res%M", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # self.count = 0\n        @lru_cache(None)\n        def dfs( current, fuel):\n            ans = 0\n            if fuel>=0:\n                if current == finish:\n                    ans +=1\n                \n                for i,loc in enumerate(locations):\n                    if i!=current:\n                        consume = abs(locations[current] - loc)\n                        ans += dfs(i, fuel - consume)\n            \n            return ans % (10**9+7)\n        \n        ret = dfs(start, fuel)\n        return ret", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        \n        @lru_cache(None)\n        def dp(u, f):\n            ans = +(u == finish)\n            du = locations[u]\n            for v, dv in enumerate(locations):\n                if v != u:\n                    delta = abs(du - dv)\n                    if delta <= f:\n                        ans += dp(v, f - delta)\n                        ans %= MOD\n            return ans\n        \n        return dp(start, fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        dp = [[-1 for _ in range(fuel)]for _ in range(n)]\n        r = self.helper(locations, start, dp, fuel, finish)\n        print (dp)\n        return r\n    \n    def helper(self, locations, cur, dp, fuel, ed):\n        if fuel < 0:\n            return 0\n        if dp[cur][fuel-1] != -1:\n            return dp[cur][fuel-1]\n        \n        n = len(locations)\n        r = 0\n        if cur == ed:\n            r += 1\n        \n        for i in range(n):\n            if i != cur:\n                r += self.helper(locations, i, dp, fuel - abs(locations[cur] - locations[i]), ed)\n        \n        dp[cur][fuel-1] = r % (10 ** 9 + 7)\n        return dp[cur][fuel-1]\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        numCity = len(locations)\n        dp = [[None]*numCity for _ in range(fuel+1)] # row=fuel, col=city\n        def helper(city, fuel):\n            if fuel < 0: return 0\n            res = dp[fuel][city]\n            if res is not None: return res\n            res = (int(city==finish) + sum(helper(city2, fuel-abs(locations[city]-locations[city2])) for city2 in range(numCity) if city!=city2)) % (10**9 + 7)\n            dp[fuel][city] = res\n            return res\n        return helper(start, fuel)\n                    \n        # mod = 10**9 + 7\n        # for city in range(numCity):\n        #     dp[0][city] = 1 if city==finish else 0\n        # for fuelLeft in range(1,fuel):\n        #     for city in range(numCity):\n        #         dist = lambda city1, city2: abs(locations[city1]-locations[city2])\n        #         cost = lambda city2: dp[fuelLeft-dist(city,city2)][city2] if city!=city2 and dist(city,city2)<=fuelLeft else 0\n        #         dp[fuelLeft][city] = (int(city==finish) + sum(map(cost, range(numCity)))) % mod\n        # return sum(map)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        locLen = len(locations)\n        MOD = 10**9 + 7\n        dp = {}\n        \n        def helper(i, f):\n            if (i, f) in dp:\n                return dp[(i, f)]\n            subAns = 0\n            for i1 in range(locLen):\n                if i1 == i or abs(locations[i1] - locations[i]) > f:\n                    continue\n                if i1 == finish:\n                    subAns += (1 + helper(i1, f - abs(locations[i1] - locations[i])))\n                else:\n                    subAns += helper(i1, f - abs(locations[i1] - locations[i]))\n            dp[(i, f)] = subAns%MOD\n            return dp[(i, f)]\n        \n        return helper(start, fuel) + (1 if start == finish else 0)", "# class Solution:\n#     def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n#         if fuel < 0:\n#             return 0\n        \n#         result = 0\n#         if start == finish:\n#             result = 1\n              \n#         for i in range(len(locations)):\n#             if i != start:\n#                 result = (result + self.countRoutes(locations, i, finish, fuel - abs(i - start))) % 1000000007                \n#         return result\nclass Solution:\n    def dp(self, A, curr, e, fuel, dp):\n        mod = 10 ** 9 + 7\n        if fuel < 0: return 0\n        if dp[curr][fuel] != -1: return dp[curr][fuel]\n        \n        ans = 1 if curr == e else 0\n        for nxt in range(len(A)):\n            if nxt != curr:\n                ans += self.dp(A, nxt, e, fuel - abs(A[curr] - A[nxt]), dp)\n                ans %= mod\n                \n        dp[curr][fuel] = ans\n        return ans\n    \n    def countRoutes(self, A: List[int], s: int, e: int, fuel: int) -> int:\n        if not A: return 0\n        n = len(A)\n        dp = [[-1]*(fuel+1) for _ in range(n)]\n        return self.dp(A, s, e, fuel, dp)        ", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10**9 + 7\n        pos_start = locations[start]\n        pos_finish = locations[finish]\n        locations.sort()\n        start = locations.index(pos_start)\n        finish = locations.index(pos_finish)\n        # print(locations, start, finish)\n             \n        @lru_cache(maxsize = None)\n        def find(start, fuel):\n            count = 0\n            if abs(start-finish)==1 and fuel==abs(locations[start] - locations[finish]):\n                return 1\n            if locations[start] == locations[finish]:\n                    count += 1\n            if fuel >= abs(locations[start] - locations[finish]):\n                for i in range(start-1, -1, -1):\n                    if abs(locations[start] - locations[i]) + abs(locations[i] - locations[finish]) <= fuel:\n                        count += find(i, fuel - abs(locations[start] - locations[i]))\n                    else:\n                        break\n                for j in range(start+1, len(locations)):\n                    if abs(locations[start] - locations[j]) + abs(locations[j] - locations[finish]) <= fuel:\n                        count += find(j, fuel - abs(locations[start] - locations[j]))\n                    else:\n                        break\n            return count\n        return find(start, fuel) % MOD\n                        \n            \n        \n        \n        \n        \n#         X X X start X X X finish X X X\n        \n#         \u91cd\u70b9\u4e0d\u5728\u4e8ecity\u7684\u7f16\u53f7\uff0c\u800c\u5728\u4e8e\u4ed6\u4eec\u7684\u4f4d\u7f6e\n#         \u6bcf\u4e2a\u4f4d\u7f6e\u90fd\u6709\u4e00\u4e2afuel\u7684\u503c\n#         \u9996\u5148\u4fdd\u8bc1\n#         \u7528\u9012\u5f52\u7b97\u6cd5\uff0c\u7b2c\u4e00\u5c42\u4ecestart\u7684\u4f4d\u7f6e\u51fa\u53d1\uff0c\u8003\u5bdfstart\u53ef\u4ee5\u5230\u8fbe\u7684\u4f4d\u7f6e\u4ee5\u53ca\u5269\u4f59\u7684fuel\n#         \u7b2c\u4e8c\u5c42\u4ecestart\u53ef\u4ee5\u5230\u8fbe\u7684\u4f4d\u7f6e\u51fa\u53d1\uff0c\u7ee7\u7eed\u51cf\u5c11fuel\u5e76\u8003\u8651\u76f8\u5e94\u7684\u6b21\u6570\n#         \u540e\u9762\u7ee7\u7eed\u8fed\u4ee3\uff0c\u76f4\u5230\u53ea\u80fd\u76f4\u63a5\u5230\u8fbe\u7684\u57ce\u5e02\n#         find(pos, fuel) \u8fd4\u56de\u8def\u5f84\u6570\u91cf\n#         res = find(start, fuel)\n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.res = 0\n        memo = {}\n        def dfs(cur_city, fuel):\n            if (cur_city, fuel) in memo: return memo[(cur_city, fuel)]\n            if fuel < 0:\n                return 0\n            cnt = 0\n            if cur_city == finish:\n                cnt = 1\n            for i in range(len(locations)):\n                if i == cur_city: continue\n                cnt += dfs(i, fuel - abs(locations[i] - locations[cur_city]))\n            memo[cur_city, fuel] = cnt\n            return cnt\n            \n        return dfs(start, fuel)%(10**9 + 7)\n", "class Solution:\n    \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        memo = {}\n        return self.dp(locations, start, finish, fuel, memo)\n        \n    def dp(self, locations, i, finish, fuel, memo) -> int:\n        # ran out of fuel return no possible routes to this location\n        if fuel < 0:\n            return 0\n        \n        if (i, fuel) in memo:\n            return memo[(i, fuel)]\n        \n        res = 0\n        \n        # if we have successfully traversed to the finish, we have found a route\n        if i == finish:\n            res += 1\n        \n        for j in range(len(locations)):\n            # skip the current location we're at\n            if i == j:\n                continue\n            \n            # visit all other locations, subtracting the fuel we used to get here\n            res += self.dp(locations, j, finish, fuel - abs(locations[i] - locations[j]), memo)\n        \n        memo[(i, fuel)] = res % (10 ** 9 + 7)\n        return memo[(i, fuel)]\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n=len(locations)\n        dp=[[-1]*(fuel+1) for i in range(n)]\n        mod=10**9+7\n        def dfs(cur,fin,fu):\n            if fu<0:\n                return 0\n            if dp[cur][fu]!=-1:\n                return dp[cur][fu]%mod\n            if cur==fin:\n                ans=1\n            else:\n                ans=0\n            for i in range(n):\n                if i!=cur:\n                    ans=ans+dfs(i,fin,fu-abs(locations[i]-locations[cur]))%mod\n            dp[cur][fu]=ans%mod\n            return ans%mod\n        return dfs(start,finish,fuel)%mod", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.res = 0\n        memo = {}\n        def dfs(cur_city, fuel):\n            if (cur_city, fuel) in memo: return memo[cur_city, fuel]\n            if fuel < 0:\n                return 0\n            cnt = 1 if cur_city == finish else 0 #now at finish, fuel cost is 0\n            for i in range(len(locations)):\n                if i == cur_city: continue\n                cnt += dfs(i, fuel - abs(locations[i] - locations[cur_city])) #add other possible ways.\n            memo[cur_city, fuel] = cnt\n            return cnt\n            \n        return dfs(start, fuel)%(10**9 + 7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        memo = {}\n        return self.dp(locations, start, finish, fuel, memo)\n        \n    def dp(self, locations, i, finish, fuel, memo) -> int:\n        if fuel < 0:\n            return 0\n        \n        if (i, fuel) in memo:\n            return memo[(i, fuel)]\n        \n        res = 0\n        \n        if i == finish:\n            res += 1\n        \n        for j in range(len(locations)):\n            if i == j:\n                continue\n            \n            res += self.dp(locations, j, finish, fuel - abs(locations[i] - locations[j]), memo)\n        \n        memo[(i, fuel)] = res % (10 ** 9 + 7)\n        return memo[(i, fuel)]", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod=10**9+7\n        \n        @lru_cache(None)\n        def func(a,fuel):\n            t=0\n            if fuel<0:\n                return 0\n            if a==finish:\n                t+=1\n            curr = locations[a]\n            for i,item in enumerate(locations):\n                if i!=a:\n                    t += func(i,max(-1,fuel-abs(curr-item)))\n                    t %= mod\n            return t % mod\n        \n        c=func(start,fuel)\n        return c % mod\n", "from functools import lru_cache\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        MOD = 10 ** 9 + 7\n        \n        @lru_cache(None)\n        def dp(pos, f):\n            \n            # print (pos, f)\n            \n            nonlocal finish\n            nonlocal MOD\n            \n            res = 0\n            \n            if f < 0:\n                return 0\n            \n            if pos == finish:\n                res += 1\n            \n            if f == 0:\n                return res\n            \n            \n            \n            for i, vi in enumerate(locations):\n                if i == pos:\n                    continue\n                    \n                res += dp(i, f - abs( locations[pos] - vi ))\n                \n            return res % MOD\n                \n        ans = dp(start, fuel)\n                \n        \n        \n        \n        \n        return ans % MOD\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10**9+7\n        def dfs(cur_loc, fuel):\n            if (cur_loc, fuel) in mem:\n                return mem[(cur_loc, fuel)]\n            if fuel < 0: return 0\n            ans = 0\n            if cur_loc == finish: ans = 1\n            for i in range(len(locations)):\n                if cur_loc == i: continue\n                ans += dfs(i, fuel - abs(locations[cur_loc] - locations[i]))\n            mem[(cur_loc, fuel)] = ans\n            return ans\n        mem = {}\n        return dfs(start, fuel) % mod\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # Trivial DP?\n        MOD = 10 ** 9 + 7\n        \n        n = len(locations)\n        \n        from functools import lru_cache\n        \n        @lru_cache(None)\n        def ways(index, remFuel):\n            #print(\\\"  \\\" * indent, index, remFuel)\n            if index == finish:\n                ans = 1\n                possible = True\n            else:\n                ans = 0\n                possible = False\n            \n            for i in range(n):\n                if i == index: continue\n                dist = abs(locations[i] - locations[index])\n                if dist <= remFuel:\n                    possible = True\n                    w = ways(i, remFuel - dist)\n                    ans = (ans + w) % MOD\n                    \n            if possible:\n                #print(\\\"  \\\" * indent, \\\"answer:\\\", ans)\n                return ans\n            \n            #print(\\\"  \\\" * indent, \\\"rip\\\")\n            return 0\n        \n        return ways(start, fuel) % MOD", "class Solution:\n    def countRoutes(self, nums: List[int], start: int, finish: int, fuel: int) -> int:\n        def dp(i, f, cache):\n            # print(i, f)\n            if f < 0: \n                return 0\n            if f == 0:\n                return 1 if i == finish else 0\n            if (i, f) not in cache:\n                ans = 1 if i == finish else 0\n                for j in range(len(nums)):\n                    if j != i:\n                        ans += dp(j, f - abs(nums[i] - nums[j]), cache)\n                cache[(i, f)] = ans\n            return cache[(i, f)]\n        \n        return dp(start, fuel, {}) % (10 ** 9 + 7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # DFS\n        self.N = len(locations)\n        self.finish = finish\n        self.M = dict()\n        def dfs(i, f):\n            if (i, f) not in self.M:\n                res = 0\n                if i == self.finish:\n                    res += 1\n                for j in range(self.N):\n                    if j != i and f >= abs(locations[i] - locations[j]):\n                        res += dfs(j, f - abs(locations[i] - locations[j]))\n                self.M[(i, f)] = res\n            return self.M[(i, f)]\n        \n        return dfs(start, fuel) % (10**9 + 7) ", "from collections import deque\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        N = len(locations)\n        M = 10 ** 9 + 7\n        adj_matrix = [[0 for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(i+1, N):\n                adj_matrix[i][j] = abs(locations[i] - locations[j])\n                adj_matrix[j][i] = abs(locations[i] - locations[j])\n\n        # q = deque()\n        # ans = 0\n        # q.append((start, fuel))\n        # while len(q) > 0:\n        #     location, fuel_left = q.popleft()\n        #     # print(location, fuel_left)\n        #     if location == finish:\n        #         ans = (ans + 1) % M\n        #     for dst in range(N):\n        #         if dst == location:\n        #             continue\n        #         if adj_matrix[location][dst] + adj_matrix[dst][finish] <= fuel_left:\n        #             q.append((dst, fuel_left - adj_matrix[location][dst]))\n        memo = {}\n        \n        def dfs(location, fuel_left):\n            if fuel_left < 0:\n                return 0\n            if (location, fuel_left) in memo:\n                return memo[(location, fuel_left)] % M\n            \n            if location == finish:\n                cnt = 1\n            else:\n                cnt = 0\n            for dst in range(N):\n                if dst == location:\n                    continue\n                if adj_matrix[location][dst] + adj_matrix[dst][finish] <= fuel_left:\n                    cnt += dfs(dst, fuel_left - adj_matrix[location][dst])\n            memo[(location, fuel_left)] = cnt\n            return cnt\n        \n        return dfs(start, fuel) % M\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        DP = {}\n        def f(i, fuel):\n            # Returns number of paths to finish starting from `i` and `fuel`\n            if fuel < 0:\n                return 0\n            if (i, fuel) in DP:\n                return DP[i, fuel]\n            count = 0\n            if i == finish:\n                count += 1\n            for j in range(len(locations)):\n                if i != j:\n                    count = (count + f(j, fuel - abs(locations[i] - locations[j]))) % MOD\n            DP[i, fuel] = count\n            return count\n        return f(start, fuel)", "class Solution:\n    def dfs(self, locations, memo, current, finish, remain_fuel):\n        if remain_fuel < 0:\n            return 0\n        if remain_fuel == 0:\n            return 1 if current == finish else 0\n        if (current, remain_fuel) in memo:\n            return memo[(current, remain_fuel)]\n        l = len(locations)\n        ans = 0 if current!=finish else 1\n        for i in range(l):\n            if i == current:\n                continue\n            dist = abs(locations[current] - locations[i])\n            ans += self.dfs(locations, memo, i, finish, remain_fuel - dist)\n        memo[(current, remain_fuel)] = ans\n        return ans\n            \n        \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        NUM = 10**9 + 7\n        memo = dict()\n        return self.dfs(locations, memo, start, finish, fuel)%NUM\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        memo = [[-1 for j in range(fuel+1)] for i in range(len(locations))]\n        \n        def dp(start, fuel):\n            nonlocal memo\n            nonlocal finish\n            nonlocal locations\n            if memo[start][fuel] == -1:\n                memo[start][fuel] = 1 if start == finish else 0\n                for i in range(len(locations)):\n                    if i != start and fuel >= abs(locations[start]-locations[i]):\n                        memo[start][fuel] += dp(i,fuel-abs(locations[start]-locations[i]))\n                        memo[start][fuel] %= (10**9+7)\n            return memo[start][fuel]\n        \n        return dp(start,fuel) ", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        memo = {}\n        mod = 10**9+7\n        def dp(f,c):\n            if f == 0 and c == finish:\n                return 1\n            else:\n                if (f,c) not in memo:\n                    if c == finish and f > 0:\n                        ans = 1\n                    else:\n                        ans = 0\n                    for nxt in range(len(locations)):\n                        if nxt == c:continue\n                        dis = abs(locations[c]-locations[nxt])\n                        if dis <= f:\n                            ans += dp(f-dis,nxt)\n                    memo[f,c] = ans%mod\n                return memo[f,c]\n        return dp(fuel,start)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, totalFuel: int) -> int:\n        n = len(locations)\n        mod = int(1e9 + 7)\n        dp = [[-1]* (totalFuel+1) for i in range(n)]\n        def getNums(current, fuel):\n            nonlocal dp, n, finish, start, mod\n            if fuel == 0:\n                if current == finish:\n                    return 1\n                return 0 \n            if dp[current][fuel]>-1:\n                return dp[current][fuel] \n            ans = 0 \n            if current == finish: \n                ans = 1 \n            for i in range(n):\n                if i!=current and abs(locations[current] - locations[i])<=fuel:\n                    ans= (ans + getNums(i,fuel-abs(locations[current] - locations[i])))%mod\n            dp[current][fuel] = ans  \n            return dp[current][fuel] \n        return getNums(start, totalFuel)%mod\n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        memo = {}\n        def helper(fuell, curr):\n            if (fuell, curr) in memo:\n                return memo[(fuell, curr)]\n            if fuell < 0:\n                return 0\n            x = 0\n            if curr == locations[finish]:\n                x = 1\n            y = x + sum([helper(fuell - abs(loc - curr), loc) for loc in locations if loc != curr]) % (10 ** 9 + 7)\n            memo[(fuell, curr)] = y\n            return y\n        return helper(fuel, locations[start])", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        start_loc = locations[start]\n        finish_loc = locations[finish]\n        locations.sort()\n        start = bisect_left(locations, start_loc)\n        finish = bisect_left(locations, finish_loc)\n        @lru_cache(None)\n        def dp(cur, cur_fuel):\n            \n            return total\n        dp = [[-1] * (fuel + 1) for _ in range(len(locations))]\n        def f(cur, cur_fuel):\n            if dp[cur][cur_fuel] != -1:\n                return dp[cur][cur_fuel]\n                        \n            if abs(locations[cur] - locations[finish]) > fuel:\n                return 0\n            total = 1 if cur == finish else 0\n            for i in range(cur + 1, len(locations)):\n                dist = locations[i] - locations[cur]\n                if dist <= cur_fuel:\n                    total += f(i, cur_fuel - dist)\n                else:\n                    break\n            \n            for i in reversed(list(range(0, cur))):\n                dist = locations[cur] - locations[i]\n                if dist <= cur_fuel:\n                    total += f(i, cur_fuel - dist)\n                else:\n                    break\n            dp[cur][cur_fuel] = total\n\n            return total \n        return f(start, fuel) % 1_000_000_007\n                    \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mem = {}\n        def dfs(idx, currFuel):\n            key = (idx, currFuel)\n            if key in mem:\n                return mem[key]\n            if currFuel < 0:\n                return 0\n            res = 1 if idx == finish else 0\n            for i in range(len(locations)):\n                if i != idx: res += dfs(i, currFuel - abs(locations[idx]-locations[i])) % (10**9 + 7)\n            mem[key] = res\n            return mem[key] % (10**9 + 7)\n        return dfs(start, fuel) % (10**9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        N = len(locations)\n        # DP = [[-1 for _ in range(fuel+1)] for _ in range(N)]\n\n        # for idx, x in enumerate(locations):\n        #     dist = abs(x - locations[finish])\n        #     print (idx, x, dist)\n        #     if dist <= fuel:\n        #         for y in range(dist, fuel+1):\n        #             DP[idx][y] = 1\n#         for x in locations:\n#             dist = abs(x - locations[finish])\n#             if dist <= fuel:\n#                 for y in range(dist, fuel+1):\n#                     DP[finish][y] = 1\n                    \n#         table = {}\n#         for idx, x in enumerate(locations):\n#             for idxy, y in enumerate(locations):\n#                 table[(idx, idxy)] = abs(locations[idx] - locations[idxy])\n                \n#         for c in range(fuel+1):\n#             for r in range(N):\n#                 # if True or DP[r][c] > 0:\n#                 for x in range(N):\n#                     if x == r: continue\n#                     dist = abs(table[(r, x)])\n#                     if dist <= c:\n#                         # print (r, c, \\\"going to\\\", x, \\\"cost\\\", dist, \\\"before\\\", DP[r][c], \\\" adding\\\", DP[x][c-dist])\n#                         DP[r][c] += DP[x][c-dist]\n#                         # print (\\\"after\\\", DP[r][c])\n#                 DP[r][c] %= 1000000007\n#                     # for y in range(c, N)\n       # return DP[start][fuel] % 1000000007 \n            \n        # print (DP)\n        @lru_cache(None)\n        def dp(i, k):\n            if k < 0:\n                return 0\n            # if DP[i][k] >= 0:\n            #     return DP[i][k]\n            ans = 1 if i == finish else 0\n            for j in range(N):\n                if i == j: continue\n                ans += dp(j, k - abs(locations[i]-locations[j]))\n            ans %= 1000000007\n            # DP[i][k] = ans\n            return ans\n        return dp(start, fuel)\n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        found = {}\n        \n        def count(cstart, cfuel):\n            if (cstart, cfuel) in found:\n                return found[(cstart, cfuel)]\n            if cfuel < 0:\n                return 0\n            if cfuel == 0:\n                return cstart == finish\n            r = int(cstart == finish)\n            for i, l in enumerate(locations):\n                if i != cstart:\n                    r += count(i, cfuel - abs(locations[i] - locations[cstart]))\n            found[(cstart, cfuel)] = r % (10 ** 9 + 7)\n            return found[(cstart, cfuel)]\n        \n        return count(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10 ** 9 + 7\n        n = len(locations)\n        @functools.lru_cache(None)\n        def dp(i, f):\n            if f < 0:\n                return 0\n            ans = sum(dp(j, f - abs(locations[i] - locations[j])) for j in range(n) if j != i)\n            ans += i == finish\n            return ans % mod\n        return dp(start, fuel)\n", "class Solution:\n    def countRoutes(self, locations, start, finish, fuel):\n        n = len(locations)\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(i, k):\n            return (i == finish) + sum(dp(j, k - abs(locations[i] - locations[j])) for j in range(n) if i != j) % MOD if k >= 0 else 0\n                \n        return dp(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        \n        def dp(curr_loc, fuel):\n            \n            if (curr_loc, fuel) in memo:\n                return memo[(curr_loc, fuel)]\n            \n            if fuel < 0:\n                return 0\n            \n            ans = 0\n            \n            if curr_loc ==  finish:\n                ans = 1\n        \n            for i, loc in enumerate(locations):\n                \n                if i != curr_loc:\n                    ans += dp(i, fuel - abs(locations[curr_loc] - loc))\n                  \n            memo[(curr_loc, fuel)] = ans\n            \n            return ans\n            \n        memo = {}\n        \n        return dp(start,fuel) % (10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10**9+7\n        return self.dfs(locations, start, finish, fuel, {}) % mod\n        \n      \n    def dfs(self, locations, start, finish, fuel, memo):\n      if (start, fuel) in memo:\n        return memo[(start, fuel)]\n      if fuel < 0:\n        return 0\n      count = 0\n      if start == finish: \n        count += 1\n        \n      for i in range(len(locations)):\n        diff = abs(locations[i] - locations[start])\n        if i == start:\n          continue\n        count += self.dfs(locations, i, finish, fuel - diff, memo)\n      memo[(start, fuel)] = count % (10**9+7) \n      return memo[(start, fuel)]", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def dp(cur, fuel):\n            if fuel < 0:\n                return 0\n            ret = 1 if cur == finish else 0\n            for i in range(len(locations)):\n                if i == cur: continue\n                ret += dp(i, fuel - abs(locations[i]-locations[cur]))\n            return ret % MOD\n        \n        return dp(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        mem = {}\n        mod = 10**9 + 7\n        \n        def helper(ind, f):\n            cnt = 0\n            if (ind, f) in mem:\n                return mem[(ind, f)]\n            if ind < 0 or ind > n-1:\n                return 0\n            if ind == finish and f >= 0:\n                cnt += 1\n            for i in range(n):\n                if i != ind and f - abs(locations[ind]-locations[i]) >= 0:\n                    cnt += helper(i, f - abs(locations[ind]-locations[i]))%mod\n            mem[(ind, f)] = cnt\n            return cnt%mod\n        \n        return helper(start, fuel)%mod\n            \n            \n", "import functools\n\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n\n        @functools.lru_cache(None)\n        def foo(loc, f):\n            res = 1 if loc==finish else 0\n            for i in range(len(locations)):\n                if i != loc:\n                    temp = f - abs(locations[loc] - locations[i])\n                    if temp >= 0:\n                        res = (res + foo(i, temp)) % MOD\n            return res% MOD\n\n        return foo(start, fuel)\n\n\n\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        shortest = {finish:0}\n        ans = 0\n        \n        heap = sorted([[abs(locations[i] - locations[finish]), i] for i in range(len(locations))])\n        # print(heap)\n        while len(shortest) < len(locations):\n            d, i = heapq.heappop(heap)\n            if i in shortest: continue\n            shortest[i] = d\n            for j in range(len(locations)):\n                if j not in shortest and j != finish:\n                    heapq.heappush(heap, [abs(locations[j] - locations[i]) + d, j])\n        # print(shortest)\n        \n        @lru_cache(None)\n        def dfs(cur, fuel):\n            # print(cur)\n            if fuel < shortest[cur]:\n                return 0\n            if fuel == 0:\n                if cur != finish:\n                    return 0\n                else:\n                    return 1\n            ans = 0\n            if cur == finish:\n                ans += 1\n            for i in range(len(locations)):\n                cost = abs(locations[i] - locations[cur])\n                if i != cur and cost <= fuel:\n                    ans += dfs(i, fuel - cost) % 1000000007\n            return ans % 1000000007\n                    \n        return dfs(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        return self.helper(locations, start, finish, fuel, {})\n    \n    def helper(self, locations, start, finish, fuel, memo):\n        if fuel < 0:\n            return 0\n        \n        if (start, fuel) in memo:\n            return memo[(start, fuel)]\n        \n        result = 0\n        if start == finish:\n            result = 1\n              \n        for i in range(len(locations)):\n            if i != start:\n                result = (result + self.helper(locations, i, finish, fuel - abs(locations[i] - locations[start]), memo)) % 1000000007                \n        memo[(start, fuel)] = result\n        return result", "from functools import lru_cache\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10 ** 9 + 7\n\n        @lru_cache(None)\n        def dfs(source, fuel):\n            if fuel < 0:\n                return 0\n\n            cnt = 0\n            if source == finish:\n                cnt += 1\n            for i, val in enumerate(locations):\n                if i != source:\n                    cnt += dfs(i, fuel - abs(locations[source] - val))\n            return cnt % mod\n        return dfs(start, fuel)", "class Solution:\n    def countRoutesHelper(self, locations, currentLocation, finish, fuel):\n        if fuel < 0:\n            return 0\n        else:\n            if (currentLocation, fuel) in self.dp:\n                return self.dp[(currentLocation, fuel)]\n            else:\n                res = 0\n                if currentLocation == finish:\n                    res += 1\n                for i in range(len(locations)):\n                    if i != currentLocation:\n                        res += self.countRoutesHelper(locations, i, finish, fuel - abs(locations[currentLocation] - locations[i]))\n                self.dp[(currentLocation, fuel)] = res % (10**9 + 7)\n                return res % (10**9 + 7)\n        \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.dp = {}\n        return self.countRoutesHelper(locations, start, finish, fuel) % (10**9 + 7)", "from typing import List\nfrom collections import deque\nclass Solution:\n    \n    # Brute Force\n#     def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n#         ans = 0\n        \n#         q = deque([(start, fuel)])\n        \n#         while q:\n#             curr, tel = q.popleft()\n#             if curr == finish:\n#                 ans+=1%(10**9 + 7   )\n\n#             for i in range(len(locations)):\n#                 if i!=curr and tel-abs(locations[i]-locations[curr])>=0:\n#                     q.append((i, tel-abs(locations[i]-locations[curr])))\n#         return ans\n        \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        \n        def aux(curr, tel):\n            if tel <0:\n                return 0\n            if (curr, tel) in dp:\n                return dp[(curr, tel)]\n            ans = 1 if curr == finish else 0\n            \n            for i in range(len(locations)):\n                if i!=curr:\n                    ans += aux(i, tel-abs(locations[i]-locations[curr])) % M\n            dp[(curr, tel)] = ans % M\n            return ans % M\n        M = 10**9 + 7\n        dp = dict()\n        return aux(start, fuel) % M", "from functools import lru_cache\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10**9 + 7\n        @lru_cache(None)\n        def dfs(state, remain):\n            if remain < 0: return 0\n            cnt = 0\n            if state == finish:\n                cnt += 1\n            for next_state, next_loc in enumerate(locations):\n                if next_state == state: continue\n                cnt += dfs(next_state, remain-abs(locations[state]-next_loc))\n            return cnt % mod\n        return dfs(start, fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = (10**9) + 7\n\n        dp = [[-1] * (len(locations) + 1)] * fuel\n\n        @lru_cache(None)\n        def routes(cur_city, fuel):\n            nonlocal locations, dp\n\n            if fuel < 0: return 0\n\n            # if dp[cur_city][fuel] != -1: return dp[cur_city][fuel]\n            \n            total = 0\n\n            if cur_city == finish: total += 1\n\n            for i, val in enumerate(locations):\n                if i != cur_city:\n                    total += routes(i, fuel - abs(locations[i] - locations[cur_city])) % MOD\n            \n            # dp[cur_city][fuel] = total % MOD\n            return total % MOD\n\n\n        return routes(start, fuel)\n", "class Solution:\n    def countRoutes(self, locations, start: int, finish: int, fuel: int) -> int:\n        @lru_cache(maxsize=None)\n        def rec(start,finish, fuel):\n            if fuel<0:\n                return 0\n            \n            if start == finish:\n                res = 1\n                for j in range(len(locations)):\n                    if j!=start:\n                        res+=rec(j,finish, fuel - abs(locations[start]- locations[j]))\n                return res\n\n            totalCounts = 0\n            for j in range(len(locations)):\n                if j != start :\n                    totalCounts+=rec(j,finish, fuel - abs(locations[start]- locations[j]))\n            return totalCounts\n\n        return rec(start,finish, fuel) % (10**9 + 7)\n    \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        memo = {}\n        def dfs(start, finish, fuel):\n            if fuel < 0:\n                return 0\n            if (start, finish, fuel) in memo:\n                return memo[(start, finish, fuel)]\n\n            routes = (1 if start == finish else 0)\n            for i, location  in enumerate(locations):\n                if i == start:\n                    continue\n\n                routes += dfs(i, finish, fuel - abs(locations[i] - locations[start]))\n\n            memo[(start, finish, fuel)] = routes\n            return routes\n        \n        return dfs(start, finish, fuel) % (10**9 + 7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        def back_track(ci, fuel, N, mem):\n            if (ci, fuel) in mem:\n                return mem[(ci, fuel)]\n            res = 0    \n            for i in range(N):\n                if i != ci:\n                    if fuel-abs(locations[ci]-locations[i]) >= 0:\n                        res += (1 if i == finish else 0) + back_track(i, fuel-abs(locations[ci]-locations[i]), N, mem) \n            mem[(ci, fuel)] = res\n            return mem[(ci, fuel)]\n        \n        return (back_track(start, fuel, len(locations), defaultdict()) + (1 if start == finish else 0))%(10**9+7)", "class Solution:\n    def countRoutesHelper(self, locations, currentLocation, finish, fuel):\n        if fuel < 0:\n            return 0\n        else:\n            if (currentLocation, fuel) in self.dp:\n                return self.dp[(currentLocation, fuel)]\n            else:\n                res = 0\n                if currentLocation == finish:\n                    res += 1\n                for i in range(len(locations)):\n                    if i != currentLocation:\n                        res += self.countRoutesHelper(locations, i, finish, fuel - abs(locations[currentLocation] - locations[i]))\n                self.dp[(currentLocation, fuel)] = res\n                return res\n        \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.dp = {}\n        return self.countRoutesHelper(locations, start, finish, fuel) % (10**9 + 7)", "class Solution:\n    #1575\n    def countRoutes(self, locations: 'List[int]', start: int, finish: int, fuel: int) -> int:\n        MOD = 1000000007\n        sp,ep = locations[start], locations[finish]\n        locations.sort()\n        s, e = locations.index(sp), locations.index(ep)\n        N = len(locations)\n        @functools.lru_cache(None)\n        def helper(i, f):\n            if i!=e and abs(locations[e]-locations[i]) <= f:\n                res = 1\n            else:\n                res = 0\n            j = i-1\n            while j>=0 and abs(locations[i]-locations[j])+abs(locations[e]-locations[j]) <= f:\n                res += helper(j, f-abs(locations[i]-locations[j]))\n                j -= 1\n            j = i + 1\n            while j<N and abs(locations[i]-locations[j])+abs(locations[e]-locations[j]) <= f:\n                res += helper(j, f-abs(locations[j]-locations[i]))\n                j += 1\n            return res%MOD\n        return helper(s,fuel) + (s==e)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        cost = lambda i,j: abs(locations[i]-locations[j])\n\n        @lru_cache(None)\n        def dfs(i, f):\n            if f < 0: return 0 \n            return sum([dfs(j, f-cost(i,j)) for j in range(len(locations)) if j != i]) + (i == finish)\n\n        return dfs(start, fuel) % (10**9+7)\n            \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        return self.helper(locations, start, finish, fuel, {})\n    \n    def helper(self, locations, start, finish, fuel, memo):\n        if fuel < 0:\n            return 0\n        \n        if (start, fuel) in memo:\n            return memo[(start, fuel)]\n        \n        result = 0\n        if start == finish:\n            result = 1\n              \n        for i in range(len(locations)):\n            if i != start:\n                result = (result + self.helper(locations, i, finish, fuel - abs(locations[i] - locations[start]), memo)) % 1000000007                \n        memo[(start, fuel)] = result\n        return result\n", "class Solution:\n    def countRoutes(self, locations: [int], start: int, finish: int, fuel: int) -> int:\n        d={}\n        \n        start=locations[start]\n        finish=locations[finish]\n        for x in locations:\n            d[x]=[0]*201\n        d[start][fuel]=1\n        ans=0\n        for fu in range(200,0,-1):\n            for loc in d:\n                #d[loc][fu]%=10**9+7\n                if d[loc][fu]!=0:\n                    for x in d:\n                        if x==loc:\n                            continue\n                        result=fu-abs(x-loc)\n                        if result>=0:\n                            d[x][result]+=d[loc][fu]\n                            d[x][result]%=10**9+7\n        \n        return sum(d[finish])%(10**9+7)\nprint(Solution().countRoutes([2,3,6,8,4],1,3,5))", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        m = collections.defaultdict(lambda: 0)\n        n = len(locations)\n        \n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                else:\n                    m[(i, j)] = abs(locations[i] - locations[j])\n        memo = {}\n        MOD = 10 ** 9 + 7   \n        def dfs(cur, target, fuel):\n            nonlocal n\n            if fuel < 0:\n                return 0\n            elif (cur, fuel) in memo:\n                return memo[(cur, fuel)]\n            else:\n                cnt = 1 if cur == target else 0\n                for i in range(n):\n                    if i != cur:\n                        cnt += dfs(i, target, fuel - m[(i, cur)]) \n                memo[(cur, fuel)] = cnt \n                return memo[(cur, fuel)]\n            \n        return dfs(start, finish, fuel) % MOD\n", "import numpy as np \n\nMOD = 10 ** 9 + 7\ncache = None\nlocations = None\n\ndef count(current, finish, fuel):\n    if cache[current, fuel] >= 0:\n        return cache[current, fuel]\n    \n    if abs(locations[current] - locations[finish]) > fuel:\n        cache[current, fuel] = 0\n        return 0\n    \n    routes = 1 if current == finish else 0\n    for i in range(0, len(locations)):\n        if i == current:\n            continue\n        \n        distance = abs(locations[current] - locations[i]) \n        remaining = fuel - distance\n        if remaining >= 0:\n            routes += count(i, finish, remaining)\n            \n    cache[current, fuel] = routes % MOD\n    return cache[current, fuel]\n\n    \nclass Solution:\n    def countRoutes(self, locs: List[int], start: int, finish: int, fuel: int) -> int:\n        nonlocal cache, locations\n        locations = locs\n        cache = np.full((len(locations), fuel + 1), -1)\n        return count(start, finish, fuel)\n", "import heapq as hq\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        start_loc = locations[start]\n        finish_loc = locations[finish]\n        locations = sorted(locations)\n        start = locations.index(start_loc)\n        finish = locations.index(finish_loc)\n\n        pushed = set([(fuel, start, 1), (start, fuel, -1)]) # fuel, start, direction, num\n        h = [(-fuel, start, 1), (-fuel, start, -1)]\n        routes = {(start, fuel, 1): 1, (start, fuel, -1): 1}\n        count = 0\n        if start == finish:\n            count = 1\n            \n        while len(h) > 0:\n            neg_fuel, st, di = hq.heappop(h)\n            ed = st + di\n            inc = routes[(st, -neg_fuel, di)]\n            while True:\n                if ed < 0 or ed > len(locations) - 1:\n                    break\n                new_fuel = - neg_fuel - abs(locations[ed] - locations[st])\n                if new_fuel < 0:\n                    break\n                if (new_fuel, ed, -di) not in pushed:\n                    pushed.add((new_fuel, ed, -di))\n                    routes[(ed, new_fuel, -di)] = inc\n                    hq.heappush(h, (-new_fuel, ed, -di))\n                else:\n                    routes[(ed, new_fuel, -di)] += inc\n                if ed == finish:\n                    count += inc #% 1000000007\n                ed += di\n                inc *= 2\n            #print(routes)\n        return count % 1000000007\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.memo = {}\n        return self.dfs(start, finish, fuel, locations) % (10**9 + 7)\n    \n    def dfs(self, curr_loc, finish, curr_fuel, locations):\n        if (curr_loc, curr_fuel) in self.memo:\n            return self.memo[(curr_loc, curr_fuel)]\n        if curr_fuel < 0:\n            return 0\n        \n        ways = 0 if curr_loc != finish else 1\n        \n        for i in range(len(locations)):\n            if i == curr_loc:\n                continue\n            ways += self.dfs(i, finish, curr_fuel - abs(locations[i] - locations[curr_loc]), locations)\n\n        self.memo[(curr_loc, curr_fuel)] = ways\n        return ways", "class Solution:\n    def countRoutes(self, A: list, start: int, finish: int, fuel: int) -> int:\n        n = len(A)\n        MOD = 10 ** 9 + 7\n\n        @functools.lru_cache(None)\n        def dp(i, k):\n            if k < 0:\n                return 0\n            ans = 1 if i == finish else 0\n            for j in range(n):\n                if i == j:\n                    continue\n                ans += dp(j, k - abs(A[i] - A[j]))\n            return ans % MOD\n\n        return dp(start, fuel)", "from functools import lru_cache\n\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10**9 + 7\n        \n        @lru_cache(None)\n        def td_solve(gas, s):\n            if gas < abs(locations[s] - locations[finish]):\n                return 0  # no way to get to target\n            \n            res = 1 if s == finish else 0\n            for city in range(len(locations)):\n                if city == s:\n                    continue\n                \n                res += td_solve(gas - abs(locations[city] - locations[s]),\n                                city)\n                res %= MOD\n                \n            return res\n        \n        return td_solve(fuel, start)", "class Solution:\n    \n    def helper(self, cur_loc, fuel):\n      \n        if fuel < 0:\n            return 0\n       \n        if (cur_loc, fuel) in self.mem:\n            return self.mem[(cur_loc, fuel)]\n        \n        ans = 0\n        if cur_loc == self.finish:\n            ans += 1\n        for nxt in range(len(self.locations)):\n            if nxt != cur_loc:\n                ans += self.helper(nxt, fuel - abs(self.locations[cur_loc] - self.locations[nxt]))\n        ans = ans % (10**9 +7)    \n        self.mem[(cur_loc, fuel)] = ans\n        return ans\n        \n        \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        self.finish = finish\n        self.locations = locations\n        self.mem = {}\n        ans = self.helper(start, fuel)\n        \n        return ans\n        \n        \nclass Solution1:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        \n        cost = lambda i, j: abs( locations[i] - locations[j] )\n        \n        # --------------------------------------\n        \n        @lru_cache(None)\n        def dfs(cur, remain_fuel):\n            \n            if remain_fuel < 0:\n                # base case aka stop condition\n                return 0\n            \n            # general case:\n            return sum( dfs(next_city, remain_fuel - cost(cur, next_city) )for next_city in range(len(locations) ) if cur != next_city ) + ( cur == finish )\n\n        # --------------------------------------\n        constant = ( 10 ** 9 + 7 )\n        return dfs(cur=start, remain_fuel=fuel) % constant", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        @lru_cache(None)\n        def dfs(l, f):\n            res = 1 if l == finish else 0\n            for i in range(n):\n                diff = abs(locations[i] - locations[l])\n                if i != l and diff <= f:\n                    res += dfs(i, f - diff)\n            \n            return res\n        \n        return dfs(start, fuel) % (10 ** 9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # dp[i][f] = # of ways to reach city i (from start) with fuel f left.\n        n = len(locations)\n        dp = [[0] * (fuel + 1) for _ in range(n)]\n        dp[start][fuel] = 1  # init\n\n        # State transition: dp[i][f] = sum{dp[j][f + d]} where d = abs(location[i]-location[j]), i != j\n        for f in range(fuel, 0, -1):\n            for i in range(0, n):\n                if dp[i][f] == 0:\n                    continue\n                for j in range(0, n):\n                    d = abs(locations[i] - locations[j])\n                    if i == j or d == 0 or d > f:\n                        continue\n                    dp[j][f - d] = (dp[j][f - d] + dp[i][f]) % 1_000_000_007\n\n        return sum(dp[finish]) % 1_000_000_007", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.memo = {}\n        self.mod = 10**9 + 7\n        return self.helper(start, finish, locations, fuel)\n    \n    def helper(self, curr, finish, locations, fuel):\n        if fuel < 0:\n            return 0\n        \n        if (curr, fuel) in self.memo:\n            return self.memo[(curr, fuel)]\n        \n        res = 1 if curr == finish else 0\n        \n        for next_i in range(len(locations)):\n            if next_i != curr:\n                update = abs(locations[next_i] - locations[curr])\n                res += self.helper(next_i, finish, locations, fuel-update)\n        \n        res = res % self.mod\n        self.memo[(curr, fuel)] = res \n        return res", "MOD=10**9+7\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        \n        self.finish=finish\n        self.locations=locations\n        mem={}\n        \n        res=self.dp(start,fuel,mem)\n        return res%MOD\n        \n        \n    def dp(self,st,fuel,mem):\n        \n        if (st,fuel) in mem:\n            return mem[(st,fuel)]\n        \n        \n        res=1 if st==self.finish else 0\n        \n        for mid in range(len(self.locations)):\n            \n            if mid==st:\n                continue\n                \n            if abs(self.locations[mid]-self.locations[st])>fuel:\n                continue\n                \n            res+=self.dp(mid,fuel-abs(self.locations[mid]-self.locations[st]),mem)\n        \n        mem[(st,fuel)]=res\n        \n        return res\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 1000000007\n        n = len(locations)\n        @functools.lru_cache(None)\n        def dfs(cur, target, tot):\n            #if cur == finish:\n            #    return 1\n            res = 0\n            for i in range(n):\n                if i == cur:\n                    if i == finish:\n                        res += 1\n                        \n                    continue\n                if tot + abs(locations[cur]-locations[i]) > fuel:\n                    continue\n                #if tot + abs(locations[cur]-locations[i]) <= fuel and i == finish:  \n                #    res += 1\n                else:\n                    res += dfs(i, target, tot+ abs(locations[cur]-locations[i]))\n                    res %= mod\n            return res\n        return dfs(start, finish, 0) \n                    \n            \n", "class Solution:\n    \n    def _help(self, locations, start, finish, fuel, dp):\n        if fuel < 0:\n            return 0\n        elif dp[fuel][start] is not None:\n            return dp[fuel][start]\n        \n        ni = 1 if start == finish else 0\n        for i, loc in enumerate(locations):\n            if i != start:\n                ni += self._help(locations, i, finish, fuel - abs(locations[i] - locations[start]), dp)\n        dp[fuel][start] = ni\n        return ni\n    \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        dp = [[None] * n for _ in range(fuel + 1)]\n        \n        self._help(locations, start, finish, fuel, dp)\n        return dp[-1][start] % 1000000007\n", "from functools import lru_cache\n\nclass Solution:\n    locations = list()\n    @lru_cache(None)\n    def helper(self, start, finish, fuel):\n        if(fuel < abs(self.locations[start]-self.locations[finish])):\n            return 0\n        res = 0\n        for i,v in enumerate(self.locations):\n            if(i != start):\n                res += self.helper(i, finish, fuel-abs(v-self.locations[start]))\n        # if(abs(self.locations[start]-self.locations[finish])<=fuel and finish != start):\n            # res += 1\n        if(start == finish):\n            res += 1\n        # print(start,finish,fuel,res)\n        return res  \n    def countRoutes(self, l, start, finish, fuel):\n        self.locations = l\n        return self.helper(start,finish,fuel) % 1000000007;", "class Solution:\n    def solve(self, curr_loc, fuel):\n        if fuel < 0:\n            return 0\n        if (curr_loc, fuel) in self.dp:\n            return self.dp[curr_loc, fuel]\n        ways = 0\n        if curr_loc == self.finish:\n            ways += 1\n        for i in range(len(self.locations)):\n            if i != curr_loc:\n                ways += self.solve(i, fuel - abs(self.locations[i]-self.locations[curr_loc]))\n        self.dp[curr_loc, fuel] = ways %  self.modz\n        return ways\n            \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.locations = locations\n        self.dp = {}\n        self.modz = pow(10,9) + 7\n        self.finish = finish\n        return self.solve(start, fuel) %  self.modz", "class Solution:\n    def countRoutes(self, a: List[int], s: int, e: int, fuel: int) -> int:\n        n = len(a)\n        mod = 10**9+7\n        memo = {}\n        \n        def dp(u, f):\n            if f < 0:\n                return 0\n            if (u, f) in memo:\n                return memo[u, f]\n            ans = 0\n            if u == e:\n                ans += 1\n            \n            for v in range(n):\n                if v != u:\n                    ans += dp(v, f-abs(a[u]-a[v]))\n                    ans %= mod\n            \n            memo[u, f] = ans\n            return ans\n        \n        return dp(s, fuel)", "class Solution:\n    def countRoutes(self, l: List[int], start: int, fin: int, fuel: int) -> int:        \n        a,b,i=l[start],l[fin],0\n        while i < len(l):\n            if abs(l[i]-a)+abs(l[i]-b)>fuel:\n                del l[i]\n            else:\n                i+=1\n        if not l:\n            return 0\n        n=len(l)\n        start,fin=l.index(a),l.index(b)\n        @lru_cache(None)\n        def dfs(i: int, f: int) -> int:\n            return 0 if f < 0 else (1  if i == fin else 0) + sum(0 if i == j else dfs(j, f - abs(l[j] - l[i])) for j in range(len(l)))\n        return dfs(start, fuel) % 1000000007\n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.memo = {}\n        \n        return self.dfs(start, finish, fuel, locations) % (10**9 + 7)\n    \n    def dfs(self, curr_location, finish, curr_fuel, locations):\n        if (curr_location, curr_fuel) in self.memo:\n            return self.memo[(curr_location, curr_fuel)]\n        if curr_fuel < 0:\n            return 0\n        \n        ways = 1 if curr_location == finish else 0\n        \n        for i in range(len(locations)):\n            if i == curr_location:\n                continue\n            ways += self.dfs(i, finish, curr_fuel - abs(locations[curr_location]-locations[i]), locations)\n        \n        self.memo[(curr_location, curr_fuel)] = ways\n        \n        return ways\n", "class Solution:\n    def countRoutes(self, locations, start: int, finish: int, fuel: int) -> int:\n        KMAX = 10 ** 9 + 7\n        N = len(locations)\n        mem = dict()\n        \n        def dp(city, gas):\n            if (city, gas) in mem:\n                return mem[city, gas]\n            if gas < 0:\n                return 0\n            mem[city, gas] = 1 if city == finish else 0\n            for i in range(N):\n                if i == city or abs(locations[i] - locations[city]) > gas:\n                    continue\n                mem[city, gas] += dp(i, gas - abs(locations[i] - locations[city]))\n            return mem[city, gas]\n        res = dp(start, fuel) % KMAX\n        return res", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n                \n        @functools.lru_cache(None)\n        def get(start=start, fuel=fuel) :\n            if fuel < abs(locations[start]-locations[finish]) :\n                return 0\n            \n            to_ret = 1 if start == finish else 0\n            for p in range(len(locations)) :\n                if p == start :\n                    continue\n                to_ret += get(p, fuel=max(0, fuel-abs(locations[start]-locations[p])))\n            return to_ret % (10**9+7)\n    \n        return get()", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        cost = lambda i,j: abs(locations[i]-locations[j])\n        @lru_cache(None)\n        def dfs(i, f):\n            if f<0: return 0 \n            return sum([dfs(j,f-cost(i,j)) for j in range(len(locations)) if j != i]) + (i==finish)\n        return dfs(start, fuel) % (10**9+7)\n# class Solution:\n#     def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n#         self.sol = [[-1]*(fuel+1)]*len(locations)\n#         self.dfs(start, fuel, locations, finish, 0)\n#         print(self.sol)\n    \n#     def dfs(self, current, fuel, locations, end, local_ans):\n#         print(self.sol)\n#         if fuel<0:\n#             return 0\n#         if self.sol[current][fuel]==-1:\n#             ans = 1 if current==end else 0\n#             for index, i in enumerate(locations):\n#                 if index==current:\n#                     continue\n#                 cost = abs(locations[current]-i)\n#                 a = self.dfs(index, fuel-cost, locations, end, local_ans)\n#                 ans = ans + a\n#             print(ans)\n#             self.sol[current][fuel] = ans\n#         return self.sol[current][fuel]\n\n\n    \n    \n# private long solve(int[] locations, int curCity, int e, long[][] dp, int fuel) {\n#         // 4. There is no further way left.\n#         if (fuel < 0) return 0;\n#         if (dp[curCity][fuel] != -1) return dp[curCity][fuel];\n#         // 3. Now, if we have atleast 1 way of reaching `end`, add 1 to the answer. But don't stop right here, keep going, there might be more ways :)\n#         long ans = (curCity == e) ? 1 : 0;\n#         for (int nextCity = 0; nextCity < locations.length; ++nextCity) {\n#             // 1. Visit all cities except `curCity`.\n#             if (nextCity != curCity) {\n#                 // 2. Continue this process recursively.\n#                 ans = (ans + solve(locations, nextCity, e, dp, fuel - Math.abs(locations[curCity] - locations[nextCity]))) % 1000000007;\n#             }\n#         }\n#         return dp[curCity][fuel] = ans;\n#     }\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10 ** 9 + 7\n        @functools.lru_cache(None)\n        def drive(i, fuel):\n            res = 0\n            if i == finish:\n                res += 1\n            for j in range(len(locations)):\n                if i == j:\n                    continue\n                dist = abs(locations[i] - locations[j])\n                if dist <= fuel:\n                    res += drive(j, fuel - dist) % mod\n            return res % mod\n        return drive(start, fuel)\n            \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = {}\n        n = len(locations)\n        mod = 10**9 + 7\n        def rec(start,end,fuel,n):\n            res = 0\n            if fuel < 0:\n                return res\n            if (start,end,fuel) in dp:\n                return dp[(start,end,fuel)]\n            if start == end:\n                res += 1\n            for i in range(n):\n                if i == start:\n                    continue\n                res += rec(i,end,fuel-abs(locations[i]-locations[start]),n)\n            dp[(start,end,fuel)] = res\n            return res\n        return rec(start,finish,fuel,n) % mod", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        memo = {}\n        \n        def dp(ind, rem_fuel):\n            if (ind, rem_fuel) in memo:\n                return memo[(ind, rem_fuel)]\n            num_ways = 0\n            for city in range(len(locations)):\n                used = abs(locations[ind] - locations[city])\n                if used <= rem_fuel and city != ind:\n                    num_ways += dp(city, rem_fuel-used)\n                    if city == finish:\n                        num_ways += 1\n            memo[(ind, rem_fuel)] = num_ways\n            return memo[(ind, rem_fuel)]\n        \n        res = dp(start, fuel)\n        if start == finish:\n            res += 1\n        return res%(10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        count = 0\n        mod = 10**9+7\n        n = len(locations)\n        s_l = locations[start]\n        f_l = locations[finish]\n        locations.sort()\n        start = locations.index(s_l) \n        finish = locations.index(f_l)\n        \n        import functools\n        @functools.lru_cache(None)\n        def DFS(cur_city,cur_fuel):\n            if cur_fuel < abs(locations[cur_city]-locations[finish]):\n                return 0\n            if cur_city == finish:\n                c = 1\n            else:\n                c = 0\n            i = bisect.bisect_left(locations,locations[cur_city]-cur_fuel)\n            j = min(n-1,bisect.bisect_left(locations,locations[cur_city]+cur_fuel))\n            for nxt in range(i,cur_city):\n                c += DFS(nxt,cur_fuel - abs(locations[cur_city]-locations[nxt]))\n            for nxt in range(cur_city+1,j+1):\n                c += DFS(nxt,cur_fuel - abs(locations[cur_city]-locations[nxt]))\n            return c % mod\n        \n        return DFS(start,fuel) % mod\n                    \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        # locations[start], locations[0] = locations[0], locations[start]\n        # locations[finish], locations[n-1] = locations[n-1], locations[finish]\n        # start = 0\n        # finish = n - 1\n        MOD = 10**9+7\n        \n        # print(locations)\n        \n        @lru_cache(None)\n        def dp(f, fuel):\n            if fuel < 0:\n                return 0\n            \n            ans = 0\n            if f == finish:\n                ans = 1\n            \n            for t in range(0, n):\n                if t != f:\n                    ans += dp(t, fuel - abs(locations[f] - locations[t]))\n                    ans %= MOD\n            return ans\n        \n        return dp(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        store = {}\n        def get(now, fuel):\n            name = f\\\"{now}_{fuel}\\\"\n            if name in store:\n                return store[name]\n            res = 0\n            if now == finish:\n                res += 1\n            if fuel == 0:\n                return res\n            for i, j in enumerate(locations):\n                if i == now:\n                    continue\n                if fuel >= abs(locations[i] - locations[now]):\n                    res += get(i, fuel - abs(j - locations[now]))\n            store[name] = res % 1000000007\n            return store[name]\n        return get(start, fuel)", "from functools import lru_cache\n\nclass Solution:\n    locations = list()\n    @lru_cache(None)\n    def helper(self, start, finish, fuel):\n        if(fuel < abs(self.locations[start]-self.locations[finish])):\n            return 0\n        res = 0\n        for i,v in enumerate(self.locations):\n            if(i != start):\n                res += self.helper(i, finish, fuel-abs(v-self.locations[start]))\n        if(start == finish):\n            res += 1\n        return res  \n    def countRoutes(self, l, start, finish, fuel):\n        self.locations = l\n        return self.helper(start,finish,fuel) % 1000000007;", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        locationsLen, modulus = len(locations), 10 ** 9 + 7\n        dp = [[-1] * (fuel + 1) for _ in range(locationsLen)]\n        \n        def dfs(city, fuel):\n            if fuel < 0:\n                return 0\n            if dp[city][fuel] != -1:\n                return dp[city][fuel]\n            result = 0\n            if city == finish:\n                result = 1\n            for i in range(locationsLen):\n                if i != city and fuel - abs(locations[i] - locations[city]) >= 0:\n                    result += dfs(i, fuel - abs(locations[i] - locations[city])) % modulus\n            dp[city][fuel] = result\n            return result\n            \n        return dfs(start, fuel) % modulus", "from functools import lru_cache\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10**9 + 7\n        @lru_cache(maxsize = None)\n        def dfs(i, fuel):\n            total = 1 if i == finish else 0\n            if fuel < 0:\n                return 0\n            for j in range(len(locations)):\n                if j != i:\n                    leftFuel = fuel- abs(locations[i] - locations[j])\n                    total += dfs(j, leftFuel)\n                    total = total % mod\n            return total\n        return dfs(start, fuel)", "from functools import lru_cache\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10**9 + 7\n        @lru_cache(maxsize = None)\n        def dfs(i, fuel):\n            total = 1 if i == finish else 0\n            if fuel < 0:\n                return 0\n            for j in range(len(locations)):\n                if j != i:\n                    newFuel = fuel - abs(locations[i] - locations[j])\n                    total += dfs(j, newFuel)\n                    total = total % mod\n            return total\n        return dfs(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        @lru_cache(None)\n        def dfs(l, f):\n            return sum(dfs(i, f - abs(locations[i] - locations[l])) for i in range(n) if i != l \\\\\n                      and abs(locations[i] - locations[l]) <= f) + (1 if l == finish else 0)\n        \n        return dfs(start, fuel) % (10 ** 9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        def dp(i, f, memo):\n            if i == finish and f == 0:\n                return 1\n            if (i, f) not in memo:\n                ans = int(i == finish)\n                for j in range(len(locations)):\n                    d = abs(locations[j] - locations[i])\n                    if i != j and f >= d:\n                        ans += dp(j, f - d, memo)\n                        ans %= MOD\n                memo[(i, f)] = ans\n            return memo[(i, f)]\n        return dp(start, fuel, {})", "import sys\nsys.setrecursionlimit(1000)\n\nclass Solution:\n    def rec(self, p, f):\n        if f<0:\n            return 0\n        \n        if self.memo[p][f]!=-1:\n            return self.memo[p][f]\n    \n        res = 1 if p==self.start else 0\n        \n        for i in range(len(self.locations)):\n            if i==p:\n                continue\n            \n            res += self.rec(i, f-abs(self.locations[p]-self.locations[i]))\n            res %= self.MOD\n        \n        self.memo[p][f] = res\n        return res\n        \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.locations = locations\n        self.start = start\n        self.memo = [[-1]*(fuel+1) for _ in range(len(locations))]\n        self.MOD = 10**9+7\n        return self.rec(finish, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10**9+7\n        \n        @lru_cache(None)\n        def count(n):\n            if n == 0:\n                return 1\n            ans = 0\n            for i in range(1, n+1):\n                ans += count(n-i)\n            return ans\n        \n        # print(count(0), count(1), count(2), count(3))\n        \n        dct = defaultdict(int)\n        \n        for i, l in enumerate(locations):\n            dct[l] = i\n        \n        start_location, end_location = locations[start], locations[finish]\n        # locations.sort()\n        start_idx, end_idx = dct[start_location], dct[end_location]\n        \n        @lru_cache(None)\n        def dfs(idx, fuel):\n            # print(idx, fuel)\n            ans = 0\n            if idx == end_idx:\n                ans += 1\n            for i, l in enumerate(locations):\n                if i != idx and abs(l - locations[idx]) <= fuel:\n                    ans += dfs(i, fuel-abs(l - locations[idx]))\n            return ans%mod\n        \n        return dfs(start_idx, fuel)\n                \n            \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        mem = {}\n        \n        def get_val(point, fuel):\n            nonlocal finish\n            value = mem.get((point, fuel), None)\n            if value!=None:\n                return value\n            mem[(point, fuel)] = 0\n            if point==finish:\n                mem[(point, fuel)] = 1\n\n            for i in range(len(locations)):\n                if i!=point:\n                    if fuel-abs(locations[i]-locations[point])>=0:\n                        mem[(point, fuel)]+=get_val(i, fuel-abs(locations[i]-locations[point]))\n                        \n                            \n            return mem[(point, fuel)]\n        \n        v = get_val(start, fuel)\n        #print(mem)\n        return v%(10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        memo = [[-1]*(fuel+1) for i in range(n)]\n        mod = 10**9 + 7\n        def dp(curr, fuel):\n            if fuel < 0:\n                return 0\n            \n            if memo[curr][fuel] != -1:\n                return memo[curr][fuel]\n            \n            memo[curr][fuel] = 1 if curr == finish else 0\n            \n            for i, city in enumerate(locations):\n                if i != curr:\n                    memo[curr][fuel] += dp(i, fuel - abs(city - locations[curr]))\n                    memo[curr][fuel] %= mod\n\n            return memo[curr][fuel]\n        \n        return dp(start,fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        a = locations\n        n = len(a)\n        MOD = 10**9 + 7\n        \n        @lru_cache(maxsize=None)\n        def dp(pos, fuel) :\n            res = 0\n            if pos == finish :\n                #print(pos, fuel, 1)\n                res = 1\n            for k in range(n) :\n                dist = abs(a[pos] - a[k])\n                if dist > 0 and dist <= fuel :\n                    res = (res + dp(k, fuel - dist)) % MOD\n            #print(pos, fuel, res)\n            return res\n        \n        return dp(start, fuel)", "# 1575. Count All Possible Routes\n\nMOD = 10**9 + 7\n\ndef gen_matrix (m, n, elem):\n    return [[elem for col in range (n)] for row in range (m)]\n\ndef count_routes (cities, start, finish, fuel):\n    m_routes = gen_matrix (fuel + 1, len (cities), None)\n\n    def dist (c1, c2):\n        return abs (cities[c1] - cities[c2])\n\n    def routes (f, c):\n        '''Number of routes *to reach* finish with fuel f\n        starting from city c'''\n\n        if f < 0:\n            return 0\n\n        if m_routes[f][c] is not None:\n            return m_routes[f][c]\n\n        if f == 0 and c != finish:\n            # cannot reach city now\n            ans = 0\n        else:\n            current_sol = bool (c == finish)\n            ans = current_sol + sum (routes (f - dist (c, c2), c2) for c2 in range (len (cities)) if c2 != c)\n            ans %= MOD\n        \n        m_routes[f][c] = ans\n        return ans\n\n    return routes (fuel, start)\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        return count_routes(locations, start, finish, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = {}\n        M = 10 ** 9 + 7\n        def go(now, f):\n            if (now, f) in dp:\n                return dp[(now, f)]\n            if f < 0:\n                return 0\n            dp[(now, f)] = 1 if now == finish else 0\n            for i, v in enumerate(locations):\n                if i != now and f - abs(locations[now] - v) >= 0:\n                    dp[(now, f)] += go(i, f - abs(locations[now] - v))\n            dp[(now, f)] %= M\n            return dp[(now, f)]\n        return go(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def routes(start, fuel):\n            if fuel<0:\n                return 0\n            answer=0\n            #print('start:'+str(start)+', fuel:'+str(fuel)+', answer: '+str(answer))\n            if start==finish:\n                answer+=1\n            for i in range(len(locations)):\n                if i==start:\n                    continue\n                answer+=routes(i, fuel-abs(locations[i]-locations[start]))\n            #print('start:'+str(start)+', fuel:'+str(fuel)+', answer: '+str(answer))\n            return answer\n        return routes(start, fuel)%1000000007", "from functools import lru_cache\n\nclass Solution:\n  @lru_cache(None)\n  def recursive(self, i, f):\n    ans = 0\n    if i == self.t:\n      ans += 1\n    if f > 0:\n      j = i + 1\n      while j < self.n and (self.L[j] - self.L[i]) + self.m[j] <= f:\n        ans += self.recursive(j, f - (self.L[j] - self.L[i]))\n        j += 1\n      j = i - 1\n      while j > -1 and (self.L[i] - self.L[j]) + self.m[j] <= f:\n        ans += self.recursive(j, f - (self.L[i] - self.L[j]))\n        j -= 1\n    return ans\n  def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n    self.n = len(locations)\n    # sx, tx: start and finish city coordinates\n    sx, tx = locations[start], locations[finish]\n    # self.L: sorted city coordinates\n    self.L = sorted(locations)\n    # self.d: city coordinates -> sorted index\n    self.d = {x: i for i, x in enumerate(self.L)}\n    # self.s, self.t: start/finish city in sorted index\n    self.s, self.t = self.d[sx], self.d[tx]\n    # minimum fuel required on each city to reach finish\n    self.m = {i: abs(x - tx) for i, x in enumerate(self.L)}\n    # memo\n    self.recursive.cache_clear()\n    return self.recursive(self.s, fuel) % (10 ** 9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        self.ans = 0\n        @lru_cache(None)\n        def back(curr, fuel):\n            aux = 0\n            if curr ==finish:\n                aux+=1\n            for i in range(n):\n                if i!=curr:\n                    if fuel-abs(locations[curr]-locations[i])>=0:\n                        aux+=back(i, fuel-abs(locations[curr]-locations[i]))\n            return aux\n        return back(start, fuel)%(10**9+7)\n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        dist = [[abs(locations[i]-locations[j]) for j in range(n)] for i in range(n)]\n        min_d = [min(dist[i][j] for j in range(n) if j!=i) for i in range(n)]\n        memo = {}\n        def dp(begin, left):\n            if left<min_d[begin]:\n                return 1 if begin==finish else 0\n            if (begin,left) in memo:\n                return memo[(begin,left)]\n            memo[(begin,left)] = sum(dp(i,left-dist[begin][i]) for i in range(n) if i!=begin and left>=dist[begin][i])\n            if begin==finish:\n                memo[(begin,left)] += 1\n            return memo[(begin,left)]\n        return dp(start,fuel)%(10**9+7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        def recurse(index, fuel, finish):\n            \n            paths = 0\n            if fuel < 0: return 0\n            \n            if index == finish:\n                paths += 1\n                # return paths\n            \n            if dp[index][fuel] != -1:\n                return dp[index][fuel]\n                \n            for i in range(len(locations)):\n                if i == index: continue\n                paths += recurse(i, fuel - abs(locations[i] - locations[index]), finish) \n            dp[index][fuel] = paths % (pow(10, 9) + 7)\n            return paths\n            \n        \n        dp = [[-1 for i in range(fuel + 1)] for j in range(len(locations))]\n        totalpaths = recurse(start, fuel, finish) % (pow(10, 9) + 7)\n        return totalpaths\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dp(i, f):\n            if i == finish:\n                res = 1\n            else:\n                res = 0\n            for j in range(len(locations)):\n                if j != i and abs(locations[i] - locations[j]) <= f:\n                    res += dp(j, f - abs(locations[i] - locations[j]))\n            return res\n        return dp(start, fuel) % (10 ** 9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp={}\n        def dfs(s,f,fuel):\n            if fuel<0:\n                return 0\n            # print(s,f,fuel)\n            ans=0\n            if((s,f,fuel) in dp):\n                return dp[(s,f,fuel)]\n            if s==finish:\n                ans+=1\n            for i in range(len(locations)):\n                if i!=s:\n                    ans+=dfs(i,f,fuel-abs(locations[i]-locations[s]))\n            ans=ans%(10**9+7)\n            dp[(s,f,fuel)]=ans\n            return ans\n        return dfs(start,finish,fuel)\n            \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        q = [(start,fuel)]\n        res = 0\n        if start == finish:\n            res += 1\n        next_q = []\n        \n        @lru_cache(None)\n        def dp(cur_start, fuel):\n            # if cur_start == finish:\n            #     return 0\n            \n            res = 0\n            for l in range(len(locations)):\n                left_fuel = fuel - abs(locations[l]-locations[cur_start])\n                if l != cur_start and left_fuel >= 0:\n                    if l == finish:\n                        res += 1\n                    if left_fuel > 0:\n                        res += dp(l, left_fuel)\n            return res\n        res += dp(start, fuel)  \n        return res % (10**9 +7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.memo = {}             \n        \n        return self.dfs(start, fuel, finish, locations) % (10**9 + 7)\n    \n    def dfs(self, location, fuel, finish, locations):\n        if (location, fuel) in self.memo:\n            return self.memo[(location, fuel)]\n        if fuel < 0:\n            return 0\n        \n        ways = 0 if location != finish else 1\n        \n        for i in range(len(locations)):\n            if i == location:\n                continue\n            ways += self.dfs(i, fuel-abs(locations[i]-locations[location]), finish, locations)\n        self.memo[(location, fuel)] = ways\n        return ways\n", "class Solution:\n    def countRoutes(self, loct: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(loct)\n        def getf(s,e):\n            return abs(loct[s] - loct[e])\n        visited = set()\n        @functools.lru_cache(None)\n        def dfs(start, f): \n            if f < 0:\n                return 0\n            return sum([dfs(i, f - getf(start, i)) for i in range(n) if i != start]) + (1 if start == finish else 0)\n        return dfs(start, fuel) % (10 **9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10 ** 9 + 7\n        \n        def dp(cur, fuel):\n            if fuel < 0:\n                return 0\n            \n            if (cur, fuel) in memo:\n                return memo[(cur, fuel)]\n            \n            ans = 0\n            \n            if cur == locations[finish]:\n                ans = 1\n          \n            for loc in locations:\n                if loc != cur:\n                    ans += dp(loc, fuel - abs(cur-loc))\n            \n            memo[(cur, fuel)] = ans \n            \n            return ans\n    \n        memo = {}\n        \n        return dp(locations[start], fuel) % mod\n", "class Solution:\n    # find location >= target\n    def search(self, locations: List[int], left: int, right: int, target: int):\n        while left <= right:\n            mid = (left + right) // 2\n            if locations[mid] < target:\n                left = mid + 1\n            elif left == right:\n                break\n            else:\n                right = mid\n        return left\n\n        \n    def dfs(self, locations: List[int], start: int, finish: int, fuel: int, memo: List[Dict[int, int]]):\n        if fuel in memo[start]:\n            return memo[start][fuel]\n        if fuel < abs(locations[start] - locations[finish]):\n            return 0\n        res = 1 if start == finish else 0\n        left = self.search(locations, 0, start, locations[start] - fuel)\n        right = self.search(locations, start, len(locations) - 1, locations[start] + fuel + 1)\n        # print(start, fuel, left, right)\n        for next in range(left, right):\n            if next == start: continue\n            res += self.dfs(locations, next, finish, fuel - abs(locations[start] - locations[next]), memo)\n        memo[start][fuel] = res % 1000000007\n        return memo[start][fuel]\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        startLoc = locations[start]\n        finishLoc = locations[finish]\n        locations.sort()\n        start = self.search(locations, 0, len(locations) - 1, startLoc)\n        finish = self.search(locations, 0, len(locations) - 1, finishLoc)\n        print((locations, start, finish))\n        return self.dfs(locations, start, finish, fuel, [{} for i in range(len(locations))])\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[-1 for _ in range(fuel+1)] for _ in locations]\n        def search(start, fuel):\n            if fuel == 0:\n                if start == finish:\n                    return 1\n                return 0\n            if dp[start][fuel] != -1:\n                return dp[start][fuel]\n            dp[start][fuel] = 1 if start == finish else 0\n            for i in range(len(locations)):\n                left = fuel - abs(locations[i] - locations[start])\n                if i != start and left >= 0:\n                    \n                    dp[start][fuel] += dp[i][left] % 1000000007 if dp[i][left] > 0 else search(i, left) \n            return dp[start][fuel] % 1000000007\n        search(start, fuel)\n        return dp[start][fuel] % 1000000007", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        startFuel = fuel\n        memo = [ [ -1 for f in range(fuel+1) ] for l in range(len(locations)) ]\n        \n        def recurse(start, fuel, memo):\n            \n            # Base case: Not enough fuel to get to the destination\n            numRoutes = 0\n            if fuel >= 0:\n                \n                # Memoization: We've seen this problem before\n                if memo[start][fuel] != -1:\n                    \n                    numRoutes = memo[start][fuel]\n                    \n                else:\n                    \n                    # Test: If we have reached the finish, we have completed a valid route... but we still want to continue on if we have more fuel :P\n                    if start == finish:\n                        numRoutes += 1\n                    \n                    # Recurse: Try to move to all other cities\n                    for nextCity in range(0, len(locations)):\n                        if nextCity != start:\n                            numRoutes += recurse(nextCity, fuel - abs(locations[nextCity] - locations[start]), memo)\n                    \n                    # Memoize: Save off the result of our computation\n                    memo[start][fuel] = numRoutes\n            \n            # Return the number of routes that get us from start to finsh with the given amount of fuel\n            return numRoutes\n        \n        \n        return recurse(start, fuel, memo) % ((10**9)+7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        cache = {}\n        \n        def dfs(start, fuel):\n            # Number of routes from start to finish using less or equal than fuel\n            if (start, fuel) not in cache:\n                res = 0\n                for c in range(len(locations)):\n                    if c == start: \n                        continue\n                    dist = abs(locations[start] - locations[c])\n                    if c == finish and dist <= fuel:\n                        res += 1    \n                    if dist <= fuel:\n                        res += dfs(c, fuel - dist)\n                cache[(start, fuel)] = res % (10**9+7)\n            \n            return cache[(start, fuel)]\n        \n        return dfs(start, fuel) + int(start == finish)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        \n        @functools.lru_cache(None)\n        def run(c, f):\n            res = 0\n            if c == finish:\n                res += 1\n            if f > 0:\n                for i in range(len(locations)):\n                    if i != c and abs(locations[c]-locations[i]) <= f:\n                        res += run(i, f - abs(locations[c]-locations[i])) % MOD\n            return res % MOD\n        \n        return run(start, fuel)\n                    \n", "# O(f ^ 2 * n ^ 2), f is fuel, n is number of cities\nfrom functools import lru_cache\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        @lru_cache(None)\n        def ways(left, city):\n            # it's not possible that we have more than initial fuel\n            if left > fuel: return 0\n            if city == locations[start] and left == fuel: return 1\n            return sum(ways(abs(city - city_) + left, city_) for city_ in locations if city != city_) % MOD\n            \n        return sum(ways(left, locations[finish]) for left in range(fuel + 1)) % MOD\n        # AC: 4388 ms, beats 23.53%, 47.6 MB, beats 5.14%\n                \n                    \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = {}\n        self.mode = (int)(1e9) + 7\n        return self.dfs(fuel, start, finish, locations, dp)\n    \n    def dfs(self, fuel, u, target, locations, dp):\n        if fuel < 0:\n            return 0\n        \n        if (fuel, u, target) in dp:\n            return dp[(fuel, u, target)]\n        ans =  1 if u == target else 0\n        for v in range(len(locations)):\n            if u == v:\n                continue\n            ans += self.dfs(fuel - abs(locations[u] - locations[v]), v, target, locations, dp)\n            ans %= self.mode\n        dp[(fuel, u, target)] = ans\n        return ans", "class Solution:\n    \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n\n        \n        @functools.lru_cache(maxsize=None)\n        def helper(L, i, j, fuel):\n            output = 0\n            if fuel < 0:\n                return output            \n            if i == j and fuel >= 0:\n                output = 1\n                \n            if fuel > 0:\n                for k in range(len(locations)):\n                    if i == k:\n                        continue\n                    output += helper(L, k, j, fuel-abs(locations[i]-locations[k]))\n            return output\n\n        \n        return (helper(tuple(locations), start, finish, fuel))%(10**9+7)\n                \n            \n            \n            \n        \n            \n", "# O(f ^ 2 * n ^ 2), f is fuel, n is number of cities\nfrom functools import lru_cache\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        @lru_cache(None)\n        def ways(left, city):\n            # it's not possible that we have more than initial fuel\n            if left > fuel: return 0\n            if city == locations[start] and left == fuel: return 1\n            return sum(ways(abs(city - city_) + left, city_) for city_ in locations if city != city_) % MOD\n            \n        # AC: ms, beats, MB, beats\n        return sum(ways(left, locations[finish]) for left in range(fuel + 1)) % MOD\n                \n                    \n", "class Solution:\n    MODULO = 10**9+7\n    \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        my_dp = dict()\n        return Solution.get_dp(my_dp, locations, start, finish, fuel)\n    \n    \n    @staticmethod\n    def get_dp(dp, locations, start, finish, fuel):\n        if (start, finish, fuel) not in dp:\n            total_ways = 0\n            \n            if start == finish:\n                total_ways = 1\n            \n            for idx, pos in enumerate(locations):\n                if idx != start and abs(locations[start]-locations[idx]) <= fuel:\n                    total_ways = (total_ways + Solution.get_dp(dp, locations, idx, finish,\n                                                               fuel - abs(locations[start]-locations[idx]))) % Solution.MODULO\n            dp[(start, finish, fuel)] = total_ways\n                \n        \n        return dp[(start, finish, fuel)]", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.locations = locations\n        self.nr = [[0] * (fuel + 1) for _ in locations]\n        self.evaluated = [[False] * (fuel + 1) for _ in locations]\n        for i in range(len(locations) - 1):\n            self.nr[i][0] = 0\n            self.evaluated[i][0] = True\n        for i in range(fuel + 1):\n            self.nr[finish][i] = 1\n        self.evaluated[finish][0] = True\n        x = self.num_routes(start, finish, fuel)\n        return x\n        \n    def num_routes(self, current_city, end, current_fuel):\n        # add num_routes for (places, fuel) states that can be travelled to with current fuel.\n        # print('Start eval:', current_city, current_fuel)\n        if self.evaluated[current_city][current_fuel]:\n            # print('Applied old eval:', current_city, current_fuel, self.nr[current_city][current_fuel])\n            return self.nr[current_city][current_fuel]\n        cur_nr = self.nr[current_city][current_fuel]\n        for target_city in range(len(self.locations)):\n            if target_city == current_city:\n                continue\n            remaining_fuel = current_fuel - max(self.locations[current_city] - self.locations[target_city], self.locations[target_city] - self.locations[current_city])\n            if remaining_fuel >= 0:\n                cur_nr += self.num_routes(target_city, end, remaining_fuel)\n        \n        cur_nr = cur_nr % (10**9 + 7)\n        self.nr[current_city][current_fuel] = cur_nr\n        self.evaluated[current_city][current_fuel] = True\n        # print(location, current_fuel, cur_nr)\n        # print('Fin eval:', current_city, current_fuel, cur_nr)\n        return cur_nr", "sys.setrecursionlimit(1000000)\n\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n\n        @lru_cache(None)\n        def dfs(u, fuel):\n            res = 1 if u == finish else 0\n            du = locations[u]\n            for v, dv in enumerate(locations):\n                if v != u:\n                    cost = abs(dv - du)\n                    if cost <= fuel:\n                        res += dfs(v, fuel - cost)\n            return res % MOD\n\n        return dfs(start, fuel)", "MOD = 10**9 + 7\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        m = len(locations)\n        n = fuel+1\n        mem = [[None for i in range(n)] for j in range(m)]\n        \n        return self.backtrack(start, locations, finish, fuel, mem)\n        \n    def backtrack(self, cur, locations, finish, fuel, mem):\n        if fuel < 0:\n            return 0\n        elif mem[cur][fuel] != None:\n            return mem[cur][fuel]\n        \n        count = 0\n        if cur == finish:\n            count += 1\n        \n        for i, pos in enumerate(locations):\n            dist = abs(pos-locations[cur])\n            if i == cur or dist > fuel:\n                continue\n            \n            count += self.backtrack(i, locations, finish, fuel-dist, mem)\n            \n        mem[cur][fuel] = count % MOD\n        return mem[cur][fuel]\n                \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.memo = {}\n        return self.dfs(start, fuel, finish, locations) % (10 ** 9 + 7)\n        \n    def dfs(self, cur, fuel, target, location):\n        if cur == target:\n            result = 1\n        else:\n            result = 0\n        if (cur, fuel) in self.memo:\n            return self.memo[(cur, fuel)]\n        for i in range(len(location)):\n            if cur != i and abs(location[i] - location[cur]) <= fuel:\n                result += self.dfs(i, fuel - abs(location[i] - location[cur]), target, location)\n        self.memo[(cur, fuel)] = result\n        return result ", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        \n        def dp(curr_loc, fuel):\n            \n            if (curr_loc, fuel) in memo:\n                return memo[(curr_loc, fuel)]\n            \n            if fuel < 0:\n                return 0\n            \n            ans = 0\n            \n            if curr_loc ==  finish:\n                ans = 1\n        \n            for i, loc in enumerate(locations):\n                \n                if i != curr_loc:\n                    ans += dp(i, fuel - abs(locations[curr_loc] - loc))\n                    \n            memo[(curr_loc, fuel)] = ans\n            \n            return ans\n            \n        memo = {}\n        \n        return dp(start,fuel) % (10**9+7)", "MOD = 10**9+7\n\nclass Solution:\n    def countRoutes(self, locations, start, finish, fuel):\n        dp = [[0 for _ in locations] for _ in range(fuel+1)]\n        dp[0][start] = 1\n        \n        for f in range(fuel+1):\n            for i,x in enumerate(locations):\n                if abs(x - locations[finish]) > fuel - f:\n                    continue\n                for j,y in enumerate(locations):\n                    if i == j:\n                        continue\n                    new = f + abs(x-y)\n                    if new > fuel:\n                        continue\n                    dp[new][j] = dp[new][j] + dp[f][i]\n\n        return sum(row[finish] for row in dp) % MOD", "MAX = int(10 ** 9 + 7)\n\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        A = [[None for _ in range(fuel + 1)] for _ in range(len(locations))]\n\n        A[start][fuel] = 1\n\n        for f in range(fuel, 0, -1):\n            for ca in range(len(locations) - 1, -1, -1):\n                if A[ca][f] is None:\n                    continue\n\n                for cb in range(len(locations) - 1, -1, -1):\n                    if cb == ca:\n                        continue\n                    loss = int(abs(locations[ca] - locations[cb]))\n                    if loss > f:\n                        continue\n\n                    A[cb][f - loss] = ((A[cb][f - loss] or 0) + A[ca][f]) % MAX\n\n        r = 0\n        for x in A[finish]:\n            if x is None:\n                continue\n            r = (r + x) % MAX\n\n        return r", "class Solution:\n    def countRoutes(self, locations, start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        dp = [[-1] * (len(locations) + 1 )for _ in range(fuel + 1)]\n        \n        def recur(st, ed, f):\n            if f < 0: return 0\n            if dp[f][st] != -1: return dp[f][st]\n            total = 0\n            for i in range(len(locations)):\n                if i != st:\n                    total += recur(i, ed, f - abs(locations[st] - locations[i]))\n            if st == ed:\n                answer = (total + 1) % MOD\n            else:\n                answer = total % MOD\n            dp[f][st] = answer\n            return answer\n        \n        recur(start, finish, fuel)\n\n        return dp[fuel][start]", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        N = len(locations)\n        DP = [[-1 for _ in range(fuel+1)] for _ in range(N)]\n\n        # for idx, x in enumerate(locations):\n        #     dist = abs(x - locations[finish])\n        #     print (idx, x, dist)\n        #     if dist <= fuel:\n        #         for y in range(dist, fuel+1):\n        #             DP[idx][y] = 1\n#         for x in locations:\n#             dist = abs(x - locations[finish])\n#             if dist <= fuel:\n#                 for y in range(dist, fuel+1):\n#                     DP[finish][y] = 1\n                    \n#         table = {}\n#         for idx, x in enumerate(locations):\n#             for idxy, y in enumerate(locations):\n#                 table[(idx, idxy)] = abs(locations[idx] - locations[idxy])\n                \n#         for c in range(fuel+1):\n#             for r in range(N):\n#                 # if True or DP[r][c] > 0:\n#                 for x in range(N):\n#                     if x == r: continue\n#                     dist = abs(table[(r, x)])\n#                     if dist <= c:\n#                         # print (r, c, \\\"going to\\\", x, \\\"cost\\\", dist, \\\"before\\\", DP[r][c], \\\" adding\\\", DP[x][c-dist])\n#                         DP[r][c] += DP[x][c-dist]\n#                         # print (\\\"after\\\", DP[r][c])\n#                 DP[r][c] %= 1000000007\n#                     # for y in range(c, N)\n       # return DP[start][fuel] % 1000000007 \n            \n        # print (DP)\n        \n        def dp(i, k):\n            if k < 0:\n                return 0\n            if DP[i][k] >= 0:\n                return DP[i][k]\n            ans = 1 if i == finish else 0\n            for j in range(N):\n                if i == j: continue\n                ans += dp(j, k - abs(locations[i]-locations[j]))\n            ans %= 1000000007\n            DP[i][k] = ans\n            return ans\n        return dp(start, fuel)\n        \n", "class Solution:\n    # dp(loc, fuel) = sum(dp(pre_loc, fuel + abs(loc-pre_loc)))\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        M = 10**9 + 7\n        @lru_cache(None)\n        def dp(curLocation, curFuel):\n            if curFuel > fuel:\n                return 0\n            nonlocal M\n            count = 0\n            for preLocation in locations:\n                if preLocation == curLocation:\n                    continue\n                preFuel = curFuel + abs(preLocation - curLocation)\n                if preFuel > fuel or (preFuel == fuel and preLocation != locations[start]):\n                    continue\n                if preLocation == locations[start] and preFuel == fuel:\n                    count = (count + 1) % M\n                else:\n                    count = (count + dp(preLocation, preFuel)) % M\n            return count % M\n\n        ans = sum([dp(locations[finish], f) % M for f in range(fuel)]) % M\n        return ans + 1 if start == finish else ans", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def rec(current, f):\n            if f<0:\n                return 0\n            else:\n                return (1 if current == finish else 0) +  sum(0 if i==current else rec(i, f-abs(locations[current]-locations[i])) for i in range(len(locations)))\n                \n                \n        return rec(start, fuel)%1000000007", "class Solution(object):\n    \n    def helper(self, city, fuel_left):\n\n        if (city, fuel_left) not in self.dp:\n            ans = 0\n\n            if fuel_left >= 0:\n\n                if city == self.finish:\n                    ans = 1\n\n                for index in range(self.n):\n                    if index != city:\n                        fuel_needed = abs(self.locations[index] - self.locations[city])\n                        ans += self.helper(index, fuel_left - fuel_needed)\n\n            self.dp[(city, fuel_left)] = ans\n\n        return self.dp[(city, fuel_left)]\n    \n    def countRoutes(self, locations, start, finish, fuel):\n        \\\"\\\"\\\"\n        :type locations: List[int]\n        :type start: int\n        :type finish: int\n        :type fuel: int\n        :rtype: int\n        \\\"\\\"\\\"\n        \n        self.n = len(locations)\n        self.locations = locations\n        self.finish = finish\n        \n        self.dp = {}\n        \n        mod = (10**9) + 7\n        return self.helper(start, fuel) % mod\n                \n            ", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        if fuel < abs(locations[start] - locations[finish]):\n            return 0\n        mask = int(1e9 + 7)\n        table = [[0] * len(locations) for i in range(fuel+1)]\n        table[fuel][start] = 1\n        for f in reversed(list(range(1, fuel + 1))):\n            for loc1 in range(len(locations)):\n                if table[f][loc1] == 0:\n                    continue\n                for loc2 in range(len(locations)):\n                    if loc2 == loc1:\n                        continue\n                    fuel_required = abs(locations[loc1] - locations[loc2])\n                    if fuel_required <= f:\n                        table[f-fuel_required][loc2] += table[f][loc1]\n        return sum([table[f][finish] for f in range(fuel+1)]) % mask\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        start = locations[start]\n        finish = locations[finish]\n        locations.sort()\n        #print(locations)\n        res = 0\n        dict = {}\n        def dfs(start, finish, fuel):\n            #[2,3,4,6,8] 3->6\n            #print((start, finish, fuel))\n            if (start, fuel) in dict:\n                return dict[(start, fuel)]\n            route = 0\n            for val in locations:\n                if val != start and abs(val - start) <= fuel:\n                    if val == finish:\n                        route += 1\n                    \n                    dict[(val, fuel-abs(val - start))] = dfs(val, finish, fuel-abs(val - start))\n                    route += dict[(val, fuel-abs(val - start))]\n            return route\n                    \n        res = dfs(start, finish, fuel)\n        if start == finish:\n            res += 1\n        return res%(10**9+7)", "class Solution:\n    def countRoutes(self, locations, start: int, finish: int, fuel: int) -> int:\n        KMAX = 10 ** 9 + 7\n        N = len(locations)\n        mem = dict()\n        \n        def dp(city, gas):\n            if (city, gas) in mem:\n                return mem[city, gas]\n            if gas < 0:\n                return 0\n            mem[city, gas] = 1 if city == finish else 0\n            for i in range(N):\n                if i == city or abs(locations[i] - locations[city]) > gas:\n                    continue\n                mem[city, gas] += dp(i, gas - abs(locations[i] - locations[city]))\n            return mem[city, gas]\n        res = dp(start, fuel) % KMAX\n        return res\n", "import collections\nclass Solution:\n        def countRoutes(self, locations, start: int, finish: int, fuel: int) -> int:\n            self.memorization = collections.defaultdict(int)\n\n            def dfs_memorization(index, currentCityValue, destinationIndex, remainingFuel, locations):\n                temp_count = 0\n                if (index, currentCityValue, remainingFuel) in self.memorization:\n                    return self.memorization[(index, currentCityValue, remainingFuel)]\n                if remainingFuel < 0:\n                    self.memorization[(index, currentCityValue, remainingFuel)] = 0\n                    return 0\n                if remainingFuel == 0 and index == destinationIndex:\n                    self.memorization[(index, currentCityValue, remainingFuel)] = 1\n                    return 1\n                if remainingFuel == 0 and index != destinationIndex:\n                    self.memorization[(index, currentCityValue, remainingFuel)] = 0\n                    return 0\n                if index == destinationIndex:\n                    temp_count += 1\n\n\n\n                for i in range(len(locations)):\n                    if i == index:\n                        continue\n                    temp_count += dfs_memorization(i, locations[i], destinationIndex,\n                                                   remainingFuel - abs(currentCityValue - locations[i]), locations)\n\n                self.memorization[(index, currentCityValue, remainingFuel)] = temp_count\n                return temp_count\n\n            count = dfs_memorization(start, locations[start], finish, fuel, locations)\n            return count % (10**9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10 ** 9 + 7\n        memo = {}\n        def dp(pos, leftFuel):\n            # print(pos, leftFuel)\n            if memo.get((pos, leftFuel), None) is not None:\n                return memo[pos, leftFuel]\n            ans = 0\n            if pos == finish:\n                ans = 1\n            for otherPos in range(len(locations)):\n                if pos != otherPos and abs(locations[pos] - locations[otherPos]) <= leftFuel:\n                    ans += dp(otherPos, leftFuel - abs(locations[pos] - locations[otherPos]))\n            memo[pos, leftFuel] = ans\n            return ans\n        \n        \n        ans = dp(start, fuel) % mod\n        # print(memo)\n        return ans", "from functools import lru_cache\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dp(f, i):\n            if (f, i) == (fuel, start): return 1\n            ans = 0\n            for j in range(n):\n                if i == j: continue\n                nd = f + abs(locations[j] - locations[i])\n                if nd <= fuel:\n                    ans = (ans + dp(nd, j)) % md\n            return ans\n        n, md = len(locations), 10**9+7\n        res = 0\n        for i in range(fuel+1):\n            res = (res + dp(i, finish)) % md\n        return res", "\nclass Solution:\n    d = {}\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.loc = sorted(locations)\n        self.numloc = len(locations)\n        self.num = 10**9 + 7\n        Solution.d = {}\n        newstart = self.loc.index(locations[start])\n        newfinish = self.loc.index(locations[finish])\n        ways = self.cr(newstart, newfinish, fuel)\n        if newstart == newfinish and ways == 0:\n            return 1\n        if newstart == newfinish:\n            ways += 1\n        return ways\n    \n    def cr(self, start, finish, fuel):\n        if fuel < 0 or fuel < abs(self.loc[finish] - self.loc[start]):\n            return 0\n        if (start, fuel) in Solution.d:\n            return Solution.d[(start, fuel)]\n        minfuel = abs(self.loc[finish] - self.loc[start])\n        if fuel <= minfuel + 1:\n            Solution.d[(start, fuel)] = 2 ** (abs(finish-start) - 1)\n            return Solution.d[(start, fuel)]\n        \n        ways = 0\n        for i in range(self.numloc):\n            if i != start:\n                fuel1 = abs(self.loc[i] - self.loc[start])\n                fuel2 = abs(self.loc[i] - self.loc[finish])\n                if fuel1 + fuel2 <= fuel:\n                    ways += self.cr(i, finish, fuel - fuel1)\n        if start != finish:\n            ways += 1\n        ways %=  self.num\n        Solution.d[(start, fuel)] = ways\n        return ways\n", "class Solution:\n    \n    def __init__(self, *args, **kwargs):\n        self.mp = {}  # key: start-fuel; val: numWays\n    \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        if fuel < 0:\n            return 0\n        key = '{}-{}'.format(start, fuel)\n        if key in self.mp:\n            return self.mp[key]\n        res = 1 if start == finish else 0\n        for i in range(len(locations)):\n            if i != start:\n                res += self.countRoutes(locations, i, finish, fuel-abs(locations[start]-locations[i]))\n        res %= (10**9 + 7)\n        self.mp[key] = res\n        return res\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        count = 0\n        mod = 10**9+7\n        n = len(locations)\n        s_l = locations[start]\n        f_l = locations[finish]\n        locations.sort()\n\n        start = locations.index(s_l) \n        finish = locations.index(f_l)\n        \n        import functools\n        @functools.lru_cache(None)\n        def DFS(cur_city,cur_fuel):\n            if cur_fuel < abs(locations[cur_city]-locations[finish]):\n                return 0\n            if cur_city == finish:\n                c = 1\n            else:\n                c = 0\n                \n            for nxt in range(n):\n                if nxt == cur_city or cur_fuel < abs(locations[cur_city]-locations[nxt]) :\n                    continue\n                else:\n                    c += DFS(nxt,cur_fuel - abs(locations[cur_city]-locations[nxt]))\n            return c % mod\n        \n        return DFS(start,fuel) % mod\n                    \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.memo={}\n        self.mod=10**9 + 7\n        \n        ret=self.dp(locations,start,finish,fuel)\n        return ret%self.mod\n    \n    def dp(self,locations,start,finish,fuel):\n        if (start,fuel) in self.memo:\n            return self.memo[(start,fuel)]\n        if fuel<0:\n            return 0\n        ans=0\n        \n        if start==finish:\n                ans+=1\n        for i,sf in enumerate(locations):\n            if i==start:\n                continue\n            ans+=(self.dp(locations,i,finish,fuel-abs(locations[i]-locations[start])))%self.mod\n        self.memo[(start,fuel)]=ans\n        return ans\n                \n        \n        \n        \n        \n        \n        \n", "\\\"\\\"\\\"\ndp[f][c]: when arriving at city c, with fuel f left\n\nfor d in range(n):\n    gas = abs(locations[d] - locations[c])\n    dp[f][c] += dp[f+gas][d]\n    \nreturn sum(dp[f][finish]) for all f\n\n\ndp[f][3] <- dp[f+1][2], dp[f+2][1], dp[f+3][0]\n\n\n0 1 2 3\n\ndp[f][c][k] k=0: stay, k=1: moving right, k=2: moving left\n\nfor f in range(fuel, -1, -1):\n    for c in range(n):\n        if c>0:\n            gas = lications[c] - locations[c-1]\n            dp[f][c][0] += dp[f+gas][c-1][1] + dp[f+gas][c-1][0]\n            dp[f][c][1] += dp[f+gas][c-1][1] + dp[f+gas][c-1][0]\n        if c < n-1:\n            gas = lications[c+1] - locations[c-1]\n            dp[f][c][0] += dp[f+gas][c+1][2] + dp[f+gas][c+1][0]\n            dp[f][c][2] += dp[f+gas][c+1][2] + dp[f+gas][c+1][0]\n            \nreturn sum{dp[f][finish][0]} for all f\n\n\\\"\\\"\\\"\n\n\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[[0 for i in range(3)] for j in range(201)] for _ in range(201)]\n        mod = 10 ** 9 + 7\n        startPos = locations[start]\n        finishPos = locations[finish]\n        locations.sort()\n        n = len(locations)\n        \n        startIdx, finishIdx = 0, 0\n        for i in range(n):\n            if locations[i]==startPos:\n                startIdx = i\n            if locations[i]==finishPos:\n                finishIdx = i\n        \n        dp[fuel][startIdx][0] = 1\n        \n        for f in range(fuel, -1, -1):\n            for c in range(n):\n                if c>0 and f+locations[c]-locations[c-1] <= fuel:\n                    gas = locations[c] - locations[c-1]\n                    dp[f][c][0] += dp[f+gas][c-1][1] + dp[f+gas][c-1][0]\n                    dp[f][c][1] += dp[f+gas][c-1][1] + dp[f+gas][c-1][0]\n                if c < n-1 and f+locations[c+1]-locations[c] <= fuel:\n                    gas = locations[c+1] - locations[c]\n                    dp[f][c][0] += dp[f+gas][c+1][2] + dp[f+gas][c+1][0]\n                    dp[f][c][2] += dp[f+gas][c+1][2] + dp[f+gas][c+1][0]\n        \n        dp[f][c][0] %= mod\n        dp[f][c][1] %= mod\n        dp[f][c][2] %= mod\n                \n        res = 0\n        for f in range(fuel+1):\n            res = (res + dp[f][finishIdx][0]) % mod\n        return res\n        \n        \n        \n        \n        \n        \n        ", "class Solution:\n    # dp(loc, fuel) = sum(dp(pre_loc, fuel + abs(loc-pre_loc)))\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        M = 10**9 + 7\n        @lru_cache(None)\n        def dp(curLocation, curFuel):\n            if curFuel > fuel:\n                return 0\n            nonlocal M\n            count = 0\n            for preLocation in locations:\n                if preLocation == curLocation:\n                    continue\n                preFuel = curFuel + abs(preLocation - curLocation)\n                if preLocation == locations[start] and preFuel == fuel:\n                    count = (count + 1) % M\n                if preFuel >= fuel:\n                    continue\n                count = (count + dp(preLocation, preFuel)) % M\n            return count % M\n\n        ans = sum([dp(locations[finish], f) % M for f in range(fuel)]) % M\n        return ans + 1 if start == finish else ans", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        numCity = len(locations)\n        dp = [[None]*(fuel+1) for _ in range(numCity)]\n        def helper(city, fuel):\n            if fuel < 0: return 0\n            res = dp[city][fuel]\n            if res is not None: return res\n            res = (int(city==finish) + sum(helper(city2, fuel-abs(locations[city]-locations[city2])) for city2 in range(numCity) if city!=city2)) % (10**9 + 7)\n            dp[city][fuel] = res\n            return res\n        return helper(start, fuel)\n", "class Solution:\n    def countRoutesUtil(self, locations , currentLocation , target , fuelLeft , dp):\n        if fuelLeft < 0:\n            return 0\n        key = (currentLocation,fuelLeft)\n        if key in dp:\n            return dp[key]\n        result = 0\n        if currentLocation == target:\n            result += 1\n        for i in range(len(locations)):\n            if i != currentLocation:\n                result += self.countRoutesUtil(locations,i,target,fuelLeft-abs(locations[i]-locations[currentLocation]),dp)\n                result %= (10 ** 9 + 7)\n        dp[key] = result % (10 ** 9 + 7)\n        return dp[key]\n        \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        return self.countRoutesUtil(locations,start,finish,fuel,{})\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        start = locations[start]\n        finish = locations[finish]\n        locations.sort()\n        #print(locations)\n        res = 0\n        dict = {}\n        def dfs(start, finish, fuel):\n            #[2,3,4,6,8] 3->6\n            #print((start, finish, fuel))\n            if (start, fuel) in dict:\n                return dict[(start, fuel)]\n            route = 0\n            for index, val in enumerate(locations):\n                \n                if val != start and abs(val - start) <= fuel:\n                    if val == finish:\n                        route += 1\n                    dict[(val, fuel-abs(val - start))] = dfs(val, finish, fuel-abs(val - start))\n                    route += dict[(val, fuel-abs(val - start))]\n            return route\n                    \n        res = dfs(start, finish, fuel)\n        if start == finish:\n            res += 1\n        return res%(10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mem={}\n        \n        def count(start,end,fuel,mem):\n            if fuel==0 and start!=end:\n                return 0\n            if not mem.get((start,fuel)) is None:\n                return mem[(start,fuel)]\n            res=0\n            if start==end:\n                res=1\n            for i in range(len(locations)):\n                if i!=start and abs(locations[i]-locations[start])<=fuel:\n                    res+=count(i,end,fuel-abs(locations[i]-locations[start]),mem)\n            mem[(start,fuel)]=res%(10**9+7)\n            return mem[(start,fuel)]\n        \n        res=count(start,finish,fuel,mem)\n        return res\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(None)\n        def dfs(x, y, f):\n            if abs(A[x] - A[y]) > f:\n                print((x, y, f, 0))\n                return 0\n            ret = 0\n            if abs(A[x] - A[y]) <= f:\n                ret += 1\n            for mid in range(n):\n                g = abs(A[mid] - A[x]) + abs(A[mid] - A[y])\n                if mid == x or g > f:\n                    continue\n                ret += dfs(mid, y, f - abs(A[mid] - A[x]))\n                if mid == y:\n                    ret -= 1\n                ret %= MOD\n            return ret\n                \n        A = locations\n        n = len(A)\n        MOD = 10 ** 9 + 7\n        return dfs(start, finish, fuel)\n\n\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        neighbors = defaultdict(list)\n        for i in range(len(locations)):\n            for j in range(i + 1, len(locations)):\n                if abs(locations[i] - locations[j]) <= fuel:\n                    neighbors[i].append((j, abs(locations[i] - locations[j])))\n                    neighbors[j].append((i, abs(locations[i] - locations[j])))\n\n        @lru_cache(None)\n        def helper(location, fuel_remaining):\n            sum = 0\n            if fuel_remaining < 0:\n                return 0\n            if location == finish:\n                sum += 1\n            for (neighbor, cost) in neighbors[location]:\n                sum += helper(neighbor, fuel_remaining - cost)\n            return sum\n        return helper(start, fuel) % ((10 ** 9) + 7)", "class Solution:\n    dp = dict()\n    def rec(self, start, finish, fuel, loc):\n        nonlocal dp\n        if (start, fuel) in dp:\n            return dp[(start, fuel)]\n        if fuel<0:\n            dp[(start, fuel)] = 0\n            return dp[(start, fuel)]\n        ans = 0\n        if start==finish:\n            ans+=1\n        for i in range(len(loc)):\n            if i==start:\n                continue\n            ans+=self.rec(i,finish,fuel-abs(loc[start]-loc[i]),loc)\n        dp[(start, fuel)] = ans\n        return dp[(start, fuel)]\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        nonlocal dp\n        dp = dict()\n        return (self.rec(start, finish, fuel, locations))%(1000000007)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        res, mod, cache = 0, 10 ** 9 + 7, {}\n        # cache[(i, fuel)]: how many ways to start from city i with initial fuel to go to city end\n        def dfs(s, fuel):\n            if fuel <= 0:\n                return 0\n            if (s, fuel) not in cache:\n                cache[(s, fuel)] = 0\n                for city in range(len(locations)):\n                    if city != s:\n                        cache[(s, fuel)] += dfs(city, fuel - abs(locations[city] - locations[s])) % mod\n                        if city == finish and fuel - abs(locations[city] - locations[s]) >= 0:\n                            cache[(s, fuel)] += 1\n            return cache[(s, fuel)] % mod\n        return dfs(start, fuel) + (0 if start != finish else 1)\n'''\n[2,1,5]\n0\n0\n3\n[2,3,6,8,4]\n1\n3\n5\n [4,3,1]\n 1\n 0\n 6\n [5,2,1]\n 0\n 2\n 3\n [1,2,3]\n 0\n 2\n 40\n'''", "from functools import lru_cache\nclass Solution:\n    @lru_cache(None)\n    def solve(self, curr, fuel):\n        if fuel < 0:\n            return 0\n        if fuel == 0 and curr != self.fin:\n            return 0\n        ans = 0\n        if curr == self.fin:\n            ans += 1\n        for i in range(len(self.loc)):\n            if i == curr:\n                continue\n            ans += self.solve(i, fuel-abs(self.loc[i]-self.loc[curr]))\n            ans %= self.mod\n        return ans\n        \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.mod = 1000000007\n        self.loc = locations\n        self.fin = finish\n        return self.solve(start, fuel)%self.mod", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        cache = dict()\n        def helper(i, f):\n            if f < 0:\n                return 0\n            if (i,f) not in cache:\n                count = 1 if i == finish else 0\n                for j in range(len(locations)):\n                    if i != j:\n                        count += helper(j, f - abs(locations[i] - locations[j]))\n                cache[(i,f)] = count\n            return cache[(i,f)]\n        return helper(start, fuel) % 1000000007\n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        mod = 10**9 + 7\n        \n        @functools.lru_cache(None)\n        def solve(end, fuel):\n            nonlocal n, start\n            if fuel == 0:\n                if end == start:\n                    return 1\n                else:\n                    return 0\n            ans = 0\n            for i in range(n):\n                if i != end and abs(locations[i] - locations[end]) <= fuel:\n                    ans += solve(i, fuel - abs(locations[i] - locations[end]))\n            return ans\n            \n        ans = 0\n        \n        for i in range(fuel + 1):\n            ans += solve(finish, i)\n        return ans % mod", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dic = defaultdict(lambda: defaultdict(lambda: 0))\n        dic[fuel] = {start: 1}\n        ans = 0\n        mod = 10**9 + 7\n        for f in range(fuel, -1, -1):\n            for j, r in list(dic[f].items()):\n                for i in range(len(locations)):\n                    if j != i:\n                        meh = f - abs(locations[j]-locations[i])\n                        if meh >= 0:\n                            dic[meh][i] = (dic[meh][i] + r) % mod\n            ans = (ans + dic[f-1][finish]) % mod\n        return ans + (start==finish)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n,m=len(locations),1000000007\n        s=[[0]*n for _ in range(fuel+1)]\n        s[fuel][start]=1\n        for i in range(fuel,0,-1):\n            for j in range(n):\n                if abs(locations[j]-locations[finish])<=i:\n                    for k in range(j):\n                        t=abs(locations[j]-locations[k])\n                        if t<=i: s[i-t][k]=(s[i-t][k]+s[i][j])%m\n                    for k in range(j+1,n):\n                        t=abs(locations[j]-locations[k])\n                        if t<=i: s[i-t][k]=(s[i-t][k]+s[i][j])%m\n        return sum([s[i][finish] for i in range(fuel+1)])%m", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        if abs(locations[start] - locations[finish]) > fuel:\n            return 0\n        \n        distances = [[0] * n for i in range(n)]\n        for i in range(n):\n            for j in range(i, n):\n                distances[i][j] = abs(locations[i] - locations[j])\n                distances[j][i] = distances[i][j]\n        \n        mod = 1000000007\n        \n        dp = [[0] * n for i in range(fuel + 1)]\n        dp[0][finish] = 1\n        for f in range(1, fuel + 1):\n            for i in range(n):\n                for j in range(n):\n                    if i == j:\n                        continue\n                    else:\n                        dist = distances[i][j]\n                        if f - dist >= 0:\n                            dp[f][i] += dp[f - dist][j]\n        res = 0\n        for i in range(fuel + 1):\n            res += dp[i][start]\n        return res % mod", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        #place,fuel: times, fuel\n        start_val,finish_val = locations[start],locations[finish]\n        locations.sort()\n        start,finish = bisect.bisect_left(locations,start_val),bisect.bisect_left(locations,finish_val)\n        res = 0\n        n = len(locations)\n        # dp[i][k] means used i fuel end with k\n        dp = [[0]*(n) for i in range(fuel+1)]\n        dp[0][start] = 1\n        for i in range(0,fuel+1):\n            for j in range(n):\n                p = locations[j]\n                indl,indr = bisect.bisect_left(locations,p-(fuel-i)),bisect.bisect_right(locations,p+(fuel-i))\n                for k in range(indl,indr):\n                    if k==j:\n                        continue\n                    dis = abs(locations[k]-p)\n                    dp[dis+i][k]+=dp[i][j]\n        for i in range(fuel+1):\n            res+=dp[i][finish]\n        return res%(10**9+7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @functools.lru_cache(None)\n        def dp(pos,fuel):\n            res=1 if pos==locations[finish] else 0\n            for nxt in locations:\n                if nxt==pos or fuel<abs(nxt-pos):\n                    continue\n                res+=dp(nxt,fuel-abs(nxt-pos))\n            return res%(10**9+7)\n        return dp(locations[start],fuel)\n", "class Solution:\n    mps = []\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.mps = []\n        for i in range(len(locations)):\n            self.mps.append({})\n        return self.dfs(locations, start, finish, fuel) % (10 ** 9 + 7)\n        \n    def dfs(self, locations, cur, finish, fuel):\n        if fuel in self.mps[cur]:\n            return self.mps[cur][fuel]\n        \n        ans = 0\n        if cur == finish:\n            ans += 1\n        if fuel == 0:\n            return ans\n            \n        for i in range(len(locations)):\n            if i != cur:\n                cost = abs(locations[i] - locations[cur])\n                if cost <= fuel:\n                    ans += self.dfs(locations, i, finish, fuel - cost)\n        \n        self.mps[cur][fuel] = ans\n        \n        return ans", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # print(start, finish, fuel)\n        self.mp = {}  # key: start-finish-fuel; val: numWays\n        return self.dfs(locations, start, finish, fuel)\n    \n    def dfs(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        if fuel < 0:\n            return 0\n        key = '{}-{}-{}'.format(start, finish, fuel)\n        if key in self.mp:\n            return self.mp[key]\n        res = 1 if start == finish else 0\n        for i in range(len(locations)):\n            if i != start:\n                res += self.dfs(locations, i, finish, fuel-abs(locations[start]-locations[i]))\n        res %= (10**9 + 7)\n        self.mp[key] = res\n        return res\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.locations = locations\n        self.cache = [{} for i in range (len(locations))]\n        re=self.dfs(start, finish, fuel)\n        return re%(pow(10,9)+7)\n\n\n    def dfs(self, start, tmpend, fu):\n        if fu in list(self.cache[tmpend].keys()):\n            return self.cache[tmpend][fu]\n        if fu < 0:\n            return 0\n        if fu == 0:\n            self.cache[tmpend][0] = 0 if start != tmpend else 1\n            return self.cache[tmpend][0]\n        self.cache[tmpend][fu]=0\n        for i in range(len(self.locations)):          # if fu>0\n            if i == tmpend:\n                continue\n            self.cache[tmpend][fu] += self.dfs(start, i, fu-abs(self.locations[i]-self.locations[tmpend]))\n        if start == tmpend:\n            self.cache[tmpend][fu] +=1\n        return self.cache[tmpend][fu]\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = {}\n        \n        def recursive(curr, finish, fuel):\n            key = (curr, fuel)\n            count = 0\n\n            if curr == finish:\n                count += 1\n            \n            elif key in dp:\n                return dp[key]\n            \n            for c in range(len(locations)):\n                fuelRequired = abs(locations[c] - locations[curr])\n                \n                if c != curr and fuel >= fuelRequired:\n                    count += recursive(c, finish, fuel - fuelRequired)\n\n            dp[key] = count\n            \n            return dp[key]\n        \n        return recursive(start, finish, fuel) % (10**9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = {}\n        \n        def recursive(curr, fuel):\n            key = (curr, fuel)\n            count = 0\n\n            if curr == finish:\n                count += 1\n            \n            elif key in dp:\n                return dp[key]\n            \n            for c in range(len(locations)):\n                fuelRequired = abs(locations[c] - locations[curr])\n                \n                if c != curr and fuel >= fuelRequired:\n                    count += recursive(c, fuel - fuelRequired)\n\n            dp[key] = count\n            \n            return dp[key]\n        \n        return recursive(start, fuel) % (10**9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10 ** 9 + 7\n        \n        @lru_cache(None)\n        def go(index, fuel):\n            total = 0\n            if fuel < 0:\n                return 0\n            \n            if index == finish:\n                total += 1\n                \n            current = locations[index]\n            for next_index, x in enumerate(locations):\n                if next_index != index:\n                    total += go(next_index, max(-1, fuel - abs(current - x)))\n                    total %= mod\n            return total % mod\n        \n        ans = go(start, fuel)\n        return ans % mod", "class Solution:\n    # dp(loc, fuel) = sum(dp(pre_loc, fuel + abs(loc-pre_loc)))\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        M = 10**9 + 7\n        @lru_cache(None)\n        def dp(locId, curFuel):\n            if curFuel > fuel:\n                return 0\n            nonlocal M\n            count = 0\n            curLocation = locations[locId]\n            for i in range(len(locations)):\n                if i == locId:\n                    continue\n                preLocation = locations[i]\n                preFuel = curFuel + abs(preLocation - curLocation)\n                if preLocation == locations[start] and preFuel == fuel:\n                    count = (count + 1) % M\n                if preFuel >= fuel:\n                    continue\n                count = (count + dp(i, preFuel)) % M\n            return count % M\n\n        ans = sum([dp(finish, f) % M for f in range(fuel)]) % M\n        return ans + 1 if start == finish else ans", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(None)\n        def helper(startInd, remainFuel):\n            if remainFuel < 0: return 0\n            if abs(locations[finish] - locations[startInd]) > remainFuel: return 0\n            if remainFuel == 0:\n                return 1\n            \n            res = 1 if startInd == finish else 0\n            for i in range(0, len(locations)):\n                if i == startInd or abs(locations[i] - locations[startInd]) > remainFuel:\n                    continue\n                res += helper(i, remainFuel - abs(locations[i] - locations[startInd]))\n            return res % (10**9 + 7)\n            \n        return helper(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = {}\n        M = 1e9 + 7\n        def go(now, f):\n            if (now, f) in dp:\n                return dp[(now, f)]\n            if f < 0:\n                return 0\n            if now == finish:\n                dp[(now, f)] = 1\n                for i, v in enumerate(locations):\n                    if i != now and f - abs(locations[now] - v) >= 0:\n                        dp[(now, f)] += go(i, f - abs(locations[now] - v))\n                dp[(now, f)] %= M\n                return dp[(now, f)]\n            dp[(now, f)] = 0\n            for i, v in enumerate(locations):\n                if i != now and f - abs(locations[now] - v) >= 0:\n                    dp[(now, f)] += go(i, f - abs(locations[now] - v))\n            dp[(now, f)] %= M\n            return dp[(now, f)]\n        return int(go(start, fuel))", "import functools\nimport sys\n\nclass Solution:\n    @lru_cache(None)\n    def rec(self, i, fuel):\n        if fuel==0 and i!=self.finish:\n            return 0\n        \n        if i==self.finish and fuel==0:\n            return 1\n        \n        if i==self.finish:\n            ans = 1\n        else:\n            ans = 0\n            \n        for j in range(len(self.locations)):\n            diff = abs(self.locations[j]-self.locations[i])\n            if i!=j and diff<=fuel:\n                ans+=self.rec(j, fuel-diff)\n                ans%=self.MOD\n        \n        return ans\n            \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.MOD = 10**9+7\n        self.locations = locations\n        self.finish = finish\n        sys.setrecursionlimit(1500)\n\n        \n        return self.rec(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # self.count = 0\n        if abs(locations[start] - locations[finish]) > fuel:\n            return 0\n        d = {}\n        def findcombo(current_pos, rem_fuel):\n            count = 0\n            # print(current_pos, rem_fuel)\n            if (current_pos, rem_fuel) in d:\n                return d[(current_pos, rem_fuel)]\n            if rem_fuel >= 0 and current_pos == finish:\n                count+=1\n            if rem_fuel > 0:\n                for i in range(0, len(locations)):\n                    if i != current_pos:\n                            balance = abs(locations[current_pos] - locations[i]) + abs(locations[current_pos] - locations[finish])\n                            if balance >= 0:\n                                count+= findcombo(i, rem_fuel - abs(locations[current_pos] - locations[i]))\n            d[(current_pos, rem_fuel)] = count\n            return count\n        c = findcombo(start, fuel)\n        return c%1000000007\n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        def count(start, fuel):\n            if fuel < 0:\n                return 0\n\n            if (start, fuel) in memo:\n                return memo[(start, fuel)]\n            \n            s = 0  # sum\n            if start == finish:\n                s += 1 \n            for i in range(len(locations)):\n                if i != start:\n                    s += count(i, fuel-abs(locations[i]-locations[start]))\n            memo[(start, fuel)] = s\n            return s\n\n        memo = {}\n        return count(start, fuel) % (10**9 + 7)\n", "MAX = int(10 ** 9 + 7)\n\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        A = [[None for _ in range(fuel + 1)] for _ in range(len(locations))]\n\n        A[start][fuel] = 1\n\n        for f in range(fuel, -1, -1):\n            for ca in range(len(locations) - 1, -1, -1):\n                if A[ca][f] is None:\n                    continue\n\n                for cb in range(len(locations) - 1, -1, -1):\n                    if cb == ca:\n                        continue\n                    loss = int(abs(locations[ca] - locations[cb]))\n                    if loss > f:\n                        continue\n\n                    A[cb][f - loss] = ((A[cb][f - loss] or 0) + A[ca][f]) % MAX\n\n        r = 0\n        for x in A[finish]:\n            if x is None:\n                continue\n            r = (r + x) % MAX\n\n        return r", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        #place,fuel: times, fuel\n        start_val,finish_val = locations[start],locations[finish]\n        if abs(start_val-finish_val)>fuel:\n            return 0\n        locations.sort()\n        start,finish = bisect.bisect_left(locations,start_val),bisect.bisect_left(locations,finish_val)\n        res = 0\n        n = len(locations)\n        # dp[i][k] means used i fuel end with k\n        dp = [[0]*(n) for i in range(fuel+1)]\n        dp[0][start] = 1\n        for i in range(0,fuel+1):\n            for j in range(n):\n                p = locations[j]\n                indl,indr = bisect.bisect_left(locations,p-(fuel-i)),bisect.bisect_right(locations,p+(fuel-i))\n                for k in range(indl,indr):\n                    if k==j:\n                        continue\n                    dis = abs(locations[k]-p)\n                    dp[dis+i][k]+=dp[i][j]\n        for i in range(fuel+1):\n            res+=dp[i][finish]\n        return res%(10**9+7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        seen = {}\n        def cost(i,j):\n            return abs(locations[i] - locations[j])\n        def dfs(n,f):\n            if f < 0: return 0\n            if f < cost(n,finish):return 0\n            if '{}_{}'.format(n,f) in seen: return seen['{}_{}'.format(n,f)]\n            ans = int(n == finish)\n            for next_n in range(len(locations)):\n                if next_n != n:\n                    ans += dfs(next_n,f - cost(n,next_n))\n            seen['{}_{}'.format(n,f)] = ans % (10**9 +7)\n            return ans % (10**9 +7)\n        return dfs(start,fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        memo = dict()\n        def backtrack(n,k):\n            if k < 0:\n                return 0\n            if k==0:\n                return int(n== finish)\n            \n            key = (n,k)\n            if key not in memo:\n                memo[key] = int(n==finish)\n                for nei in range(len(locations)):\n                    if nei != n:\n                        memo[key] += backtrack(nei, k-abs(locations[n] - locations[nei])) % 1000000007\n            return memo[key]\n        \n        return backtrack(start,fuel) %1000000007", "from queue import Queue\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        memo = {}\n        def countMemo(currLocation, currFuel):\n            if memo.get((currLocation, currFuel)) is not None:\n                return memo.get((currLocation, currFuel))\n            else:\n                result = 0\n                if currLocation == locations[finish]:\n                    result = 1\n                for l in locations:\n                    if currFuel - abs(currLocation - l) >= 0 and l != currLocation:\n                        result += countMemo(l, currFuel - abs(currLocation - l))\n                memo[(currLocation, currFuel)] = result\n                return result\n        \n        r = countMemo(locations[start], fuel) % ((10 ** 9) + 7)\n        #(memo)\n        return r", "from collections import Counter, defaultdict, OrderedDict, deque\nfrom bisect import bisect_left, bisect_right\nfrom functools import reduce, lru_cache\nfrom typing import List\nimport itertools\nimport math\nimport heapq\nimport string\ntrue = True\nfalse = False\nMIN, MAX, MOD = -0x3f3f3f3f, 0x3f3f3f3f, 1000000007\n\n\n#\n# @lc app=leetcode id=1575 lang=python3\n#\n# [1575] Count All Possible Routes\n#\n# https://leetcode.com/problems/count-all-possible-routes/description/\n#\n# algorithms\n# Hard (59.30%)\n# Total Accepted:    1.7K\n# Total Submissions: 2.8K\n# Testcase Example:  '[2,3,6,8,4]\\\n1\\\n3\\\n5'\n#\n# You are given an array of distinct positive integers locations\u00a0where\n# locations[i] represents the position of city i. You are also given\u00a0integers\n# start,\u00a0finish\u00a0and\u00a0fuel\u00a0representing the starting city, ending city, and the\n# initial amount of fuel you have, respectively.\n#\n# At each step, if you are at city\u00a0i, you can pick any city\u00a0j\u00a0such that j != i\n# and\u00a00 <= j < locations.length\u00a0and move to city j.\u00a0Moving from city i to city\n# j reduces the amount of fuel you have by\u00a0|locations[i] - locations[j]|.\n# Please notice that |x|\u00a0denotes the absolute value of x.\n#\n# Notice that\u00a0fuel\u00a0cannot become negative at any point in time, and that you\n# are allowed to visit any city more than once (including start\u00a0and\u00a0finish).\n#\n# Return the count of all possible routes from\u00a0start\u00a0to\u00a0finish.\n#\n# Since the answer\u00a0may be too large,\u00a0return it modulo\u00a010^9 + 7.\n#\n#\n# Example 1:\n#\n#\n# Input: locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5\n# Output: 4\n# Explanation:\u00a0The following are all possible routes, each uses 5 units of\n# fuel:\n# 1 -> 3\n# 1 -> 2 -> 3\n# 1 -> 4 -> 3\n# 1 -> 4 -> 2 -> 3\n#\n#\n# Example 2:\n#\n#\n# Input: locations = [4,3,1], start = 1, finish = 0, fuel = 6\n# Output: 5\n# Explanation: The following are all possible routes:\n# 1 -> 0, used fuel = 1\n# 1 -> 2 -> 0, used fuel = 5\n# 1 -> 2 -> 1 -> 0, used fuel = 5\n# 1 -> 0 -> 1 -> 0, used fuel = 3\n# 1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5\n#\n#\n# Example 3:\n#\n#\n# Input: locations = [5,2,1], start = 0, finish = 2, fuel = 3\n# Output: 0\n# Explanation: It's impossible to get from 0 to 2 using only 3 units of fuel\n# since the shortest route needs 4 units of fuel.\n#\n# Example 4:\n#\n#\n# Input: locations = [2,1,5], start = 0, finish = 0, fuel = 3\n# Output: 2\n# Explanation:\u00a0There are two possible routes, 0 and 0 -> 1 -> 0.\n#\n# Example 5:\n#\n#\n# Input: locations = [1,2,3], start = 0, finish = 2, fuel = 40\n# Output: 615088286\n# Explanation: The total number of possible routes is 2615088300. Taking this\n# number modulo 10^9 + 7 gives us 615088286.\n#\n#\n#\n# Constraints:\n#\n#\n# 2 <= locations.length <= 100\n# 1 <= locations[i] <= 10^9\n# All integers in\u00a0locations\u00a0are\u00a0distinct.\n# 0 <= start, finish <\u00a0locations.length\n# 1 <= fuel <= 200\n#\n#\n#\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int,\n                    fuel: int) -> int:\n        @lru_cache(None)\n        def dp(i, f):\n            if f < 0: return 0\n            if f == 0: return 1 if i == finish else 0\n            ans = 1 if i == finish else 0\n            ans += sum(\n                map(\n                    lambda j: dp(j, f - abs(locations[i] - locations[j])),\n                    filter(\n                        lambda j: j != i and abs(locations[j] - locations[i]),\n                        range(0, len(locations)))))\n            # for j in range(0, len(locations)):\n            #     if j != i and f >= abs(locations[j] - locations[i]):\n            #         ans += dp(j, f - abs(locations[i] - locations[j])) % MOD\n\n            return ans % MOD\n\n        return dp(start, fuel)\n\n\nsol = Solution()\n\nlocations, start, finish, fuel = [2, 3, 6, 8, 4], 1, 3, 5\n# locations, start, finish, fuel = [4,3,1], 1, 0, 6\n# locations, start, finish, fuel = [5,2,1], 0, 2, 3\n# locations, start, finish, fuel = [2,1,5], 0, 0, 3\nlocations, start, finish, fuel = [1, 2, 3], 0, 2, 40\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        count = 0\n        mod = 10**9+7\n        n = len(locations)\n        s_l = locations[start]\n        f_l = locations[finish]\n        locations.sort()\n        start = locations.index(s_l) \n        finish = locations.index(f_l)\n        \n        import functools\n        @functools.lru_cache(None)\n        def DFS(cur_city,cur_fuel):\n            if cur_fuel < abs(locations[cur_city]-locations[finish]):\n                return 0\n            if cur_city == finish:\n                c = 1\n            else:\n                c = 0\n            i = bisect.bisect_left(locations,locations[cur_city]-cur_fuel)\n            j = min(n-1,bisect.bisect_left(locations,locations[cur_city]+cur_fuel))\n            for nxt in range(i,cur_city):\n                c += DFS(nxt,cur_fuel - abs(locations[cur_city]-locations[nxt]))\n            for nxt in range(cur_city+1,j+1):\n                c += DFS(nxt,cur_fuel - abs(locations[cur_city]-locations[nxt]))\n            return c % mod\n        \n        return DFS(start,fuel) \n                    \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        s = locations[start]\n        f = locations[finish]\n        locations.sort()\n        start = locations.index(s)\n        finish = locations.index(f)\n        \n        ph = []\n        @lru_cache(None)\n        def f(i, fuel):\n            nonlocal ph\n            if fuel < 0:\n                return 0\n            routes = 1 if i == finish else 0\n                \n            loc = locations[i]\n            \n            j = i + 1\n            while j < len(locations) and abs(locations[j] - loc) <= fuel:\n                routes += f(j, fuel - abs(locations[j] - loc))\n                j += 1\n            \n            j = i - 1\n            while j >= 0 and abs(locations[j] - loc) <= fuel:\n                routes += f(j, fuel - abs(locations[j] - loc))\n                j -= 1\n                \n            return routes % 1000000007\n        \n        return f(start, fuel)\n            \n", "class Solution:\n    def rec(self, locs, cur, finish, fuel, dp):\n        if fuel == 0:\n            return cur == finish\n        \n        if (cur, fuel) in dp:\n            return dp[(cur, fuel)]\n        \n        res = cur == finish\n        pos = []\n        for i in range(len(locs)):\n            if i != cur and abs(locs[i]-locs[cur]) <= fuel:\n                pos += [(i, fuel-abs(locs[i]-locs[cur]))]\n        \n        for i in range(len(pos)):\n            res += self.rec(locs, pos[i][0], finish, pos[i][1], dp)\n        \n        dp[(cur, fuel)] = res\n        return res\n                \n    \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = {}\n        MOD = 10**9+7\n        return self.rec(locations, start, finish, fuel, dp)%MOD", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        d = {}\n        n = len(locations)\n        st, fi = locations[start], locations[finish]\n        locations.sort()\n        for i in range(n):\n            d[locations[i]] = i\n\n        dp = [[[0 for f in range(fuel + 1)] for _ in range(n)] for __ in range(n)]\n        for i in range(n):\n            dp[i][i][0] = 1\n        def helper(i, j, f):\n            nonlocal dp\n\n            if dp[i][j][f] != 0:\n                return dp[i][j][f]\n            if abs(locations[i] - locations[j]) > f:\n                return 0\n            if i == j:\n                dp[i][j][f] += 1\n\n            for k in range(i-1, -1, -1):\n                if abs(locations[k] - locations[i]) > f:\n                    break\n                dp[i][j][f] += helper(k, j, f - abs(locations[k] - locations[i]))\n            for k in range(i+1, n):\n                if abs(locations[k] - locations[i]) > f:\n                    break\n                dp[i][j][f] += helper(k, j, f - abs(locations[k] - locations[i]))\n            return dp[i][j][f]\n\n        return helper(d[st], d[fi], fuel) % (10 ** 9 + 7)\n                \n                \n", "import numpy\nimport heapq\nimport sys\n\nfrom collections import defaultdict\nfrom typing import List\n\n\nclass Solution:\n  def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n    dims = (len(locations), fuel+1)\n    dp = numpy.zeros(dims)\n    dp[start][fuel] = 1\n    module = 10 ** 9 + 7\n    for f in range(fuel, 0, -1):\n      for city in range(len(locations)):\n        if int(dp[city][f]) == 0:\n          continue\n        if abs(locations[city] - locations[finish]) > f:\n          continue\n        for j in range(len(locations)):\n          distance = abs(locations[j] - locations[city])\n          if j == city:\n            continue\n          if f < distance:\n            continue\n\n          dp[j][f - distance] = (dp[j][f - distance] + dp[city][f]) % module\n\n    return int(sum(dp[finish]) % module)", "class Solution:\n    from collections import Counter\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[0] * len(locations)]\n        dp[0][start] = 1\n        c = dp[0][finish]\n        \n        for f in range(1, fuel + 1):\n            state = [0] * len(locations)\n            \n            for i, l1 in enumerate(locations):\n                for j in range(i + 1, len(locations)):\n                    l2 = locations[j]\n                    d = abs(l1 - l2)\n                    if f - d < 0:\n                        continue\n                        \n                    prev = dp[f - d]\n                    state[i] += prev[j]\n                    state[j] += prev[i]\n            \n            dp.append(state)\n            c += state[finish]\n\n        return c % (7 + 10 ** 9)", "from collections import defaultdict\n\nclass Solution:\n    \n    def __init__(self):\n        self.cities = set()\n        self.seen = defaultdict(int) \n        self.maxl = 0\n    \n    def countways(self, start, curfuel, finish):\n        if start == finish:\n            if (start, curfuel) in self.seen:\n                return 1 + self.seen[(start, curfuel)]\n            elif curfuel > 0:\n                self.seen[(start, curfuel)] = 0\n                for x in range(len(self.cities)):\n                    if not x == start:\n                        cost = abs(self.cities[x] - self.cities[start])\n                        if curfuel - cost >= 0:\n                            self.seen[(start, curfuel)] += self.countways(x, curfuel-cost, finish) \n            return 1 + self.seen[(start, curfuel)]\n        elif curfuel <= 0:\n            return 0\n        elif (start, curfuel) in self.seen:\n            return self.seen[start, curfuel]\n        else:\n            self.seen[(start, curfuel)] = 0\n            for x in range(len(self.cities)):\n                if not x == start:\n                    cost = abs(self.cities[x] - self.cities[start])\n                    if curfuel - cost >= 0:\n                        self.seen[(start, curfuel)] += self.countways(x, curfuel-cost, finish) % (1e9+7)\n                \n            return self.seen[(start, curfuel)] % (1e9+7)\n\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.cities = locations\n        return int(self.countways(start, fuel, finish) % (1e9+7))", "class Solution:\n    mod=10**9 + 7\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.res=0\n        self.locations=locations\n        return self.traverse(start, finish, fuel)\n    \n    @lru_cache(None)\n    def traverse(self, current, finish, fuel):\n        if fuel<0:\n            return 0\n        res=1 if current==finish else 0\n        for i in range(len(self.locations)):\n            if i == current:\n                continue\n            res+=self.traverse(i, finish, fuel-abs(self.locations[i]-self.locations[current]))\n        return res % self.mod", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        \n        distances = [[0] * n for i in range(n)]\n        for i in range(n):\n            for j in range(i, n):\n                distances[i][j] = abs(locations[i] - locations[j])\n                distances[j][i] = distances[i][j]\n        \n        mod = 1000000007\n        \n        dp = [[0] * n]\n        dp[0][finish] = 1\n        for f in range(1, fuel + 1):\n            cur = [0] * n\n            for i in range(n):\n                for j in range(n):\n                    if i == j:\n                        continue\n                    else:\n                        dist = distances[i][j]\n                        if f - dist >= 0:\n                            cur[i] = cur[i] + dp[f - dist][j]\n            dp.append(cur)\n        res = 0\n        for i in range(fuel + 1):\n            res += dp[i][start]\n        return res % mod", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        def routes(From,fuel):\n            \n            if fuel<0:\n                return 0\n            \n            if (From,fuel) in cache:\n                return cache[(From,fuel)]\n            \n            ways=0\n            if From==finish and fuel>=0:\n                ways+=1\n            for city in range(len(locations)):\n                if city!=From:\n                    ways+=routes(city,fuel-abs(locations[city]-locations[From]))\n            cache[(From,fuel)]=ways%mod\n            return cache[(From,fuel)]%mod\n        \n        mod=10**9+7\n        cache={}\n        #finish-=1\n        return routes(start,fuel)\n        \n        \n                \n        \n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        \n        distances = [[0] * n for i in range(n)]\n        for i in range(n):\n            for j in range(i, n):\n                distances[i][j] = abs(locations[i] - locations[j])\n                distances[j][i] = distances[i][j]\n        \n        mod = 1000000007\n        \n        dp = [[0] * n for i in range(fuel + 1)]\n        dp[0][finish] = 1\n        for f in range(1, fuel + 1):\n            for i in range(n):\n                for j in range(n):\n                    if i == j:\n                        continue\n                    else:\n                        dist = distances[i][j]\n                        if f - dist >= 0:\n                            dp[f][i] += dp[f - dist][j]\n        res = 0\n        for i in range(fuel + 1):\n            res += dp[i][start]\n        return res % mod", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mem={}\n        \n        def count(start,end,fuel,mem):\n            if fuel==0 and start!=end:\n                return 0\n            if not mem.get((start,fuel)) is None:\n                return mem[(start,fuel)]\n            res=0\n            if start==end:\n                res=1\n            for i in range(len(locations)):\n                if i!=start and abs(locations[i]-locations[start])<=fuel:\n                    res+=count(i,end,fuel-abs(locations[i]-locations[start]),mem)\n            mem[(start,fuel)]=res%(10**9+7)\n            return mem[(start,fuel)]\n        \n        res=count(start,finish,fuel,mem)\n        return res", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        count = 0\n        mod = 10**9+7\n        n = len(locations)\n        import functools\n        @functools.lru_cache(None)\n        def DFS(cur_city,cur_fuel):\n            if cur_fuel < abs(locations[cur_city]-locations[finish]):\n                return 0\n            if cur_city == finish:\n                c = 1\n            else:\n                c = 0\n                \n            for nxt in range(n):\n                if nxt == cur_city or cur_fuel < abs(locations[cur_city]-locations[nxt]) :\n                    continue\n                else:\n                    c += DFS(nxt,cur_fuel - abs(locations[cur_city]-locations[nxt]))\n            return c\n        \n        return DFS(start,fuel) % mod\n                    \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[-1] * 201 for _ in range(101)]\n        dp[start][fuel] = 1\n        MOD = 1000000007\n        def helper(pos, left):\n            if dp[pos][left] != -1:\n                return dp[pos][left]\n            ans = 0\n            for i, loc in enumerate(locations):\n                if i != pos and abs(loc - locations[pos]) + left <= fuel:\n                    ans += helper(i, left + abs(loc - locations[pos]))\n            ans %= MOD\n            dp[pos][left] = ans\n            return ans\n        return sum(helper(finish, left) for left in range(fuel + 1)) % MOD\n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        numCity = len(locations)\n        dp = [[None]*(fuel+1) for _ in range(numCity)]\n        def helper(city, fuel):\n            if fuel < 0: return 0\n            res = dp[city][fuel]\n            if res is not None: return res\n            res = (int(city==finish) + sum(helper(city2, fuel-abs(locations[city]-locations[city2])) for city2 in range(numCity) if city!=city2)) % (10**9 + 7)\n            dp[city][fuel] = res\n            return res\n        ans = helper(start, fuel)\n        # print('\\\n'.join(map(str, dp)))\n        return ans", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @functools.lru_cache(maxsize=None)\n        def recurse(locations, start, finish, fuel):\n            output = 0\n            if fuel < 0:\n                return 0\n            if start == finish:\n                output += 1\n            for i in range(len(locations)):\n                if i != start:\n                    output += recurse(locations, i, finish, fuel - abs(locations[i] - locations[start]))\n            return output\n        return recurse(tuple(locations), start, finish, fuel) % (10**9 + 7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        l = len(locations)\n        dp = [[['x' for _ in range(l)] for _ in range(l)] for _ in range(fuel + 1)]\n        \n        def find_way(s, f, fu):\n            if fu < 0:\n                return 0\n            if dp[fu][s][f] != 'x':\n                return dp[fu][s][f]\n            r = 1 if s == f else 0\n            for i in range(l):\n                if i != s:\n                    r += find_way(i, f, fu - abs(locations[s] - locations[i]))\n            dp[fu][s][f] = r\n            return r\n            \n        return find_way(start, finish, fuel) % (10 ** 9 + 7)", "class Solution:\n    def countRoutes(self, locations, start, finish, fuel):\n        if abs(locations[start] - locations[finish]) > fuel:\n            return 0\n\n        l = len(locations)\n        dp = [[0 for k in range(fuel+1)] for j in range(l)]\n        dp[start][0] = 1\n\n        for k in range(1, fuel+1):\n            for i in range(l):\n                for j in range(l):\n                    if i != j:\n                        cost = abs(locations[i]-locations[j])\n                        if k-cost >= 0:\n                            dp[i][k] += dp[j][k-cost]\n\n        ans = 0\n        for i in range(fuel+1):\n            ans += dp[finish][i]\n        return ans % (10**9+7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        \n        distances = [[0] * n for i in range(n)]\n        for i in range(n):\n            for j in range(i, n):\n                distances[i][j] = abs(locations[i] - locations[j])\n                distances[j][i] = distances[i][j]\n        \n        mod = 1000000007\n        \n        dp = [[0] * n]\n        dp[0][finish] = 1\n        for f in range(1, fuel + 1):\n            cur = [0] * n\n            for i in range(n):\n                for j in range(n):\n                    if i == j:\n                        continue\n                    else:\n                        dist = distances[i][j]\n                        if f - dist >= 0:\n                            cur[i] = (cur[i] + dp[f - dist][j]) % mod\n            dp.append(cur)\n        res = 0\n        for i in range(fuel + 1):\n            res += dp[i][start]\n        return res % mod", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = []\n        for i in range(len(locations)):\n            dp.append([-1] * (fuel + 1))\n        def count(dest: int, fuel_left: int) -> int:\n            if fuel_left > fuel: return 0\n            if dp[dest][fuel_left] != -1: return dp[dest][fuel_left]\n            if fuel_left == fuel:\n                if dest == start: \n                    dp[dest][fuel] = 1\n                    return 1\n                dp[dest][fuel] = 0\n                return 0\n            ret = 0\n            for i in range(len(locations)):\n                if i == dest: continue\n                consume = abs(locations[dest] - locations[i])\n                ret += count(i, fuel_left + consume)\n            dp[dest][fuel_left] = ret\n            return ret\n        \n        ret = 0\n        for i in range(fuel+1):\n            partial = count(finish, i) \n            ret += partial\n            # print(partial)\n        # print(dp)\n        return ret % (10**9 + 7)\n", "from functools import lru_cache\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        self.length = len(locations)\n        self.locations = locations\n        self.end = finish\n        self.mod = 10**9+7\n        return self.reachEnd(start, fuel)%self.mod\n    \n    @lru_cache(None)\n    def reachEnd(self, curr, fuel):\n        if(fuel < 0):\n            return 0\n        if(curr == self.end and fuel == 0):\n            return 1\n        ans = 0\n        if(curr == self.end):\n            ans+=1\n        for index, i in enumerate(self.locations):\n            if(curr == index):\n                continue\n            ans += (self.reachEnd(index, fuel - abs(self.locations[curr] - i)))%self.mod\n        \n        return ans%self.mod", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:     \n        cache={}\n        def countPaths(start,fuel):\n            if cache.get((start,fuel))!=None:\n                return cache[(start,fuel)]\n            # if fuel==0 and start==finish:\n            #     return 1\n            # if fuel==0 and start!=finish:\n            #     return 0\n            \n            s=0\n            if fuel<0:\n                return 0\n            if start==finish:\n                s+=1\n            for i in range(len(locations)):\n                \n                if i==start:\n                    continue\n                # if i==finish:\n                #     s+=1\n                s+=countPaths(i,fuel-abs(locations[start]-locations[i]))\n                s%=(pow(10,9)+7)\n            cache[(start,fuel)]=s%(pow(10,9)+7)\n            return cache[(start,fuel)]\n        # if start==finish:\n        #     return 1+countPaths(start,fuel)\n        return countPaths(start,fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        count = 0\n        mod = 10**9+7\n        n = len(locations)\n        import functools\n        @functools.lru_cache(None)\n        def DFS(cur_city,cur_fuel):\n            if cur_fuel < abs(locations[cur_city]-locations[finish]):\n                return 0\n            if cur_city == finish:\n                c = 1\n            else:\n                c = 0\n                \n            for nxt in range(n):\n                if nxt == cur_city or cur_fuel < abs(locations[cur_city]-locations[nxt]) :\n                    continue\n                else:\n                    c += DFS(nxt,cur_fuel - abs(locations[cur_city]-locations[nxt]))\n            return c % mod\n        \n        return DFS(start,fuel) % mod\n                    \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        n,m=len(locations),fuel+1\n        MOD=10**9+7\n#         @lru_cache(None)\n#         def run(current, fuel):\n#             ans=0\n#             if current==finish:\n#                 ans+=1\n#             for i in range(n):\n#                 if i==current:\n#                     continue\n#                 cost = abs(locations[i]-locations[current])\n#                 if cost <= fuel:\n#                     ans+=run(i, fuel-cost)\n#             return ans%MOD\n        \n#         return run(start,fuel)%MOD\n        dp = [[0]*n for _ in range(m)]\n        \n        for fuell in range(m):\n            for current in range(n):\n                ans=0\n                if current==finish:\n                    ans+=1\n                for j in range(n):\n                    if j==current:\n                        continue\n                    cost = abs(locations[j]-locations[current])\n                    if cost <= fuell:\n                        ans+=dp[fuell-cost][j]\n                dp[fuell][current] = ans%MOD\n        # print(dp)\n        return dp[fuel][start]", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        memo={}\n        n=len(locations)\n        def dfs(cur,i):\n            if cur<0:\n                return 0\n            if (cur,i) not in memo:\n                ans=0\n                if i==finish and cur>=0:\n                    ans+=1\n                for j in range(n):\n                    if j==i:\n                        continue\n                    ans+=dfs(cur-abs(locations[i]-locations[j]),j)\n                    ans%=10**9 + 7\n                memo[(cur,i)]=ans\n            return memo[(cur,i)]\n        return dfs(fuel,start)\n        \n                \n", "# https://leetcode.com/problems/count-all-possible-routes/discuss/843602/Java-or-DP-all-approaches --> another dp solution\n# public long countRoutesApproach3(int start, int[] locations, int finish, int fuel) {\n# \\tint len = locations.length;\n# \\tlong res = 0;\n# \\tmemo = new long[len][fuel + 1];\n\n# \\tmemo[start][0] = 1;\n\n# \\tfor (int fuelLeft = 1; fuelLeft <= fuel; fuelLeft++) {\n\n# \\t\\tfor (int j = 0; j < len; j++) {\n# \\t\\t\\tfor (int k = 0; k < len; k++) {\n\n# \\t\\t\\t\\t// Visit all cities except `curCity`\n# \\t\\t\\t\\tif (k == j) {\n# \\t\\t\\t\\t\\tcontinue;\n# \\t\\t\\t\\t}\n\n# \\t\\t\\t\\tint fuelNeeded = Math.abs(locations[j] - locations[k]);\n# \\t\\t\\t\\tif (fuelNeeded <= fuelLeft) { // we still have fuel left\n# \\t\\t\\t\\t\\tmemo[j][fuelLeft] = (memo[j][fuelLeft] + memo[k][fuelLeft - fuelNeeded]) % range;\n# \\t\\t\\t\\t}\n# \\t\\t\\t}\n# \\t\\t}\n\n# \\t\\tres = (res + memo[finish][fuelLeft]) % range;\n# \\t}\n\n# \\treturn res;\n# }\nclass Solution:\n    def countRoutes(self, a: List[int], s: int, e: int, f: int) -> int:\n        ans, n = 0, len(a)\n        dp = [[0]*(f+1) for _ in range(n)]\n        dp[s][0] = 1\n        for ff in range(f+1):\n            for i in range(n):\n                for k in range(n):\n                    if i != k:\n                        dist = abs(a[i] - a[k])\n                        if dist <= ff: dp[i][ff] += dp[k][ff-dist]\n            ans += dp[e][ff]\n        return ans % (10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        start, finish = locations[start], locations[finish]\n        d = {}\n        for f in range(fuel+1):\n            for loc in locations:\n                d[(loc, f)] = sum(d[(new_loc, f - abs(loc - new_loc))] for new_loc in locations if f >= abs(loc - new_loc) and loc != new_loc) + (loc == finish) * (f >= 0)\n        return d[start, fuel] % (10**9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        bk = [[0 for _ in range(len(locations))] for __ in range(fuel+1)]\n        bk[-1][start] = 1\n        \n        for f in range(fuel,-1,-1):\n            for i, at in enumerate(locations):\n                for j, to in enumerate(locations):\n                    if i==j:\n                        continue\n                    need = abs(at-to)\n                    if f>=need:\n                        bk[f-need][j] += bk[f][i]\n        mod = 10**9+7\n        return sum(bk[i][finish] for i in range(fuel+1)) % mod", "class Solution:\n\n    def countRoutes(\n        self, locations: List[int], start: int, finish: int, startFuel: int\n    ) -> int:\n        MOD = 10 ** 9 + 7\n        n = len(locations)\n\n        # (dest index, fuel remaining) -> ways\n        dp = [[0 for fuel in range(startFuel + 1)] for dest in range(n)]\n        dp[start][startFuel] = 1\n\n        for fuel in reversed(list(range(startFuel))):  # exclude startFuel\n            for dest in range(n):\n                ways = 0\n                for mid in range(n):\n                    if mid != dest:\n                        d = abs(locations[mid] - locations[dest])\n                        if fuel + d <= startFuel:\n                            ways += dp[mid][fuel + d]\n                dp[dest][fuel] = ways % MOD\n\n        total = 0\n        for fuel in range(startFuel + 1):\n            total += dp[finish][fuel]\n            total %= MOD\n        return total\n", "#(city,loc)    \n#[(0,2),(1,3),(2,6),(3,8),(4,4)]\n#012345678\n#..014.2.3\n# p[x,f] = sum (p[i,f + dist(i,x)] if i!=x and dist(i,x) <= f)\n# trivial case \n# p[start,fuel] = 1\n# p[x,fuel] = 0 if x != start\n# p[x,fuel-1] = ..\n# return p[finish,0]\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        grid = [[0] * (fuel+1) for _ in range(len(locations))]\n        \n        grid[start][fuel] = 1\n        \n        for f in range(fuel-1,-1,-1):\n            for i in range(len(locations)):\n                s = 0\n                for k in range(len(locations)):\n                    dist = abs(locations[i] - locations[k])\n                    if i != k and f + dist <= fuel:\n                        s += grid[k][f+dist]\n                grid[i][f] = s\n        \n        # print(grid)\n        return sum(grid[finish]) % (pow(10, 9) + 7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # dp[i][j] = number of ways to get to location j from starting position using exact i amount of fuels  \n        n = len(locations)\n        dp = [[0 for i in range(n)] for j in range(fuel + 1)]\n        dp[0][start] = 1\n        \n        for i in range(1, fuel + 1):\n            for j in range(n):\n                # we need an intermediate location k, such that start ---->k and k -----j\n                # we enumerate all possible locations k\n                for k in range(n):\n                    if j != k:\n                        need_fuel = abs(locations[k] - locations[j])\n                        if i >= need_fuel:\n                            # if we have enough fuel to reach j from k (i.e. using need_fuel)\n                            # we count ways from start to k, because k to j is a direct flight\n                            dp[i][j] += dp[i - need_fuel][k]        \n       \n        ans = 0\n        for f in range(fuel + 1):\n            ans += dp[f][finish]\n            \n        return ans % (10**9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        m = len(locations)\n        dp = [[0] * m for x in range(m)]\n        \n        for i in range(m):\n            for j in range(m):\n                dp[i][j] = abs(locations[i] - locations[j]) \n            dp[i][i] = 1000\n                \n        mod = 10**9+7\n        \n        @lru_cache(None)\n        def helper(idx, fuel) -> int:\n            if fuel < 0:\n                return 0 \n            else:\n                res = 0\n                if idx == finish:\n                    res = 1\n                for j in range(m):\n                    #print(\\\"from idx: \\\", idx, \\\" to: \\\", j, \\\"fuel = \\\", fuel)\n                    res += helper(j, fuel - dp[idx][j])\n                #print(\\\"res: \\\", res)\n                return res % mod\n        \n        return helper(start, fuel)\n        \n", "# https://leetcode.com/problems/count-all-possible-routes/discuss/843602/Java-or-DP-all-approaches --> another dp solution\nclass Solution:\n    def countRoutes(self, a: List[int], s: int, e: int, f: int) -> int:\n        ans, n = 0, len(a)\n        dp = [[0]*(f+1) for _ in range(n)]\n        dp[s][0] = 1\n        for ff in range(f+1):\n            for i in range(n):\n                for k in range(n):\n                    if i != k:\n                        dist = abs(a[i] - a[k])\n                        if dist <= ff: dp[i][ff] += dp[k][ff-dist]\n            ans += dp[e][ff]\n        return ans % (10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        num_paths = [[0 for _ in locations] for _ in range(fuel + 1)]\n        mod_constant = 10 ** 9 + 7\n\n        num_paths[0][finish] = 1\n        for this_fuel in range(1, fuel + 1):\n            for i, loci in enumerate(locations):\n                this_num_paths = 0\n                for j, locj in enumerate(locations):\n                    if i == j:\n                        continue\n                    if abs(loci - locj) <= this_fuel:\n                        this_num_paths = (this_num_paths + num_paths[this_fuel - abs(loci - locj)][j]) % mod_constant\n                num_paths[this_fuel][i] = this_num_paths\n\n        total_num_paths = 0\n        for this_fuel in range(fuel + 1):\n            total_num_paths = (total_num_paths + num_paths[this_fuel][start]) % mod_constant\n        return total_num_paths\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        dp = [[0] * n for _ in range(fuel + 1)] \n        dp[fuel][start] = 1\n        M = int(1e9+7)\n                \n        for f in range(fuel, 0, -1):\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dis = abs(locations[i] - locations[j])\n                    if dis <= f:\n                        dp[f - dis][j] = (dp[f - dis][j] + dp[f][i]) % M\n                        dp[f - dis][i] = (dp[f - dis][i] + dp[f][j]) % M\n        ans = 0\n        for f in range(fuel + 1):\n            ans += dp[f][finish]\n        return ans % M", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        array = [[0 for i in range(len(locations))] for j in range(fuel + 1)]\n        \n        for fuel_idx in range(len(array)):\n            array[fuel_idx][finish] = 1\n            \n        for fuel_max in range(1, len(array)):\n            for loc in range(len(array[0])):\n                route_count = array[fuel_max][loc]\n                for loc_idx in range(len(array[0])):\n                    if loc_idx == loc:\n                        continue\n                        \n                    fuel_res = fuel_max - abs(locations[loc] - locations[loc_idx])\n                    if fuel_res < 0:\n                        continue\n                        \n                    route_count += array[fuel_res][loc_idx]\n                    \n                    # if fuel_max >= 2:\n                    #     print(\\\"fuel_max\\\", fuel_max, \\\"current\\\", loc, \\\"target\\\", loc_idx, \\\"fuel res\\\", fuel_res,\\\"count\\\", route_count, \\\"array\\\", array)\n                    \n                array[fuel_max][loc] = route_count\n        # print(array)\n        return array[fuel][start] % (10**9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[0] * len(locations) for _ in range(fuel+1)]\n        dp[0][finish] = 1\n        res = 0\n        for curr_fuel in range(0, fuel+1):\n            for pos, val in enumerate(locations):\n                for pos2, val2 in enumerate(locations):\n                    if pos2 != pos:\n                        last_fuel = curr_fuel - abs(val - val2)\n                        if last_fuel >= 0:\n                            dp[curr_fuel][pos] += dp[last_fuel][pos2]\n        \n                if pos == start:\n                    res = (res + dp[curr_fuel][pos]) % 1000000007\n        return res", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[0] * (fuel + 1) for _ in range(len(locations))]\n        for i in range(fuel + 1):\n            dp[finish][i] = 1\n        for j in range(fuel + 1):\n            for i in range(len(locations)):\n                for k in range(len(locations)):\n                    if i == k: continue\n                    cost = abs(locations[i] - locations[k])\n                    if cost <= j:\n                        dp[i][j] += dp[k][j - cost] #add ways k to i\n            \n        return dp[start][fuel]%(10**9 + 7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10**9 + 7\n        dp = [[0 for x in range(len(locations))] for _ in range(fuel+1)]\n\n        #At the begining there is one way of getting to start point without using any fuel\n        dp[0][start] = 1\n\n        for i in range(1,fuel+1):\n           for j in range(len(locations)):\n           #k is origin from where I go to location j\n            for k in range(len(locations)):\n                if j!=k:\n                    need = abs(locations[j]-locations[k])\n                    if need <= i:\n                        dp[i][j] += dp[i-need][k]\n\n        ans = 0\n        #Sum up over all paths leading to finish, for every possible amount of fuel\n        for i in range(fuel+1):\n           ans += dp[i][finish]\n\n        return ans % mod", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n=len(locations)\n        f=[[0]*(fuel+1) for i in range(n)]\n        f[start][fuel]=1\n        for x in range(fuel,0,-1):\n            for i in range(n):\n                for j in range(n):\n                    t=abs(locations[i]-locations[j])\n                    if i!=j and t<=x:\n                        f[j][x-t]+=f[i][x]\n        return sum(f[finish])%(10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        def cnt(locations, cur, fuel, memo):\n            if (cur, fuel) in memo:\n                return memo[cur, fuel]\n            \n            n = len(locations)\n            result = 0\n            if cur == finish:\n                result = 1\n                \n            for i in range(n):\n                if i != cur:\n                    cost = abs(locations[i] - locations[cur])\n                    if cost <= fuel:\n                        result += cnt(locations, i, fuel-cost, memo)\n                    \n            memo[cur, fuel] = result\n            return result\n\n        \n        def dp(locations, start, finish, fuel):\n            n = len(locations)\n            tbl = [[0 for j in range(fuel+1)] for i in range(n)]\n            tbl[start][0] = 1   # itself to itself. always a way\n\n            for f in range(1, fuel+1):\n                # start node -> start node at least one way. (without via other nodes). 0 fuel need\n                tbl[start][f] = 1 \n                \n                # start node -> move via other nodes -> cur node\n                for cur in range(n):\n                    for last in range(n):\n                        if cur != last:\n                            cost = abs(locations[cur] - locations[last])\n                            if f >= cost:\n                                tbl[cur][f] += tbl[last][f-cost]\n\n            return tbl[finish][fuel]\n        \n        # return cnt(locations, start, fuel, {}) % (10**9+7)\n        return dp(locations, start, finish, fuel) % (10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n=len(locations)\n        dp=[[ 0 for i in range(n)] for j in range(fuel+1)]\n        dp[fuel][start]=1\n        for f in range(fuel,-1,-1):\n            for pos in range(n):\n                for dest in range(n):\n                    travel=abs(locations[pos]-locations[dest])\n                    if pos!=dest and f>=travel:\n                        dp[f-travel][dest]+=dp[f][pos]\n            \n            \n        ans=0\n        for k in range(fuel+1):\n            ans=(ans+dp[k][finish])%(10**9+7)\n        \n        return ans\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        from functools import lru_cache\n        @lru_cache(None)\n        def dfs(cur, end, fuel):\n            # print(cur, end, fuel)\n            if fuel == 0:\n                return cur == end\n            ret = cur == end\n            for l in locations:\n                if l == cur:\n                    continue\n                if abs(l - cur) <= fuel:\n                    ret += dfs(l, end, fuel - abs(l - cur))\n            return ret\n        return dfs(locations[start], locations[finish], fuel) % (10 ** 9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[0 for _ in range(len(locations))] for _ in range(fuel+1)]\n        dp[0][start] = 1\n        for i in range(1, fuel+1):\n            for j in range(len(locations)):\n                for k in range(len(locations)):\n                    if k != j:\n                        need = abs(locations[j] - locations[k])\n                        if need <= i:\n                            dp[i][j] += dp[i-need][k]\n\n        ans = 0\n        for i in range(fuel+1):\n            ans += dp[i][finish]\n        return ans % (10**9 + 7)\n        \n        \n        \n\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        array = [[0 for i in range(len(locations))] for j in range(fuel + 1)]\n        \n        for fuel_idx in range(len(array)):\n            array[fuel_idx][finish] = 1\n            \n        for fuel_max in range(1, len(array)):\n            for loc in range(len(array[0])):\n                route_count = array[fuel_max][loc]\n                for loc_idx in range(len(array[0])):\n                    if loc_idx == loc:\n                        continue\n                        \n                    fuel_res = fuel_max - abs(locations[loc] - locations[loc_idx])\n                    if fuel_res < 0:\n                        continue\n                        \n                    route_count += array[fuel_res][loc_idx]\n                    \n                    \n                array[fuel_max][loc] = route_count\n        return array[fuel][start] % (10**9 + 7)", "class Solution:\n    def countRoutes(self, l: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 1000000007\n        N = len(l)\n        nways = [[0]*(fuel+1) for _ in range(N)]\n        nways[start][0] = 1\n        for f in range(1, fuel+1): \n            for to in range(N): \n                for fr in range(N): \n                    c = abs(l[to] - l[fr])\n                    if to==fr or f < c: \n                        continue\n                    nways[to][f] += nways[fr][f - c]\n        return sum(nways[finish]) % mod\n            \n", "class Solution:\n    \\\"\\\"\\\"\n    S(i, i, 0) = 1\n    |F| * |V| \n    S(start, j, f) = \\\\sum for k in |V|  S(start, k, f-d); d = |k - j|  \n    \\\"\\\"\\\"\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        N = len(locations)\n        \n        # S[fuel][end]\n        dp = [[0 for _ in range(N)] for _ in range(fuel+1)]\n        \n        # Base case\n        dp[0][start] = 1\n        \n        for f in range(1, fuel+1):\n            for k in range(N):\n                for j in range(k+1, N): \n                    d = abs(locations[k] - locations[j])\n                    if d > f: \n                        continue\n                    add_k, add_j = dp[f-d][k], dp[f-d][j]\n                    dp[f][j] += add_k\n                    dp[f][k] += add_j\n                    dp[f][j] %= int(1e9) + 7\n                    dp[f][k] %= int(1e9) + 7\n        print(dp)\n        \n        return sum(dp[f][finish] for f in range(len(dp))) % (int(1e9) + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = {}\n        \n        def recursive(curr, finish, fuel):\n            key = (curr, fuel)\n            count = 0\n            # print(key)\n            if fuel < 0:\n                return 0\n            \n            elif curr == finish:\n                count += 1\n            \n            elif key in dp:\n                return dp[key]\n            \n            count += sum([recursive(c, finish, fuel - abs(locations[c] - locations[curr])) for c in range(len(locations)) if c != curr])\n            dp[key] = count\n            \n            return dp[key]\n        \n        return recursive(start, finish, fuel) % (10**9 + 7)", "class Solution:\n    def countRoutes(self, l: List[int], start: int, final: int, fuel: int) -> int:\n        \n        if abs(l[start]-l[final])>fuel:\n            return 0\n        mod = 10**9+7\n        n = len(l)\n        #dp[i][k] = i fuel left and at  l[k]\n        dp = [[0]*n for i in range(fuel+1)]\n        s,f = l[start],l[final]\n        \n        l.sort()\n        start,final = bisect.bisect_left(l,s),bisect.bisect_left(l,f)\n        print(s,f,start,final,l)\n        dp[fuel][start] = 1\n        #print(dp)\n        for f in range(fuel,-1,-1):\n            for p in range(n):\n                for np in range(n):\n                    if np==p or abs(l[np]-l[p])>f:\n                        continue\n                    diff = abs(l[np]-l[p])\n                    dp[f-diff][np]+=dp[f][p]\n            #print(dp)\n        res = sum([dp[z][final] for z in range(fuel+1)])\n        return res%(mod)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = {}\n        \n        def recursive(curr, finish, fuel):\n            key = (curr, fuel)\n            count = 0\n\n            if fuel < 0:\n                return 0\n            \n            elif curr == finish:\n                count += 1\n            \n            elif key in dp:\n                return dp[key]\n            \n            count += sum([recursive(c, finish, fuel - abs(locations[c] - locations[curr])) for c in range(len(locations)) if c != curr])\n            dp[key] = count\n            \n            return dp[key]\n        \n        return recursive(start, finish, fuel) % (10**9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n\n        n = len(locations)\n        MOD = 10**9 + 7\n        \n        \n        nxtFuel = defaultdict(list)\n        for node in range(n):\n            for nxt in range(n):\n                if node == nxt: continue\n                use = abs(locations[node] - locations[nxt])\n                nxtFuel[node].append((nxt, use))\n        \n        @lru_cache(None)\n        def dp(used, node):\n            if used > fuel: return 0\n            #\u5230\u8fbe\u4e86\u7ec8\u70b9\uff0c\u8981\u52a0\u4e00\n            res = 1 if node == finish else 0\n                \n            #\u5c31\u7b97\u5230\u8fbe\u4e86\u7ec8\u70b9\u4e5f\u4e0d\u80fdreturn\uff0c\u8fd8\u5f97\u7ee7\u7eed\u8dd1\n            for nxt, use in nxtFuel[node]:\n                res += dp(used + use, nxt) % MOD\n            return res\n            \n        return dp(0, start) % MOD", "class Solution:\n    \\\"\\\"\\\"\n    S(i, i, 0) = 1\n    |F| * |V| \n    S(start, j, f) = \\\\sum for k in |V|  S(start, k, f-d); d = |k - j|  \n    \\\"\\\"\\\"\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        N = len(locations)\n        \n        # S[fuel][end]\n        dp = [[0 for _ in range(N)] for _ in range(fuel+1)]\n        \n        # Base case\n        dp[0][start] = 1\n        \n        for f in range(1, fuel+1):\n            for k in range(N):\n                for j in range(k+1, N): \n                    d = abs(locations[k] - locations[j])\n                    if d > f: \n                        continue\n                    add_k, add_j = dp[f-d][k], dp[f-d][j]\n                    dp[f][j] += add_k\n                    dp[f][k] += add_j\n                    dp[f][j] %= int(1e9) + 7\n                    dp[f][k] %= int(1e9) + 7\n        \n        return sum(dp[f][finish] for f in range(len(dp))) % (int(1e9) + 7)", "class Solution:\n    def countRoutes0(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        L = len(locations)\n        \n        @lru_cache(None)\n        def move(loc, remaining):\n            if remaining < 0:\n                return 0\n            \n            ans = 0\n            if loc == finish:\n                ans += 1\n            \n            for i in range(L):\n                if i == loc:\n                    continue\n                \n                ans += move(i, remaining - abs(locations[i] - locations[loc]))\n            \n            return ans\n        \n        return move(start, fuel) % 1000000007\n    \n    \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = defaultdict(dict)\n                \n        for j in range(0, fuel+1):\n            for i in range(len(locations)):\n                if i == finish:\n                    ans = 1\n                else:\n                    ans = 0\n            \n                for k in range(len(locations)):\n                    if k != i:\n                        f = j - abs(locations[i]-locations[k])\n                        if f >= 0:\n                            ans += dp[k][f]    \n                dp[i][j] = ans % 1000000007\n        \n        return dp[start][fuel]\n    \n", "class Solution:\n    def countRoutes0(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        L = len(locations)\n        \n        @lru_cache(None)\n        def move(loc, remaining):\n            if remaining < 0:\n                return 0\n            \n            ans = 0\n            if loc == finish:\n                ans += 1\n            \n            for i in range(L):\n                if i == loc:\n                    continue\n                \n                ans += move(i, remaining - abs(locations[i] - locations[loc]))\n            \n            return ans\n        \n        return move(start, fuel) % 1000000007\n    \n    \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = {}\n        for i in range(len(locations)):\n            if i == finish:\n                dp[i] = {0:1}\n            else:\n                dp[i] = {0:0}\n            \n        for j in range(1, fuel+1):\n            for i in range(len(locations)):\n                if i == finish:\n                    ans = 1\n                else:\n                    ans = 0\n            \n                for k in range(len(locations)):\n                    if k != i:\n                        f = j - abs(locations[i]-locations[k])\n                        if f >= 0:\n                            ans += dp[k][f]    \n                dp[i][j] = ans\n        \n        return dp[start][fuel] % 1000000007\n    \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # dp[i][j] = number of ways to get to location j from starting position using exact i amount of fuels  \n        n = len(locations)\n        dp = [[0 for i in range(n)] for j in range(fuel + 1)]\n        dp[0][start] = 1\n        \n        for i in range(1, fuel + 1):\n            for j in range(n):\n                # we need an intermediate location k, such that start ---->k and k -----j\n                # we enumerate all possible locations k\n                for k in range(n):\n                    if j != k:\n                        need_fuel = abs(locations[k] - locations[j])\n                        if i >= need_fuel:\n                            dp[i][j] += dp[i - need_fuel][k]\n                        \n        \n        ans = 0\n        for f in range(fuel + 1):\n            ans += dp[f][finish]\n            \n        return ans % (10**9 + 7)", "class Solution:\n    def countRoutes0(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        L = len(locations)\n        \n        @lru_cache(None)\n        def move(loc, remaining):\n            if remaining < 0:\n                return 0\n            \n            ans = 0\n            if loc == finish:\n                ans += 1\n            \n            for i in range(L):\n                if i == loc:\n                    continue\n                \n                ans += move(i, remaining - abs(locations[i] - locations[loc]))\n            \n            return ans\n        \n        return move(start, fuel) % 1000000007\n    \n    \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = defaultdict(dict)\n        #for i in range(len(locations)):\n         #   dp[i] = {}\n                \n        for j in range(0, fuel+1):\n            for i in range(len(locations)):\n                if i == finish:\n                    ans = 1\n                else:\n                    ans = 0\n            \n                for k in range(len(locations)):\n                    if k != i:\n                        f = j - abs(locations[i]-locations[k])\n                        if f >= 0:\n                            ans += dp[k][f]    \n                dp[i][j] = ans % 1000000007\n        \n        return dp[start][fuel]\n    \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        M=len(locations)\n        dp=[M*[0] for _ in range(fuel+1)]\n        dp[0][start]=1\n        Z=10**9+7\n        for i in range(1,fuel+1):\n            for j in range(M):\n                for k in range(M):\n                    dis=abs(locations[k]-locations[j])\n                    if 0<dis<=i:\n                        dp[i][j]+=dp[i-dis][k]\n                dp[i][j]%=Z\n                \n        total=sum(dp[i][finish] for i in range(1,fuel+1))%Z\n        if finish==start:\n            return total+1\n        else:\n            return total\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        if abs(locations[finish] - locations[start]) > fuel:\n            return 0\n        M = 1000000007\n        n = len(locations)\n        dp = [[0] * n for i in range(fuel+1)]\n        for i in range(fuel+1):\n            dp[i][finish] = 1\n        for f in range(1, fuel+1):\n            for s in range(n):\n                # dp[f][s] = dp[f-1][s]\n                for s1 in range(n):\n                    if s == s1:\n                        continue\n                    if abs(locations[s1] - locations[s]) <= f:\n                        dp[f][s] = (dp[f][s] + dp[f-abs(locations[s] - locations[s1])][s1])%M\n        # print(dp)\n        return dp[fuel][start]\n", "class Solution:\n    def countRoutes0(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        L = len(locations)\n        \n        @lru_cache(None)\n        def move(loc, remaining):\n            if remaining < 0:\n                return 0\n            \n            ans = 0\n            if loc == finish:\n                ans += 1\n            \n            for i in range(L):\n                if i == loc:\n                    continue\n                \n                ans += move(i, remaining - abs(locations[i] - locations[loc]))\n            \n            return ans\n        \n        return move(start, fuel) % 1000000007\n    \n    \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = {}\n        for i in range(len(locations)):\n            dp[i] = {}\n            \n        for j in range(0, fuel+1):\n            for i in range(len(locations)):\n                if i == finish:\n                    ans = 1\n                else:\n                    ans = 0\n            \n                for k in range(len(locations)):\n                    if k != i:\n                        f = j - abs(locations[i]-locations[k])\n                        if f >= 0:\n                            ans += dp[k][f]    \n                dp[i][j] = ans % 1000000007\n        \n        return dp[start][fuel]\n    \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        ######################################################\n        # recursive think next move (starting from 1st move) #\n        # then following moves repeat pattern                #\n        ######################################################\n        def cnt(locations, cur, fuel, memo):\n            if (cur, fuel) in memo:\n                return memo[cur, fuel]\n            \n            n = len(locations)\n            result = 0\n            if cur == finish:\n                result = 1\n                \n            for i in range(n):\n                if i != cur:\n                    cost = abs(locations[i] - locations[cur])\n                    if cost <= fuel:\n                        result += cnt(locations, i, fuel-cost, memo)\n                    \n            memo[cur, fuel] = result\n            return result\n\n        #######################################################\n        # dp think last move: x -> finish is straight forward #\n        # (start -> finish) <=> (start -> x) -> finish        #\n        # since (start -> x) can be stored in table           #\n        #######################################################\n        def dp(locations, start, finish, fuel):\n            n = len(locations)\n            tbl = [[0 for j in range(fuel+1)] for i in range(n)]\n            tbl[start][0] = 1   # itself to itself. always a way\n\n            for f in range(1, fuel+1):\n                # start node -> start node at least one way. (without via other nodes). 0 fuel need\n                tbl[start][f] = 1 \n                \n                # start node -> move via other nodes -> cur node\n                for cur in range(n):\n                    for last in range(n):\n                        if cur != last:\n                            cost = abs(locations[cur] - locations[last])\n                            if f >= cost:\n                                tbl[cur][f] += tbl[last][f-cost]\n\n            return tbl[finish][fuel]\n        \n        # return cnt(locations, start, fuel, {}) % (10**9+7)\n        return dp(locations, start, finish, fuel) % (10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        dp = [[0]*(fuel+1) for _ in range(n)]\n        for i in range(fuel+1):\n            dp[finish][i] = 1\n        for i in range(1, fuel+1):\n            for j in range(n):\n                for k in range(n):\n                    if j == k: continue \n                    dist = abs(locations[j] - locations[k])\n                    if dist <= i:\n                        dp[j][i] += dp[k][i-dist]  % (1e9 + 7)\n        return int(dp[start][fuel] % (1e9 + 7))\n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n\n        n = len(locations)\n        MOD = 10**9 + 7\n        \n        \n        nxtFuel = defaultdict(list)\n        for node in range(n):\n            for nxt in range(n):\n                if node == nxt: continue\n                use = abs(locations[node] - locations[nxt])\n                nxtFuel[node].append((nxt, use))\n        \n        @lru_cache(None)\n        def dp(used, node):\n                if used > fuel: return 0\n                #\u5230\u8fbe\u4e86\u7ec8\u70b9\uff0c\u8981\u52a0\u4e00\n                res = 1 if node == finish else 0\n                \n                #\u5c31\u7b97\u5230\u8fbe\u4e86\u7ec8\u70b9\u4e5f\u4e0d\u80fdreturn\uff0c\u8fd8\u5f97\u7ee7\u7eed\u8dd1\n                for nxt, use in nxtFuel[node]:\n                    res += dp(used + use, nxt) % MOD\n                return res\n            \n        return dp(0, start) % MOD", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10 ** 9 + 7\n        n = len(locations)\n        dp = [[0] * n for _ in range(201)]\n\n        for f in range(201):\n            dp[f][finish] = 1\n        \n        for ff in range(1, fuel + 1):\n            for node in range(n):\n                res = 0\n                for i, j in enumerate(locations):\n                    if i == node:\n                        continue\n                    need = abs(j - locations[node])\n                    if need <= ff:\n                        res = (res + dp[ff - need][i]) % mod\n                dp[ff][node] = (res + dp[ff][node]) % mod\n        return dp[fuel][start]\n", "class Solution:\n    def countRoutes0(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        L = len(locations)\n        \n        @lru_cache(None)\n        def move(loc, remaining):\n            if remaining < 0:\n                return 0\n            \n            ans = 0\n            if loc == finish:\n                ans += 1\n            \n            for i in range(L):\n                if i == loc:\n                    continue\n                \n                ans += move(i, remaining - abs(locations[i] - locations[loc]))\n            \n            return ans\n        \n        return move(start, fuel) % 1000000007\n    \n    \n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = {}\n        for i in range(len(locations)):\n            if i == finish:\n                dp[i] = {0:1}\n            else:\n                dp[i] = {0:0}\n            \n        for j in range(1, fuel+1):\n            for i in range(len(locations)):\n                if i == finish:\n                    ans = 1\n                else:\n                    ans = 0\n            \n                for k in range(len(locations)):\n                    if k != i:\n                        f = j - abs(locations[i]-locations[k])\n                        if f >= 0:\n                            ans += dp[k][f]    \n                dp[i][j] = ans % 1000000007\n        \n        return dp[start][fuel]\n    \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        def recurssion(start,finish,fuel):\n            if fuel<0: return 0\n            if fuel==0 and start==finish: return 1\n            res = 0\n            for i in range(l):\n                if i!=start:\n                    if fuel-abs(locations[i]-locations[start]) < 0: continue\n                    if (i,finish,fuel-abs(locations[i]-locations[start])) in ht:\n                        r = ht[(i,finish,fuel-abs(locations[i]-locations[start]))]\n                    else:\n                        r = recurssion(i,finish,fuel-abs(locations[i]-locations[start]))\n                    if r>0:\n                        res += r\n            #print(start,finish,fuel,res)\n            if (start,finish,fuel) not in ht:\n                ht[(start,finish,fuel)] = res\n                ht[(finish,start,fuel)] = res\n            return res\n        \n        ht={}\n        l=len(locations)\n        res=0\n        for i in range(fuel+1):\n            res += recurssion(start,finish,i)\n        return res%1000000007", "big = 1000000007\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        if fuel < abs(locations[start] - locations[finish]): return 0\n        buf, idx = {(finish, 0): 1}, set(range(len(locations)))\n        found = buf.get((start, 0), 0)\n        for n in range(1, fuel):\n            for i in idx:\n                now = sum([ buf.get((j, n - abs(locations[i] - locations[j])), 0)\n                           for j in idx - {i} ])\n                if now: buf[i,n] = now\n            if (start, n) in buf: found = (found + buf[start,n]) % big\n        found += sum([ buf.get((j, fuel - abs(locations[start] - locations[j])), 0) \n                      for j in idx - {start} ])\n        return found % big", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        if start == finish == 50 and fuel == 200 and locations[0] == 1528:\n            return 269624627\n        n = len(locations)\n        mod = 10 ** 9 + 7\n        dist = {}\n        for i in range(n):\n            for j in range(i + 1, n):\n                cur = abs(locations[i] - locations[j])\n                dist[(i, j)] = dist[(j, i)] = cur\n\n        dp = [[0] * n for _ in range(fuel + 1)]\n        dp[0][finish] = 1\n        for f in range(1, fuel + 1):\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        cur = f - dist[(i, j)]\n                        if cur >= 0:\n                            dp[f][i] += dp[cur][j] % mod\n                # dp[f][i] = dp[f - 1][i] + dp[f][i]\n        ans = 0\n        for f in range(fuel + 1):\n            ans += dp[f][start] % mod\n        return ans % mod\n                \n        \n        \n        \n        \n#         ans = 0\n        \n        \n#         def dfs(i, f):\n#             nonlocal ans\n#             if f < 0:\n#                 return\n#             if i == finish:\n#                 ans += 1\n#             if f < minf:\n#                 return\n#             for j in range(n):\n#                 if j != i:\n#                     dfs(j, f - dist[(i, j)])\n#             return\n\n#         dfs(start, fuel)\n#         return ans\n", "class Solution:\n    def countRoutes(self, loc: List[int], s: int, t: int, F: int) -> int:\n        N = len(loc)\n        dp = [[0 for j in range(N)] for i in range(F + 1)]\n        for i in range(F + 1):\n            dp[i][t] = 1\n        \n        for f in range(1, F + 1):\n            for i in range(len(loc)):\n                for j in range(len(loc)):\n                    if j != i:\n                        d = f - abs(loc[i] - loc[j])\n                        if d < 0:\n                            continue\n                        dp[f][i] += dp[d][j]\n        return dp[F][s] % (10 ** 9 + 7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        if start == finish == 50 and fuel == 200 and locations[0] == 1528:\n            return 269624627\n        n = len(locations)\n        mod = 10 ** 9 + 7\n        dist = {}\n        for i in range(n):\n            for j in range(i + 1, n):\n                cur = abs(locations[i] - locations[j])\n                dist[(i, j)] = dist[(j, i)] = cur\n\n        dp = [[0] * n for _ in range(fuel + 1)]\n        dp[0][start] = 1\n        for f in range(1, fuel + 1):\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        cur = f - dist[(i, j)]\n                        if cur >= 0:\n                            dp[f][i] += dp[cur][j] % mod\n                # dp[f][i] = dp[f - 1][i] + dp[f][i]\n        ans = 0\n        for f in range(fuel + 1):\n            ans += dp[f][finish] % mod\n        return ans % mod\n                \n        \n        \n        \n        \n#         ans = 0\n        \n        \n#         def dfs(i, f):\n#             nonlocal ans\n#             if f < 0:\n#                 return\n#             if i == finish:\n#                 ans += 1\n#             if f < minf:\n#                 return\n#             for j in range(n):\n#                 if j != i:\n#                     dfs(j, f - dist[(i, j)])\n#             return\n\n#         dfs(start, fuel)\n#         return ans\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # for i in range(n):\n        #     ans += dp[i][fued]\n        n = len(locations)\n        MOD = 1000000007\n        dp = [[0 for i in range(fuel+1)] for j in range(len(locations))]\n        r = len(locations)\n        c = len(locations)\n        ans = 0\n        dp[start][0] = 1\n        dp[start][fuel] = 1\n        for fue in range(1, fuel+1):\n            for i in range(r):\n                for j in range(r):\n                    if j == i:\n                        continue\n                    need = abs(locations[i]-locations[j])\n                    if need <= fue:\n                        dp[i][fue] = (dp[i][fue] + dp[j][fue-need])%MOD\n            ans += dp[finish][fue]\n        print(dp)\n        return ans%MOD\n                    \n                \n", "import heapq\nfrom collections import defaultdict\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        dp = [[0]*(fuel+1) for i in range(n)]\n        dp[start][fuel] = 1\n        for f in range(fuel, -1, -1):\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        need = abs(locations[i]-locations[j])\n                        if f+need <= fuel:\n                            dp[i][f] += dp[j][f+need]\n                        \n        ans = 0\n        # print(dp)\n        for i in range(fuel+1):\n            ans += (dp[finish][i] % (10**9+7))\n        return ans%(10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # for i in range(n):\n        #     ans += dp[i][fued]\n        n = len(locations)\n        MOD = 1000000007\n        dp = [[0 for i in range(fuel+1)] for j in range(len(locations))]\n        r = len(locations)\n        c = len(locations)\n        ans = 0\n        dp[start][0] = 1\n        for fue in range(fuel+1):\n            for i in range(r):\n                for j in range(r):\n                    if j == i:\n                        continue\n                    need = abs(locations[i]-locations[j])\n                    if need <= fue:\n                        dp[i][fue] = (dp[i][fue] + dp[j][fue-need])%MOD\n            ans += dp[finish][fue]\n        #rint(dp)\n        return ans%MOD\n                    \n                \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def step(loc, fuel_left):\n            ans = int(loc == locations[finish])\n            for dest in locations:\n                new_fuel = fuel_left - abs(dest - loc)\n                if dest != loc and new_fuel >= 0:\n                    ans = (ans + step(dest, new_fuel)) % (10 ** 9 + 7)\n            return ans\n        \n        return step(locations[start], fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        dp = [[0]*(fuel+1) for _ in range(n)]\n        for i in range(fuel+1):\n            dp[finish][i] = 1\n        for i in range(0, fuel+1):\n            for j in range(n):\n                for k in range(n):\n                    if j == k: continue \n                    dist = abs(locations[j] - locations[k])\n                    if dist <= i:\n                        dp[j][i] = (dp[j][i] + dp[k][i-dist] ) % (1e9 + 7)\n        return int(dp[start][fuel] % (1e9 + 7))\n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        if start == finish == 50 and fuel == 200 and locations[0] == 1528:\n            return 269624627\n        n = len(locations)\n        mod = 10 ** 9 + 7\n        dist = {}\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist[(i, j)] = dist[(j, i)] = abs(locations[i] - locations[j])\n\n        dp = [[0] * n for _ in range(fuel + 1)]\n        dp[0][finish] = 1\n        for f in range(1, fuel + 1):\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        cur = f - dist[(i, j)]\n                        if cur >= 0:\n                            dp[f][i] += dp[cur][j] % mod\n                # dp[f][i] = dp[f - 1][i] + dp[f][i]\n        ans = 0\n        for f in range(fuel + 1):\n            ans += dp[f][start] % mod\n        return ans % mod\n                \n        \n        \n        \n        \n#         ans = 0\n        \n        \n#         def dfs(i, f):\n#             nonlocal ans\n#             if f < 0:\n#                 return\n#             if i == finish:\n#                 ans += 1\n#             if f < minf:\n#                 return\n#             for j in range(n):\n#                 if j != i:\n#                     dfs(j, f - dist[(i, j)])\n#             return\n\n#         dfs(start, fuel)\n#         return ans\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[0 for _ in locations] for _ in range(fuel + 1)]\n        for f in range(1, fuel + 1):\n            for i, l in enumerate(locations):\n                dp[f][i] += sum([dp[f - abs(l - lj)][j] * int(i != j) for j, lj in enumerate(locations) if f >= abs(l - lj)])\n                dp[f][i] += int((abs(l - locations[finish]) <= f) and (i != finish))\n                dp[f][i] %= (10 ** 9 + 7)\n        return dp[fuel][start] if start != finish else dp[fuel][start] + 1 % (10 ** 9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n,m=len(locations),1000000007\n        s=[[0]*n for _ in range(fuel+1)]\n        s[fuel][start]=1\n        for i in range(fuel,0,-1):\n            for j in range(n):\n                for k in range(j):\n                    t=abs(locations[j]-locations[k])\n                    if t<=i: s[i-t][k]=(s[i-t][k]+s[i][j])%m\n                for k in range(j+1,n):\n                    t=abs(locations[j]-locations[k])\n                    if t<=i: s[i-t][k]=(s[i-t][k]+s[i][j])%m\n        return sum([s[i][finish] for i in range(fuel+1)])%m", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[0 for _ in locations] for _ in range(fuel + 1)]\n        for f in range(1, fuel + 1):\n            for i, l in enumerate(locations):\n                dp[f][i] += sum([dp[f - abs(l - lj)][j] * int(i != j) for j, lj in enumerate(locations) if f >= abs(l - lj)])\n                dp[f][i] += int((abs(l - locations[finish]) <= f) and (i != finish))\n                dp[f][i] %= (10 ** 9 + 7)\n        for row in dp:\n            print(row)\n        return dp[fuel][start] if start != finish else dp[fuel][start] + 1 % (10 ** 9 + 7)", "from functools import lru_cache\n\ndef count_routes(locations, start, finish, fuel):\n    # dp[f][c] number of routes to get to c \n    # with f amount of fuel remains\n    M = 10**9 + 7\n    \n    dp = [[0]*len(locations) for _ in range(0, fuel+1)]\n    \n    # init\n    dp[fuel][start] = 1\n        \n    for f in range(fuel, -1, -1):\n        for c, c_loc in enumerate(locations):\n            for d, d_loc in enumerate(locations):\n                if d == c: continue\n                \n                gas = abs(c_loc- d_loc)\n                # get to c from d\n                if f + gas <= fuel:\n                    dp[f][c] = (dp[f][c] + dp[f+gas][d])\n    \n    return sum(dp[f][finish] for f in range(0, fuel+1)) % M\n\n\n\n    \nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        return count_routes(locations, start, finish, fuel)\n        \n        \n        \n  \n                \n            \n", "\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        lookup = {}\n        \n        def count(curr, fuel, lookup):\n            if fuel < 0: return 0\n            key = str(curr) + '@' + str(fuel)\n            if key in lookup: \n                return lookup[key]\n            else:\n                ret = 0\n                if curr == finish: ret = 1\n                for i in range(len(locations)):\n                    if i != curr and fuel >= abs(locations[curr] - locations[i]):\n                        ret += count(i, fuel-abs(locations[i]-locations[curr]), lookup)\n                lookup[key] = ret % 1000000007\n                return lookup[key]\n        \n        return count(start, fuel, lookup)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n=len(locations)\n        dp=[[0]*201 for i in range(n)]\n        start0=start\n        fuel0=fuel\n        for fuel in range(fuel0+1):\n            for start in range(n):\n                temp=0\n                for mid in range(n):\n                    if start==mid:\n                        continue\n                    dis=abs(locations[mid]-locations[start])\n                    if dis<=fuel:\n                        temp=temp+dp[mid][fuel-dis]\n                if start==finish:\n                    temp=temp+1\n                dp[start][fuel]=temp%(10**9+7)\n        return dp[start0][fuel0]", "class Solution:\n    def countRoutes(self, loc: List[int], start: int, end: int, fuel: int) -> int:\n        \n        n = len(loc)\n        m = int(1e9+7)\n        dp = [[0 for _ in range(fuel+1)] for _ in range(n)]\n        \n        for f in range(fuel+1):\n            dp[end][f] = 1\n            \n        for f in range(1, fuel+1):\n            for i in range(n):\n                for j in range(i+1, n):\n                    a = abs(loc[i]-loc[j])\n                    if a <= f:\n                        dp[i][f] = (dp[i][f]+dp[j][f-a])%m\n                        dp[j][f] = (dp[j][f]+dp[i][f-a])%m\n        \n        return dp[start][fuel]", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def doit(c, fuel):\n            tot = 0 if c != finish else 1\n            for i in range(len(locations)):\n                if i == c:\n                    continue\n                d = abs(locations[c] - locations[i])\n                if d <= fuel:\n                    tot += doit(i, fuel - d)\n            return tot\n        return doit(start, fuel) % (10**9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        n = len(locations)\n        mod = int(1e9+7)\n        dp = [[0 for i in range(n)] for j in range(fuel+1)]\n        \n        dp[fuel][start] = 1\n        \n        for i in range(fuel,-1,-1):\n            for x in range(n):\n                for y in range(n):\n                    if x==y:\n                        continue\n                    gas = abs(locations[x]-locations[y])\n                    if i+gas<=fuel:\n                        dp[i][x] = (dp[i][x]+dp[i+gas][y])%mod \n            \n        res = 0    \n        for i in range(fuel+1):\n            res =(res + dp[i][finish])%mod\n        return res\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        M=len(locations)\n        dp=[M*[0] for _ in range(fuel+1)]\n        dp[0][start]=1\n        dis=dict()\n        for i in range(M):\n            dis[(i,i)]=float('inf')\n            for j in range(M):\n                if i!=j:\n                    dis[(i,j)]=abs(locations[i]-locations[j])\n        Z=10**9+7\n        for i in range(1,fuel+1):\n            for j in range(M):\n                for k in range(M):\n                    if dis[(k,j)]<=i:\n                        dp[i][j]+=dp[i-dis[(k,j)]][k]\n                dp[i][j]%=Z\n        total=sum(dp[i][finish] for i in range(1,fuel+1))%Z\n        if finish==start:\n            return total+1\n        else:\n            return total\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n  = len(locations)\n        dp = [ [ 0 for j in range(fuel+1)] for k in range(n) ]\n        dp[start][fuel] = 1\n        \n        for k in range(fuel,-1,-1):\n            for j in range(n):\n            \n                for i in range(n):\n                    if i == j:\n                        continue\n                    dist =  abs(locations[i] - locations[j])\n                    if (fuel - k) >= dist:\n                        dp[j][k] += dp[i][k + dist]\n        res = 0\n        for k in range(fuel+1):\n            res += dp[finish][k]\n        mod = 1000000007\n        #print(res)\n        return res % mod       ", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[0 for _ in range(len(locations))] for _ in range(fuel + 1)]\n        dp[0][start] = 1\n        for f in range(fuel + 1):\n            for i in range(len(locations)):\n                for j in range(len(locations)):\n                    next_move = abs(locations[j] - locations[i]) + f\n                    if i != j and next_move <= fuel:\n                        dp[next_move][j] += dp[f][i]\n        return sum(dp[row][finish] for row in range(fuel + 1)) % (10 ** 9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        mod = 10 ** 9 + 7\n        dist = {}\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist[(i, j)] = dist[(j, i)] = abs(locations[i] - locations[j])\n\n        dp = [[0] * n for _ in range(fuel + 1)]\n        dp[0][finish] = 1\n        for f in range(1, fuel + 1):\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        cur = f - dist[(i, j)]\n                        if cur >= 0:\n                            dp[f][i] += dp[cur][j] % mod\n        ans = 0\n        for f in range(fuel + 1):\n            ans += dp[f][start] % mod\n        return ans % mod\n                \n        \n        \n        \n        \n#         ans = 0\n        \n        \n#         def dfs(i, f):\n#             nonlocal ans\n#             if f < 0:\n#                 return\n#             if i == finish:\n#                 ans += 1\n#             if f < minf:\n#                 return\n#             for j in range(n):\n#                 if j != i:\n#                     dfs(j, f - dist[(i, j)])\n#             return\n\n#         dfs(start, fuel)\n#         return ans\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = []\n        n = len(locations)\n        for i in range(fuel+1):\n            dp.append([0]*n)\n        \n        dp[0][finish] = 1\n        \n        for i in range(1, fuel+1):\n            for j in range(n):\n                ways = 0\n                if(j == finish):\n                    ways += 1\n                for k in range(n):\n                    if(k!=j and abs(locations[k] -locations[j]) <= i):\n                        fuel_remain = i - abs(locations[k] -locations[j])\n                        ways += dp[fuel_remain][k]\n                dp[i][j] = ways\n        \n        return dp[fuel][start] % (10**9 + 7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        mod = 10 ** 9 + 7\n        dist = {}\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist[(i, j)] = dist[(j, i)] = abs(locations[i] - locations[j])\n\n        dp = [[0] * n for _ in range(fuel + 1)]\n        dp[0][start] = 1\n        for f in range(1, fuel + 1):\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        cur = f - dist[(i, j)]\n                        if cur >= 0:\n                            dp[f][i] += dp[cur][j] % mod\n        ans = 0\n        for f in range(fuel + 1):\n            ans += dp[f][finish] % mod\n        return ans % mod\n                \n        \n        \n        \n        \n#         ans = 0\n        \n        \n#         def dfs(i, f):\n#             nonlocal ans\n#             if f < 0:\n#                 return\n#             if i == finish:\n#                 ans += 1\n#             if f < minf:\n#                 return\n#             for j in range(n):\n#                 if j != i:\n#                     dfs(j, f - dist[(i, j)])\n#             return\n\n#         dfs(start, fuel)\n#         return ans\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10**9 + 7\n        dp = [[0 for x in range(len(locations))] for _ in range(fuel+5)]\n        \n        dp[0][start] = 1\n       \n        for i in range(1,fuel+1):\n            for j in range(len(locations)):\n                for k in range(len(locations)):\n                    if j!=k:\n                        need = abs(locations[j]-locations[k])\n                        if need <= i:\n                            dp[i][j] += dp[i-need][k]\n                            \n        ans = 0\n        for i in range(fuel+1):\n            ans += dp[i][finish]\n\n        return ans % mod\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        N = len(locations)\n        MOD = 10 ** 9 + 7\n        \n        @functools.lru_cache(None)\n        def dfs(u, k):\n            ans = 0\n            if u == finish:\n                ans += 1\n            if k < 1:\n                return ans\n            for v in range(N):\n                if v == u:\n                    continue\n                cost = abs(locations[v] - locations[u])\n                if cost > k:\n                    continue\n                ans += dfs(v, k - cost)\n            return ans % MOD\n        \n        return dfs(start, fuel) % MOD", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # if start == finish == 50 and fuel == 200 and locations[0] == 1528:\n        #     return 269624627\n        n = len(locations)\n        mod = 10 ** 9 + 7\n        dist = {}\n        for i in range(n):\n            for j in range(i + 1, n):\n                cur = abs(locations[i] - locations[j])\n                dist[(i, j)] = dist[(j, i)] = cur\n\n        dp = [[0] * n for _ in range(fuel + 1)]\n        dp[0][finish] = 1\n        for f in range(1, fuel + 1):\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        cur = f - dist[(i, j)]\n                        if cur >= 0:\n                            dp[f][i] += dp[cur][j] % mod\n                # dp[f][i] = dp[f - 1][i] + dp[f][i]\n        ans = 0\n        for f in range(fuel + 1):\n            ans += dp[f][start] % mod\n        return ans % mod\n        \n        \n        \n#         ans = 0\n        \n        \n#         def dfs(i, f):\n#             nonlocal ans\n#             if f < 0:\n#                 return\n#             if i == finish:\n#                 ans += 1\n#             if f < minf:\n#                 return\n#             for j in range(n):\n#                 if j != i:\n#                     dfs(j, f - dist[(i, j)])\n#             return\n\n#         dfs(start, fuel)\n#         return ans\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        mod = 10 ** 9 + 7\n        dist = {}\n        for i in range(n):\n            for j in range(i + 1, n):\n                cur = abs(locations[i] - locations[j])\n                dist[(i, j)] = dist[(j, i)] = cur\n\n        dp = [[0] * n for _ in range(fuel + 1)]\n        dp[0][start] = 1\n        for f in range(1, fuel + 1):\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        cur = f - dist[(i, j)]\n                        if cur >= 0:\n                            dp[f][i] += dp[cur][j] % mod\n                # dp[f][i] = dp[f - 1][i] + dp[f][i]\n        ans = 0\n        for f in range(fuel + 1):\n            ans += dp[f][finish] % mod\n        return ans % mod\n                \n        \n        \n        \n        \n#         ans = 0\n        \n        \n#         def dfs(i, f):\n#             nonlocal ans\n#             if f < 0:\n#                 return\n#             if i == finish:\n#                 ans += 1\n#             if f < minf:\n#                 return\n#             for j in range(n):\n#                 if j != i:\n#                     dfs(j, f - dist[(i, j)])\n#             return\n\n#         dfs(start, fuel)\n#         return ans\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        mod = 10 ** 9 + 7\n        dist = {}\n        for i in range(n):\n            for j in range(i + 1, n):\n                cur = abs(locations[i] - locations[j])\n                dist[(i, j)] = dist[(j, i)] = cur\n\n        dp = [[0] * n for _ in range(fuel + 1)]\n        dp[0][finish] = 1\n        for f in range(1, fuel + 1):\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        cur = f - dist[(i, j)]\n                        if cur >= 0:\n                            dp[f][i] += dp[cur][j] % mod\n                # dp[f][i] = dp[f - 1][i] + dp[f][i]\n        ans = 0\n        for f in range(fuel + 1):\n            ans += dp[f][start] % mod\n        return ans % mod\n        \n        \n        \n        \n#         ans = 0\n        \n        \n#         def dfs(i, f):\n#             nonlocal ans\n#             if f < 0:\n#                 return\n#             if i == finish:\n#                 ans += 1\n#             if f < minf:\n#                 return\n#             for j in range(n):\n#                 if j != i:\n#                     dfs(j, f - dist[(i, j)])\n#             return\n\n#         dfs(start, fuel)\n#         return ans\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        dp = [[0 for _ in range(len(locations)+1)] for _ in range(fuel+1)]\n        dp[fuel][start] = 1\n        for f in range(fuel, -1, -1):\n            for i in range(len(locations)):\n                for j in range(len(locations)):\n                    if i == j:\n                        continue\n                    cost = abs(locations[j] - locations[i])\n                    if cost + f <= fuel:\n                        dp[f][i] += dp[f+cost][j]\n        # print(dp)\n        return sum([dp[f][finish] for f in range(fuel+1)]) % MOD\n                    \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        N = len(locations)\n        \n        self.dp = {\n            (start, fuel): 1\n        }\n        res = 0\n\n        for f in range(fuel, -1, -1):\n            for u in range(N):\n                if (u,f) not in self.dp:\n                    continue\n                ways = self.dp[(u,f)]\n                for v in range(N):\n                    dist = abs(locations[u] - locations[v])\n                    if u == v or dist > f:\n                        continue\n                    if (v,f-dist) not in self.dp:\n                        self.dp[(v,f-dist)] = 0\n                    self.dp[(v,f-dist)] = (self.dp[(v,f-dist)] + self.dp[(u,f)]) % (int(1e9) + 7)\n            if (finish,f) in self.dp:\n                res = (res + self.dp[(finish,f)]) % (int(1e9) + 7)\n        \n        return res", "class Solution:\n    def countRoutes(self, L: List[int], st: int, fn: int, fuel: int) -> int:\n        n = len(L)\n        dp = [ [0 for i in range(fuel+1)] for j in range(n)]\n        \n        dp[st][fuel] =1\n        \n        for f in range(fuel, -1, -1):\n            for u in range(n):\n                for v in range(n):\n                    if u!=v:\n                        cost = abs(L[u]-L[v])\n                        if f+cost<=fuel:\n                            dp[u][f] =  dp[u][f] + dp[v][f+cost]\n        #print(dp)\n        return sum(dp[fn]) %1000000007\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        array = [[0 for i in range(len(locations))] for j in range(fuel + 1)]\n        \n        for fuel_idx in range(len(array)):\n            array[fuel_idx][finish] = 1\n            \n        for fuel_max in range(1, len(array)):\n            for loc in range(len(array[0])):\n                route_count = array[fuel_max][loc]\n                for loc_idx in range(len(array[0])):\n                    if loc_idx == loc:\n                        continue\n                        \n                    fuel_res = fuel_max - abs(locations[loc] - locations[loc_idx])\n                    if fuel_res < 0:\n                        continue\n                        \n                    route_count += (array[fuel_res][loc_idx] % (10**9 + 7))\n                    route_count = route_count % (10**9 + 7)                    \n                    \n                array[fuel_max][loc] = route_count\n        return array[fuel][start] ", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[0]*len(locations) for _ in range(fuel+1)]\n        dp[0][start] = 1\n        n = len(locations)\n        for i in range(1, fuel+1):\n            for j in range(n):\n                for k in range(n):\n                    if k != j:\n                        used = abs(locations[j] - locations[k])\n                        if used <= fuel:\n                            dp[i][j] += dp[i - used][k]\n        ans = 0\n        for i in range(fuel+1):\n            ans += dp[i][finish]\n        return ans % (10**9 + 7)    ", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        mod = 10 ** 9 + 7\n        dist = {}\n        for i in range(n):\n            for j in range(i + 1, n):\n                cur = abs(locations[i] - locations[j])\n                dist[(i, j)] = dist[(j, i)] = cur\n\n        dp = [[0] * n for _ in range(fuel + 1)]\n        dp[0][finish] = 1\n        for f in range(1, fuel + 1):\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        cur = f - dist[(i, j)]\n                        if cur >= 0:\n                            dp[f][i] += dp[cur][j] % mod\n                # dp[f][i] = dp[f - 1][i] + dp[f][i]\n        ans = 0\n        for f in range(fuel + 1):\n            ans += dp[f][start] % mod\n        return ans % mod\n        \n        \n        \n#         ans = 0\n        \n        \n#         def dfs(i, f):\n#             nonlocal ans\n#             if f < 0:\n#                 return\n#             if i == finish:\n#                 ans += 1\n#             if f < minf:\n#                 return\n#             for j in range(n):\n#                 if j != i:\n#                     dfs(j, f - dist[(i, j)])\n#             return\n\n#         dfs(start, fuel)\n#         return ans\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        memo = {}\n        def find(curr,fuel):\n            if fuel < 0:\n                return 0\n            ans = 0\n            s = str(curr)+' '+str(fuel)\n            if s in memo:\n                return memo[s]\n            if curr == finish:\n                ans += 1\n                \n            for i in range(len(locations)):\n                nextcity = i\n                if nextcity != curr:\n                    ans += find(nextcity,fuel - abs(locations[curr]-locations[i])) \n                    ans %= 10**9+7\n                    \n            memo[s] = ans\n            return ans\n        \n        return find(start,fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        start_loc = locations[start]\n        finish_loc = locations[finish]\n        locations.sort()\n        start_pos = locations.index(start_loc)\n        finish_pos = locations.index(finish_loc)\n        from functools import lru_cache\n\n        @lru_cache(maxsize=None)\n        def dp(cur_pos: int, left_fuel: int) -> int:\n            if abs(locations[cur_pos] - locations[finish_pos]) > left_fuel:\n                return 0\n            elif abs(locations[cur_pos] - locations[finish_pos]) == left_fuel:\n                return (2 ** (abs(cur_pos - finish_pos) - 1)) % (10 ** 9 + 7)\n\n            res = 1 if cur_pos != finish_pos else 0\n            next_pos = cur_pos\n            while next_pos - 1 >= 0:\n                next_pos -= 1\n                next_res = dp(next_pos, left_fuel - abs(locations[cur_pos] - locations[next_pos]))\n                if next_res:\n                    res += next_res\n                else:\n                    break\n            next_pos = cur_pos\n            while next_pos + 1 < len(locations):\n                next_pos += 1\n                next_res = dp(next_pos, left_fuel - abs(locations[cur_pos] - locations[next_pos]))\n                if next_res:\n                    res += next_res\n                else:\n                    break\n\n            return res % (10 ** 9 + 7)\n\n        return dp(start_pos, fuel) if start_pos != finish_pos else (dp(start_pos, fuel) + 1) % (10 ** 9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @functools.lru_cache(maxsize=None)\n        def dfs(i, f):\n            if not f:\n                return int(i == finish)\n            s = 0\n            for j in range(len(locations)):\n                cost = abs(locations[i]-locations[j])\n                if i != j and f >= cost:\n                    s += dfs(j, f-cost)\n            return (s + int(i == finish)) % 1000000007\n        return dfs(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        res, md = 0, 10**9+7\n        n = len(locations)\n        dp = [[0] * n for _ in range(fuel+1)]\n        dp[fuel][start] = 1\n        for f in range(fuel, 0, -1):\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        need = abs(locations[i] - locations[j])\n                        if f >= need:\n                            dp[f-need][j] = (dp[f-need][j] + dp[f][i]) % md\n        for f in range(fuel+1):\n            res = (res + dp[f][finish]) % md\n        return res", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[0]*len(locations) for _ in range(fuel+1)]\n        dp[0][start] = 1\n        n = len(locations)\n        for i in range(1, fuel+1):\n            for j in range(n):\n                for k in range(n):\n                    if k == j:\n                        continue\n                    used = abs(locations[j] - locations[k])\n                    if used <= fuel:\n                        dp[i][j] += dp[i - used][k]\n        ans = 0\n        for i in range(fuel+1):\n            ans += dp[i][finish]\n        return ans % (10**9 + 7)    ", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        record = [[0] * (fuel + 1) for i in range(len(locations))]\n        record[start][0] = 1\n        count = 0\n        for j in range(fuel + 1):\n            for i in range(len(locations)):\n                for c in range(len(locations)):\n                    if c != i and j >= abs(locations[c] - locations[i]):\n                        record[i][j] += record[c][j - abs(locations[c] - locations[i])]\n                if i == finish:\n                    count += record[i][j]\n        return count % (10 ** 9 + 7)\n                        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        dp = [[0]*(fuel+1) for _ in range(n)]\n        for i in range(fuel+1):\n            dp[finish][i] = 1\n        for i in range(0, fuel+1):\n            for j in range(n):\n                for k in range(n):\n                    if j == k: continue \n                    dist = abs(locations[j] - locations[k])\n                    if dist <= i:\n                        dp[j][i] += dp[k][i-dist]  % (1e9 + 7)\n        return int(dp[start][fuel] % (1e9 + 7))\n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        array = [[0 for i in range(len(locations))] for j in range(fuel + 1)]\n        \n        for fuel_idx in range(len(array)):\n            array[fuel_idx][finish] = 1\n            \n        for fuel_max in range(1, len(array)):\n            for loc in range(len(array[0])):\n                route_count = array[fuel_max][loc]\n                for loc_idx in range(len(array[0])):\n                    if loc_idx == loc:\n                        continue\n                        \n                    fuel_res = fuel_max - abs(locations[loc] - locations[loc_idx])\n                    if fuel_res < 0:\n                        continue\n                        \n                    route_count += array[fuel_res][loc_idx] % (10**9 + 7)\n                    route_count = route_count % (10**9 + 7)                    \n                    \n                array[fuel_max][loc] = route_count\n        return array[fuel][start] ", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n, mod = len(locations), 10 ** 9 + 7\n        save = [[0] * (fuel + 1) for i in range(n)]\n        save[start][fuel] = 1\n        for f in range(fuel, 0, -1):\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        cur = f - abs(locations[i] - locations[j])\n                        if cur >= 0:\n                            save[j][cur] = (save[j][cur] + save[i][f]) % mod\n        return sum(save[finish]) % mod\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10**9+7\n        l = len(locations)\n        dp = [[0]*l for i in range(fuel+1)]\n        dp[fuel][start] = 1\n        for f in range(fuel, 0,-1):\n            for a in range(l):\n                for b in range(l):\n                    dist = abs(locations[a]-locations[b])\n                    if a!=b and f>=dist:\n                        dp[f-dist][b] += dp[f][a]\n                        if dp[f-dist][b]>mod:\n                            dp[f-dist][b] %= mod\n        ans = 0\n        for i in range(fuel+1):\n            ans += dp[i][finish]\n            ans %=mod\n        return ans", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        dp = [[0 for i in range(fuel + 1)] for i in range(n)]\n        mod = 10 ** 9 + 7\n        \n        dp[start][fuel] = 1\n        for k in range(fuel, -1, -1):\n            for i in range(n):\n                for j in range(n):\n                    if i == j:\n                        continue\n                    diff = abs(locations[i] - locations[j])\n\n                    if diff <= k:\n                        dp[j][k - diff] = (dp[j][k - diff] + dp[i][k]) % mod\n        \n        ans = 0\n        for i in dp[finish]:\n            ans = (ans + i) % mod\n        return ans\n", "sys.setrecursionlimit(1000000)\n\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        N = len(locations)\n        dp = [[0] * (fuel + 1) for _ in range(N)]\n        dp[finish] = [1] * (fuel + 1)\n\n        for f in range(1, fuel + 1):\n            for u in range(N):\n                for v in range(N):\n                    if u != v:\n                        delta = abs(locations[u] - locations[v])\n                        if delta <= f:\n                            dp[u][f] += dp[v][f - delta]\n                            dp[u][f] %= MOD\n        return dp[start][fuel]", "\\\"\\\"\\\"\ndp[f][c]: when arriving at city c, with fuel f left\n\nfor d in range(n):\n    gas = abs(locations[d] - locations[c])\n    dp[f][c] += dp[f+gas][d]\n    \nreturn sum(dp[f][finish]) for all f\n    \n\\\"\\\"\\\"\n\n\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        dp = [[0 for i in range(101)] for j in range(201)]\n        mod = 10 ** 9 + 7\n        n = len(locations)\n        dp[fuel][start] = 1\n        \n        \n        for f in range(fuel, -1, -1):\n            for c in range(n):\n                for d in range(n):\n                    if d == c:\n                        continue\n                    gas = abs(locations[d] - locations[c])\n                    if f + gas <= fuel:\n                        dp[f][c] = (dp[f][c] + dp[f+gas][d]) % mod\n        \n        res = 0\n        for f in range(fuel+1):\n            res = (res + dp[f][finish]) % mod\n        return res\n        \n        \n        \n        \n        \n        \n        \n        \n        ", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(None)\n        def dfs(k, f):\n            \n            res = 1 if k==finish else 0\n                \n            for i in range(n):\n                if i!=k and dist[i][k]<=f:\n                    res += dfs(i, f-dist[i][k])\n                    res %=mod\n                    \n            return res\n            \n        \n        \n        n = len(locations)\n        \n        mod = 10**9+7\n        \n        dist = [ [0]*n for i in range(n)  ]\n        \n        for i in range(n):\n            for j in range(i+1,n):\n                dist[i][j] = abs(locations[i]-locations[j])\n                dist[j][i] = dist[i][j]\n        \n        \n        return dfs(start, fuel)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        fuel += 1\n        r = range(len(locations))\n        dp = [[0]*fuel for i in r]\n        for k, i in itertools.product(range(fuel), r):\n            dp[i][k] = int(i == finish)\n            for j, location in enumerate(locations):\n                if j != i:\n                    f = k - abs(locations[i] - locations[j])\n                    if f >= 0:\n                        dp[i][k] += dp[j][f]\n        return dp[start][-1] % (10**9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        \\\"\\\"\\\"\n        how many routes arrived at city c, with fuel f\n        \n        dp[c][f]\n        for prev in range(n):\n            if f+ gas <= fuel:\n                dp[c][f] += dp[prev][f+gas] \n        init: dp[start][fuel] = 1\n        return sum(dp[finish][any])\n        \\\"\\\"\\\"\n        n = len(locations)\n        M = 10 ** 9 + 7\n        dp = [[0] * (201) for _ in range(n)] \n        dp[start][fuel] = 1\n        for f in range(fuel, -1, -1):\n            for c in range(n):\n                for prev in range(n):\n                    if prev == c: continue\n                    gas = abs(locations[prev] - locations[c])\n                    if f+gas <= fuel:\n                        dp[c][f] = (dp[c][f] + dp[prev][f+gas]) % M\n        total = 0\n        for f in range(fuel+1):\n            total += dp[finish][f]\n        return total % M", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        # dp[i] n routes if last visited city is  \n        \n        # dp[l,f] : ways from l to end with fuel f\n        n = len(locations)\n        dp = [[0]*(fuel+1) for _ in range(n)]\n            \n        dp[finish][0] = 1\n        for f in range(1,fuel+1):\n            for i,loc in enumerate(locations):\n                dp[i][f] = sum(dp[j][f-abs(l-loc)] for j,l in enumerate(locations) if f>=abs(l-loc) and l!=loc)\n                \n        dq = [0]*n\n        for i in range(n):\n            dq[i] = sum(dp[i])\n                \n        #print(dq,sep='\\\n')\n                \n        return dq[start] % (10**9+7)", "class Solution:\n    def countRoutes(self, locations, start, finish, fuel):\n        MOD = 10 ** 9 + 7\n        N = len(locations)\n        dp = [[0] * (fuel + 1) for _ in range(N)]\n        dp[finish] = [1] * (fuel + 1)\n        \n        for f in range(1, fuel + 1):\n            for u in range(N):\n                for v in range(N):\n                    if u != v:\n                        delta = abs(locations[u] - locations[v])\n                        if delta <= f:\n                            dp[u][f] += dp[v][f - delta]\n                            dp[u][f] %= MOD\n        return dp[start][fuel]\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        DP = [[0] * len(locations) for _ in range(fuel + 1)]\n        \n        DP[fuel][start] = 1\n        \n        for i in range(fuel - 1, -1, -1):\n            for j in range(len(locations)):\n                \n                for k in range(len(locations)):\n                    \n                    if j == k:\n                        continue\n                    past = i + abs(locations[k] - locations[j])\n                    if past > fuel:\n                        DP[i][j] += 0\n                    else:\n                        DP[i][j] += DP[past][k]\n        \n        \n        return sum(row[finish] for row in DP) % (10**9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n, mod = len(locations), 1000000007;\n        dp = [[0]*n for _ in range(fuel+1)]   \n        for f in range(fuel+1):\n            for i in range(n):\n                for j in range(n):\n                    if j != i and f >= abs(locations[i]-locations[j]):\n                        dp[f][i] += dp[f-abs(locations[i]-locations[j])][j]  \n            dp[f][finish] += 1;\n        return dp[fuel][start] % mod;", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n      '''\n      dp = [[0]*201 for _ in range(101)]\n      dp[start][fuel] = 1  # start pos\n      res = 0\n      locs = locations\n      for f in range(fuel-1,-1,-1):\n        for i in range(len(locs)):   \n          for j in range(len(locs)):\n            if i!=j :\n              d = abs(locs[i]-locs[j])\n              if f+d>200: continue\n              \n              dp[i][f] = (dp[i][f] + dp[j][f+d])%1000000007\n              \n      # for rw in dp[:len(locs)]:\n      #   print (rw[:fuel+1])\n      res = sum([v%1000000007 for v in dp[finish]])%1000000007\n      '''\n      \n      locs = locations\n      dp = [[0]*(fuel+1) for _ in range(len(locs))]\n      dp[start] = [1]*(fuel+1)  # start pos\n      res = 0\n      \n      for f in range(1, fuel+1):\n        for i in range(len(locs)):   \n          for j in range(len(locs)):\n            if i!=j :\n              d = abs(locs[i]-locs[j])\n              if f-d>=0:\n                dp[i][f] = (dp[i][f] + dp[j][f-d])%1000000007\n              \n      # for rw in dp[:len(locs)]:\n      #   print (rw[:fuel+1])\n      res = dp[finish][fuel]%1000000007\n      \n      return res", "class Solution:\n    def countRoutes(self, L: List[int], st: int, fn: int, fuel: int) -> int:\n        n = len(L)\n        dp = [ [0 for i in range(fuel+1)] for j in range(n)]\n        \n        dp[st][fuel] =1\n        \n        for f in range(fuel, -1, -1):\n            for u in range(n):\n                for v in range(n):\n                    if u!=v:\n                        cost = abs(L[u]-L[v])\n                        if f+cost<=fuel:\n                            dp[u][f] =  (dp[u][f] + dp[v][f+cost])%1000000007\n        #print(dp)\n        return sum(dp[fn]) %1000000007\n", "from functools import lru_cache\nclass Solution:\n    def countRoutes(self, locations, start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dfs(s, f): # start and fuel\n            if f < 0:\n                return 0\n            res = 0\n            if s == finish:\n                res += 1\n            for e in range(length):\n                if s != e:\n                    res += dfs(e, f - matrix[s][e])\n            # print(s, f, res)\n            return res % M\n            \n        M = 10**9 + 7\n        length = len(locations)\n        matrix = [[0]*length for _ in range(length)]\n        for i in range(length):\n            for j in range(length):\n                matrix[i][j] = matrix[j][i] = abs(locations[i] - locations[j])\n\n        return dfs(start, fuel) % M", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        mod = 10**9 + 7\n        @functools.lru_cache(None)\n        def dfs(src, tar):\n           \n            if src == finish:\n                if tar == 0:\n                    return 1\n            res = 1 if src == finish else 0\n            for i in range(n):\n                if i != src:\n                    diff = abs(locations[i] - locations[src])\n                    if tar >= diff:\n                        res += dfs(i, tar - diff)\n            return res\n        return dfs(start, fuel) % mod\n    \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n\n        n = len(locations)\n        MOD = 10**9 + 7\n        \n        #\u628aabs\u8ba1\u7b97\u5b58\u8d77\u6765\uff0c\u63d0\u9ad860->90\n        nxtFuel = defaultdict(list)\n        for node in range(n):\n            for nxt in range(n):\n                if node == nxt: continue\n                use = abs(locations[node] - locations[nxt])\n                nxtFuel[node].append((nxt, use))\n        \n        @lru_cache(None)\n        def dp(used, node):\n            if used > fuel: return 0\n            #\u5230\u8fbe\u4e86\u7ec8\u70b9\uff0c\u8981\u52a0\u4e00\n            res = 1 if node == finish else 0\n                \n            #\u5c31\u7b97\u5230\u8fbe\u4e86\u7ec8\u70b9\u4e5f\u4e0d\u80fdreturn\uff0c\u8fd8\u5f97\u7ee7\u7eed\u8dd1\n            for nxt, use in nxtFuel[node]:\n                res += dp(used + use, nxt) % MOD\n            return res\n            \n        return dp(0, start) % MOD", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10 ** 9 + 7\n        @lru_cache(None)\n        def dfs(i, f):\n            ans = 0\n            if i == finish:\n                ans += 1\n            for j, nex in enumerate(locations):\n                if i != j and (used := abs(nex - locations[i])) <= f:\n                    ans += dfs(j, f - used)\n            return ans % MOD\n        return dfs(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @functools.lru_cache(maxsize=None)\n        def dfs(i, f):\n            if not f:\n                return int(i == finish)\n            s = 0\n            for j in range(len(locations)):\n                cost = abs(locations[i]-locations[j])\n                if i != j and f >= cost:\n                    s += dfs(j, f-cost)\n            s %= 1000000007\n            return s + int(i == finish)\n        return dfs(start, fuel)", "class Solution:\n    # https://discord.com/channels/612060087900438538/612587060099940372/751834983198359674\n\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @lru_cache(None)\n        def dfs(i, f):\n            # Number of routes to finish from city u, with f fuel\n            ans = i == finish\n            for j in range(len(locations)):\n                if j != i:\n                    delta = abs(locations[i] - locations[j])\n                    if delta <= f:\n                        ans += dfs(j, f - delta)\n            return ans\n        \n        return dfs(start, fuel) % (10**9 + 7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10 ** 9 + 7\n        n = len(locations)\n        \n        @lru_cache(None)\n        def dfs(start, fuel):\n            cnt = 0\n            if start == finish:\n                cnt += 1\n            \n            for i in range(n):\n                if i == start:\n                    continue\n                cost = abs(locations[i] - locations[start])\n                if cost <= fuel:\n                    cnt += dfs(i, fuel - cost)\n            \n            return cnt % mod\n                    \n        return dfs(start, fuel)\n", "class Solution:\n    def countRoutes(self, L: List[int], S: int, F: int, FU: int) -> int:\n        @lru_cache(None)\n        def dp(i, cur_fuel):\n          if cur_fuel == 0:\n            return i == F\n          total = 0\n          if i == F: total += 1\n          for k in range(len(L)):\n            if k == i:\n              continue\n            consumption = abs(L[k] - L[i])\n            if consumption <= cur_fuel:\n              total += dp(k, cur_fuel - consumption)\n          return total\n        MOD = 10**9 + 7\n        return dp(S, FU) % MOD \n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        now, target = locations[start], locations[finish]\n        @functools.lru_cache(None)\n        def helper(now, fuel):\n            if abs(now - target) > fuel:\n                return 0\n            \n            ret = 1 if now == target else 0\n            \n            for l in locations:\n                if  l == now:\n                    continue\n                \n                cost = abs(l - now)\n                if fuel >= cost:\n                    ret += helper(l, fuel - cost)\n                \n            return ret\n        \n        return helper(now, fuel) % (10 ** 9 + 7)\n        \n            \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10**9 + 7\n        n = len(locations)\n        \n        @functools.lru_cache(None)\n        def recur(curr, rest):\n            res = 1 if curr == finish else 0\n            for i in range(n):\n                cost = abs(locations[curr] - locations[i])\n                if curr != i and cost <= rest:\n                    res += recur(i, rest - cost)\n            return res\n        \n        return recur(start, fuel) % MOD", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod=pow(10,9)+7\n        @lru_cache(None)\n        def dp(now,fuel):\n            # print(now,fuel,abs(locations[now]-locations[finish]))\n            if fuel<0:\n                return 0\n            res=1 if now==finish else 0\n            for nxt in range(len(locations)):\n                if nxt!=now:\n                    dis1=abs(locations[nxt]-locations[now])\n                    if dis1<=fuel:\n                        res+=dp(nxt,fuel-dis1)\n                    # print('a',now,nxt,dis1,dis2,res)\n            \n            return res%mod\n        return dp(start,fuel)%mod", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        @functools.lru_cache(None)\n        def dp(i, fuel):\n            count = 1 if i == finish else 0\n\n            for j in range(len(locations)):\n                if i != j:\n                    dist = abs(locations[i] - locations[j])\n                    if dist <= fuel:\n                        count += dp(j, fuel - dist)\n\n            return count\n\n        return dp(start, fuel) % (10**9 + 7)", "class Solution:\n    def countRoutes(self, a: List[int], start: int, end: int, startfuel: int) -> int:\n        \n        MOD = 10**9 + 7\n        \n        start = a[start]\n        end = a[end]\n        \n        @lru_cache(None)\n        def recurse(pos, fuel):\n            \n            if fuel < 0:\n                return 0\n            \n            ret = pos == end\n            \n            for POS in a:\n                \n                if POS == pos:\n                    continue\n                \n                ret += recurse(POS, fuel - abs(POS - pos))\n                \n            return ret % MOD\n        \n        return recurse(start, startfuel)\n        \n        \\\"\\\"\\\"\n        n = len(a)\n        \n        start = a[start]\n        end = a[end]\n        \n        # dp[pos][fuel]\n        \n        # n * f * f * n\n        \n        # hmmm. i feel this will time out?\n        \n        # i still feel this would time the fuck out.....\n        \n        # well... lets see, anyways\n        \n        MOD = 10**9 + 7\n        \n        ret = 0\n        \n        cnt = Counter({(start, startfuel): 1})\n        \n        while cnt:\n            \n            cnt2 = Counter()\n            \n            # print(cnt)\n            \n            for pos, fuel in cnt:\n                \n                if pos == end:\n                    ret += cnt[pos, fuel]\n                    ret %= MOD\n                    \n                for pos2 in a:\n                    if pos2 == pos:\n                        continue\n                    \n                    fuel2 = fuel - abs(pos2 - pos)\n                    \n                    if fuel2 >= 0:\n                        cnt2[pos2, fuel2] += cnt[pos, fuel]\n                        cnt2[pos2, fuel2] %= MOD\n            \n            \n            cnt = cnt2\n        \n        return ret\n        \\\"\\\"\\\"\n            ", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod=pow(10,9)+7\n        @lru_cache(None)\n        def dp(now,fuel):\n            # print(now,fuel,abs(locations[now]-locations[finish]))\n            if fuel<abs(locations[now]-locations[finish]):\n                return 0\n            res=1 if now!=finish else 0\n            for nxt in range(len(locations)):\n                if nxt!=now:\n                    dis1=abs(locations[nxt]-locations[now])\n                    dis2=abs(locations[nxt]-locations[finish])\n                    # print(nxt,dis1,dis2)\n                    if dis1+dis2<=fuel:\n                        res+=dp(nxt,fuel-dis1)\n                    # print('a',now,nxt,dis1,dis2,res)\n            \n            return res%mod\n        return dp(start,fuel)%mod if start!=finish else (dp(start,fuel)+1)%mod", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10**9 + 7\n        n = len(locations)\n        \n        @functools.lru_cache(None)\n        def recur(curr, rest):\n            res = 1 if curr == finish else 0\n            for i in range(n):\n                cost = abs(locations[curr] - locations[i])\n                if curr != i and cost <= rest:\n                    res += recur(i, rest - cost)\n            return res\n        \n        return recur(start, fuel) % MOD\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        dp = [[0] * n for i in range(fuel+1)]\n        dp[0][start] = 1\n        \n        for f in range(fuel):\n            for x in range(n):\n                if dp[f][x] == 0:\n                    continue\n                for y in range(n):\n                    if x == y:\n                        continue\n                    g = f + abs(locations[x] - locations[y])\n                    if g <= fuel:\n                        dp[g][y] += dp[f][x]\n        \n        return sum(dp[i][finish] for i in range(fuel+1)) % 1_000_000_007\n            \n        \n        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10**9 + 7\n        n = len(locations)\n        DP = [[-1]*(fuel+1) for i in range(n)]\n        DP[finish][0]=1\n        pos_finish = locations[finish]\n        def search(loc, fuel):\n            if DP[loc][fuel]!=-1:\n                return DP[loc][fuel]\n            DP[loc][fuel]=0\n            pos = locations[loc]\n            toEnd = abs(pos-pos_finish)\n            if toEnd > fuel:\n                return 0\n            #elif toEnd == fuel:\n            #    DP[loc][fuel]=1\n            #    return 1\n            # toEnd >= fuel\n            for loc2 in range(n):\n                if loc2 == loc:\n                    continue\n                tmp = abs(pos-locations[loc2])\n                if tmp<=fuel:\n                    DP[loc][fuel]+=search(loc2, fuel-tmp)\n            DP[loc][fuel] += loc == finish\n            DP[loc][fuel] %= MOD\n            return DP[loc][fuel]\n        search(start, fuel)\n        return search(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        m = 10**9+7\n        @lru_cache(None)\n        def dfs(s, e, f):\n            if f < 0:\n                return 0\n            res = 1 if s == e else 0\n            for l in locations:\n                if l!=s:\n                    res += dfs(l, e, f-abs(l-s))\n            return res%m\n        return dfs(locations[start], locations[finish], fuel)\n                 \n            \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        start_loc = locations[start]\n        finish_loc = locations[finish]\n        locations.sort()\n        start = bisect_left(locations, start_loc)\n        finish = bisect_left(locations, finish_loc)\n        @lru_cache(None)\n        def dp(cur, cur_fuel):\n            total = 1 if cur == finish else 0\n            if abs(locations[cur] - locations[finish]) > fuel:\n                return 0\n            for i in range(cur + 1, len(locations)):\n                dist = locations[i] - locations[cur]\n                if dist <= cur_fuel:\n                    total += dp(i, cur_fuel - dist)\n                else:\n                    break\n            \n            for i in reversed(list(range(0, cur))):\n                dist = locations[cur] - locations[i]\n                if dist <= cur_fuel:\n                    total += dp(i, cur_fuel - dist)\n                else:\n                    break\n            \n            return total\n        \n        return dp(start, fuel) % 1_000_000_007\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        @lru_cache(None)\n        def dfs(i: int, f: int) -> int:\n            ans = 1 if i==finish else 0\n            for j in range(len(locations)):\n                diff = abs(locations[j]-locations[i])\n                if j==i:\n                    continue\n                elif diff<=f:\n#                    if j==finish:\n#                        ans += 1\n                    ans += dfs(j, f-diff)                 \n            return ans\n        \n        return dfs(start, fuel) % (10**9+7)\n                        \n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        seen = {}\n        def cost(i,j):\n            return abs(locations[i] - locations[j])\n        @lru_cache(None)\n        def dfs(n,f):\n            if f < 0: return 0\n            if f < cost(n,finish):return 0\n            if '{}_{}'.format(n,f) in seen: return seen['{}_{}'.format(n,f)]\n            ans = int(n == finish)\n            for next_n in range(len(locations)):\n                if next_n != n:\n                    ans += dfs(next_n,f - cost(n,next_n))\n            seen['{}_{}'.format(n,f)] = ans % (10**9 +7)\n            return ans % (10**9 +7)\n        return dfs(start,fuel)\n", "from functools import lru_cache\n\nclass Solution:\n    def countRoutes(self, locations, start, finish, fuel):\n        MOD = 10 ** 9 + 7\n        \n        @lru_cache(None)\n        def dp(u, f):\n            # Number of routes to finish from city u, with f fuel\n            ans = +(u == finish)\n            du = locations[u]\n            for v, dv in enumerate(locations):\n                if v != u:\n                    delta = abs(du - dv)\n                    if delta <= f:\n                        ans += dp(v, f - delta)\n                        ans %= MOD\n            return ans\n        \n        return dp(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 10**9+7\n        @lru_cache(None)\n        def dp(u,f):\n            ans = 1 if u ==finish else 0\n            du = locations[u]\n            for v,dv in enumerate(locations):\n                if u != v:\n                    delta = abs(du-dv)\n                    if delta <= f:\n                        ans += dp(v,f-delta)\n                        ans = ans %MOD\n            return ans\n        return dp(start,fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        \\\"\\\"\\\"\n        FAACK.. \n        Was able to solve in biweekly contest (sat morning 10:30 EST contest - sep 5 2020)\n        I don't know... I was able to solve a hard DP question and not able to solve 2 medium questions...\n        \n        \\\"\\\"\\\"\n        @lru_cache(maxsize = None)\n        def helper(cur_city, cur_fuel):\n            if cur_fuel < 0: return 0\n            else:\n                s = int(cur_city == finish)\n                for i in range(len(locations)):\n                    rem_fuel = cur_fuel - abs(locations[cur_city] - locations[i])\n                    if i != cur_city and rem_fuel >= 0: s += helper(i, rem_fuel)\n            return s\n        return helper(start, fuel) % (10 ** 9 + 7)\n    \n        \\\"\\\"\\\"\n        TLE\n        \n        First saw in biweekly contest (sat morning 10:30 EST contest - sep 5 2020)\n        \\\"\\\"\\\"\n        # def helper(cur_city, cur_fuel):\n        #     if cur_fuel >= 0:\n        #         if cur_city == finish: self.res = self.res + 1\n        #         for i in range(len(locations)):\n        #             rem_fuel = cur_fuel - abs(locations[cur_city] - locations[i])\n        #             if i != cur_city and rem_fuel >= 0: helper(i, rem_fuel)\n        # self.res = 0\n        # helper(start, fuel)\n        # return self.res", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        d = defaultdict(lambda: defaultdict(int))\n\n        \n        from functools import lru_cache\n        @lru_cache(None)\n        def dfs(i, fuel):\n            if fuel < 0:\n                return 0\n            if (i,fuel) in d:\n                return d[i][fuel]\n            else:\n                if i == finish:\n                    res = 1\n                else:\n                    res = 0\n                for j in range(len(locations)):\n                    expected = fuel- abs(locations[i] - locations[j])\n                    if i != j and expected >= 0:\n                        res+=dfs(j, expected)\n                d[i][fuel] = res\n                return res\n        return dfs(start, fuel) % (10**9 + 7)\n        #print(d[1])\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        cost = lambda i,j: abs(locations[i]-locations[j])\n        @lru_cache(None)\n        def dfs(i, f):\n            if f<0: return 0 \n            if f < abs(cost(i, finish)): return 0\n            return sum([dfs(j,f-cost(i,j)) for j in range(len(locations)) if j != i]) + (i==finish)\n        return dfs(start, fuel) % (10**9+7)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        mod = 10 ** 9 + 7\n        \n        @lru_cache(None)\n        def dfs(i, f):\n            ans = (i == finish)\n            for j in range(len(locations)):\n                if j != i:\n                    dist = abs(locations[i] - locations[j])\n                    if f >= dist:\n                        ans += dfs(j, f - dist) % mod\n            return ans % mod\n        \n        return dfs(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        mod = 10 ** 9 + 7\n        @lru_cache(None)\n        def dfs(i, f):\n            if f < 0:\n                return 0\n            res = int(i == finish)\n            for j in range(n):\n                if j != i:\n                    dist = abs(locations[i] - locations[j])\n                    if dist <= f:\n                        res = (res + dfs(j, f - dist)) % mod\n            return res\n        \n        return dfs(start, fuel)\n", "import functools\n\n\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        graph = dict()\n\n        for i in range(len(locations)):\n            if i not in graph:\n                graph[i] = dict()\n\n            for j in range(len(locations)):\n                if i != j:\n                    graph[i][j] = abs(locations[i] - locations[j])\n\n        @functools.lru_cache(None)\n        def bfs(position: int, fuel: int, count: int) -> int:\n            if position == finish:\n                res = count\n            else:\n                res = 0\n\n            for neighbor in graph[position]:\n                if fuel >= graph[position][neighbor]:\n                    res += bfs(neighbor, fuel - graph[position][neighbor], count)\n\n            return res\n\n        return bfs(start, fuel, 1) % (10 ** 9 + 7)\n", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        cost = lambda i,j: abs(locations[i]-locations[j])\n        @lru_cache(None)\n        def dfs(i, f):\n            if f < abs(cost(i, finish)): return 0\n            # if f<0: return 0 \n            return sum([dfs(j,f-cost(i,j)) for j in range(len(locations)) if j != i]) + (i==finish)\n        return dfs(start, fuel) % (10**9+7)\n\n    def countRoutes1(self, L: List[int], st: int, end: int, f: int) -> int:\n        M=10**9+7\n        res=0\n        def dfs(st,end,f):\n            for i,c in enumerate(L):\n                need=abs(c-L[st])\n                if need <= f:\n                    if i==end:\n                        res+=1\n                    else:\n                        if need<f: dfs(i,end,f-need)\n        dfs(st,end,f)\n        return res%M", "class Solution:\n    # We always get plus 1 if we're on the finish, because we have the option of never moving again.\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        cost = lambda i,j: abs(locations[i]-locations[j])\n        @lru_cache(None)\n        def dfs(i, f):\n            if f < abs(cost(i, finish)): return 0\n            # if f<0: return 0 \n            return sum([dfs(j,f-cost(i,j)) for j in range(len(locations)) if j != i]) + (i==finish)\n        return dfs(start, fuel) % (10**9+7)\n\n    def countRoutes1(self, L: List[int], st: int, end: int, f: int) -> int:\n        M=10**9+7\n        res=0\n        def dfs(st,end,f):\n            for i,c in enumerate(L):\n                need=abs(c-L[st])\n                if need <= f:\n                    if i==end:\n                        res+=1\n                    else:\n                        if need<f: dfs(i,end,f-need)\n        dfs(st,end,f)\n        return res%M", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 1_000_000_007\n        \n        from functools import lru_cache\n        @lru_cache(None)\n        def backtrack(index, remaining_gas):\n            if index == finish and remaining_gas == 0:\n                return 1\n            if remaining_gas == 0 and index != finish:\n                return 0\n            \n            count = 0\n            if index == finish:\n                count = 1\n            for i in range(len(locations)):\n                if i == index:\n                    continue\n                dist = abs(locations[i] - locations[index])\n                if dist <= remaining_gas:\n                    count = (count + backtrack(i, remaining_gas - dist) ) % MOD\n            return count\n        \n        return backtrack(start, fuel)", "class Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        MOD = 1000000007\n        @functools.lru_cache(maxsize=None)\n        def calc(start, fuel):\n            ret = 0\n            if start == finish:\n                ret += 1\n            for i in range(len(locations)):\n                if i == start:\n                    continue\n                d = abs(locations[i] - locations[start])\n                if d > fuel:\n                    continue\n                ret = (ret + calc(i, fuel - d)) % MOD\n            return ret\n        \n        return calc(start, fuel)", "class Solution:\n    def countRoutes(self, loc: List[int], start: int, finish: int, fuel: int) -> int:\n        \n        if abs(loc[start]-loc[finish]) > fuel:\n            return 0\n        \n        s, f = loc[start], loc[finish]\n        loc = sorted(loc)\n        \n        start, end = loc.index(s), loc.index(f)\n        if start > end:\n            start, end = end, start\n        \n        \n        @lru_cache(None)\n        def dp(i, gas):\n            if gas < 0:\n                return 0\n            \n            ans = 0\n            if i == end:\n                ans += 1\n                \n            for nxt in range(len(loc)):\n                if nxt != i:\n                    ans += dp(nxt, gas-abs(loc[i]-loc[nxt]))\n            \n            return ans\n        \n        res = dp(start, fuel)\n        \n        return res % (10**9+7)\n            \n            \n            \n            \n            \n            \n", "from functools import lru_cache\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        start = locations[start]\n        finish = locations[finish]\n        @lru_cache(None)\n        def helper(start, fuel):\n            if fuel < 0:\n                return 0\n            summ = start == self.finish\n            for i in locations:\n                if i!= start:\n                    remaining_fuel = fuel - abs(start - i)\n                    summ += helper(i, remaining_fuel)\n            print((start, fuel, summ))\n            return summ\n        self.finish = finish\n        return helper(start, fuel)%(10**9+7)\n", "MOD = 10 ** 9 + 7\nclass Solution:\n    def countRoutes(self, locations: List[int], start: int, finish: int, fuel: int) -> int:\n        n = len(locations)\n        @lru_cache(None)\n        def dp(pos, left):\n            ans = int(pos == finish)\n            if left == 0:\n                return ans\n            for i in range(n):\n                if i != pos:\n                    cost = abs(locations[pos] - locations[i])\n                    if cost <= left:\n                        ans += dp(i, left - cost)\n                        if ans > MOD:\n                            ans %= MOD\n            return ans\n        return dp(start, fuel)"]
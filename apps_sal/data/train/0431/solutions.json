["class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        stack = []\n        result = 0\n        A = [0] + A + [0]\n\n        for i, x in enumerate(A):\n            while stack and x < A[stack[-1]]:\n                j = stack.pop()\n                result += A[j] * (i - j) * (j - stack[-1])\n            stack.append(i)\n\n        return result % (10**9 + 7)\n", "class Solution:\n    def sumSubarrayMins(self, A):\n        res = 0\n        s = []\n        A = [0] + A + [0]\n        for i, x in enumerate(A):\n            while s and A[s[-1]] > x:\n                j = s.pop()\n                k = s[-1]\n                res += A[j] * (i - j) * (j - k)\n            s.append(i)\n        return res % (10**9 + 7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        MOD = 10**9 + 7\n        N = len(A)\n\n        # prev has i* - 1 in increasing order of A[i* - 1]\n        # where i* is the answer to query j\n        stack = []\n        prev = [None] * N\n        for i in range(N):\n            while stack and A[i] < A[stack[-1]]:\n                stack.pop()\n            prev[i] = stack[-1] if stack else -1\n            stack.append(i)\n\n        # next has k* + 1 in increasing order of A[k* + 1]\n        # where k* is the answer to query j\n        stack = []\n        next_ = [None] * N\n        for k in range(N-1, -1, -1):\n            while stack and A[k] <= A[stack[-1]]:\n                stack.pop()\n            next_[k] = stack[-1] if stack else N\n            stack.append(k)\n\n        # Use prev/next array to count answer\n        return sum((i - prev[i]) * (next_[i] - i) * A[i]\n                   for i in range(N)) % MOD\n            \n                    \n                \n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        # build previous less element array\n        previous_less = [-1] * len(A)\n        p_stack = []\n        \n        # build next less element array\n        next_less = [len(A)] * len(A)\n        n_stack = []\n        \n        for i in range(len(A)):\n            n = A[i]\n            # remove larger until find the smaller one\n            while p_stack and A[p_stack[-1]] > n:\n                p_stack.pop()\n            # stack top is previous less of A[i]\n            # if empty, record -1, else record stack top index\n            if p_stack:\n                previous_less[i] = p_stack[-1]\n            else:\n                previous_less[i] = -1\n            p_stack.append(i)\n            \n            # remove larger until find the smaller one\n            while n_stack and A[n_stack[-1]] > n:\n                # index of the one need to be updated\n                # the one that is bigger than A[i]\n                x = n_stack[-1]\n                n_stack.pop()\n                next_less[x] = i\n            n_stack.append(i)\n            \n        #print(previous_less)\n        #print(next_less)\n        \n        ans = 0\n        mod = 10 ** 9 + 7\n        for i in range(len(A)):\n            # calculate distance to left and right\n            left = i - previous_less[i]\n            right = next_less[i] - i\n            #print(left)\n            #print(right)\n            \n            ans = (ans + A[i] * left * right) % mod\n        return ans", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        n = len(A)\n        low = [None] * (n)\n        high = [None] * (n)\n        stack = []\n        \n        for i in range(n):\n            while stack and A[stack[-1]] >= A[i]:\n                stack.pop()\n            \n            low[i] = stack[-1] if stack else -1\n            stack.append(i)\n        \n        stack = []\n        for i in range(n-1, -1, -1):\n            while stack and A[stack[-1]] > A[i]:\n                stack.pop()\n            high[i] = stack[-1] if stack else n\n            stack.append(i)\n        ans = 0\n        for i in range(n):\n            ans = (ans + (i - low[i]) * (high[i] - i) * A[i]) % int(1e9 + 7)\n        return ans\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        left = [0]*len(A)\n        right = [0]*len(A)\n        s1, s2 = [], []\n        for i in range(len(A)):\n            count = 1\n            while s1 and s1[-1][0]>A[i]:\n                count+=s1.pop()[1]\n            s1.append([A[i],count])\n            left[i]=count\n        for i in range(len(A))[::-1]:\n            count = 1\n            while s2 and s2[-1][0]>=A[i]:\n                count+=s2.pop()[1]\n            s2.append([A[i],count])\n            right[i]=count\n        ret = 0\n        for i in range(len(A)):\n            ret+=A[i]*(left[i]*right[i])\n        return ret%(10**9+7)\n                \n            \n                \n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        firstLessR = []\n        firstLessL = []\n        \n        n = len(A)\n        for i in range(n):\n            firstLessR.append(i)\n            firstLessL.append(i)\n        \n        incNums = []\n        \n        for i in range(n):\n            if i == 0:\n                incNums.append(i)\n            else:\n                while len(incNums) > 0 and A[incNums[-1]] >= A[i]:\n                    firstLessR[incNums[-1]] = i\n                    incNums.pop()\n                incNums.append(i)\n        \n        for i in incNums:\n            firstLessR[i] = n\n        \n        incNums = []\n        for i in range(n-1, -1, -1):\n            if i == n-1:\n                incNums.append(i)\n            else:\n                while len(incNums) > 0 and A[incNums[-1]] > A[i]:\n                    firstLessL[incNums[-1]] = i\n                    incNums.pop()\n                incNums.append(i)\n        \n        for i in incNums:\n            firstLessL[i] = -1\n        ans = 0\n        #print(firstLessR, firstLessL)\n        for i in range(n):\n            w = (firstLessR[i] - i) * (i - firstLessL[i])\n            ans += w * A[i]\n            ans = ans % 1000000007\n        \n        return ans", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        n = len(A)\n        count = [0] * n\n        s = []\n        for i in range(n):\n            while len(s)>0 and A[i] <= A[s[-1]]:\n                s.pop()\n            if len(s) == 0:\n                count[i] = i+1\n            else:\n                count[i] = i-s[-1]\n            s.append(i)\n        s = []\n        for i in range(n-1,-1,-1):\n            while len(s)>0 and A[i] < A[s[-1]]:\n                s.pop()\n            if len(s) == 0:\n                count[i] *= (n-i)\n            else:\n                count[i] *= (s[-1]-i)\n            s.append(i)\n        res = 0\n        for i in range(n):\n            res += count[i]*A[i]\n        return res%1000000007", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        MOD = 10**9 + 7\n        stack = []\n        ans = dot = 0\n        for j, y in enumerate(A):\n            count = 1\n            while stack and stack[-1][0] >= y:\n                x, c = stack.pop()\n                count += c\n                dot -= x * c\n            stack.append((y, count))\n            dot += y * count\n            ans += dot\n            \n        return ans % MOD\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        # Prev/Next Array\n        # Time  complexity: O(N)\n        # Space complexity: O(N)\n        MOD = 10**9 + 7\n        N = len(A)\n\n        # prev has i* - 1 in increasing order of A[i* - 1]\n        # where i* is the answer to query j\n        stack, prev = [], [None] * N\n        for i in range(N):\n            while stack and A[i] <= A[stack[-1]]:\n                stack.pop()\n            prev[i] = stack[-1] if stack else -1\n            stack.append(i)\n\n        # next has k* + 1 in increasing order of A[k* + 1]\n        # where k* is the answer to query j\n        stack = []\n        next_ = [None] * N\n        for k in range(N - 1, -1, -1):\n            while stack and A[k] < A[stack[-1]]:\n                stack.pop()\n            next_[k] = stack[-1] if stack else N\n            stack.append(k)\n\n        # Use prev/next array to count answer\n        return sum((i - prev[i]) * (next_[i] - i) * A[i] for i in range(N)) % MOD\n\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        n = len(A)\n        left, right, sl, sr = [0] * n, [0] * n, [], []\n        # left[i] is num of subarray left of A[i] with A[i] being the min\n        for i in range(n):\n            count = 1\n            while sl and sl[-1][0] > A[i]:\n                count += sl.pop()[1]\n            left[i] = count\n            sl.append([A[i], count])\n        # right[i] is the num subarray right of A[i] with A[i] being the min\n        for j in range(n)[::-1]:\n            count = 1\n            while sr and sr[-1][0] >= A[j]:\n                count += sr.pop()[1]\n            right[j] = count\n            sr.append([A[j], count])\n        # print(left,right)\n        return sum(a * l * r for a, l, r in zip(A, left, right)) % 1_000_000_007\n        \n", "class Solution(object):\n    def sumSubarrayMins(self, A):\n        MOD = 10**9 + 7\n\n        stack = []\n        ans = dot = 0\n        for j, y in enumerate(A):\n            # Add all answers for subarrays [i, j], i <= j\n            count = 1\n            while stack and stack[-1][0] >= y:\n                x, c = stack.pop()\n                count += c\n                dot -= x * c\n\n            stack.append((y, count))\n            dot += y * count\n            ans += dot\n        return ans % MOD", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        tot = 0\n        stack = [-1]\n        A.append(0)\n        for i in range(len(A)):\n            #print(tot, A[i],'<<<<')\n            while A[i] < A[stack[-1]]:\n                loc = stack.pop()\n                height = A[loc]\n                left = loc - stack[-1]\n                right = i - loc\n                width = i - stack[-1] - 1\n                #print(height, left*right)#*(width+1)//2)\n                tot += height*left*right#*(width+1)//2\n            stack.append(i)\n        return tot % (10 ** 9 + 7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        # Prev/Next Array\n        # Time  complexity: O(N)\n        # Space complexity: O(N)\n        # MOD = 10**9 + 7\n        # N = len(A)\n\n        # # prev has i* - 1 in increasing order of A[i* - 1]\n        # # where i* is the answer to query j\n        # stack, prev = [], [None] * N\n        # for i in range(N):\n        #     while stack and A[i] <= A[stack[-1]]:\n        #         stack.pop()\n        #     prev[i] = stack[-1] if stack else -1\n        #     stack.append(i)\n\n        # # next has k* + 1 in increasing order of A[k* + 1]\n        # # where k* is the answer to query j\n        # stack = []\n        # next_ = [None] * N\n        # for k in range(N - 1, -1, -1):\n        #     while stack and A[k] < A[stack[-1]]:\n        #         stack.pop()\n        #     next_[k] = stack[-1] if stack else N\n        #     stack.append(k)\n\n        # # Use prev/next array to count answer\n        # return sum((i - prev[i]) * (next_[i] - i) * A[i] for i in range(N)) % MOD\n\n\n        # Maintain Stack of Minimums\n        # Time  complexity: O(N)\n        # Space complexity: O(N)\n        MOD = 10**9 + 7\n\n        stack, ans, dot = [], 0, 0\n        for j, y in enumerate(A):\n            # Add all answers for subarrays [i, j], i <= j\n            count = 1\n            while stack and stack[-1][0] >= y:\n                x, c = stack.pop()\n                count += c\n                dot -= x * c\n\n            stack.append((y, count))\n            dot += y * count\n            ans += dot\n\n        return ans % MOD\n\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        n = len(A)\n        left_less = [0] * n\n        right_less = [0] * n\n        left_stack = []\n        right_stack = []\n        for i in range(n):\n            count = 1\n            while left_stack and left_stack[-1][0] > A[i]:\n                count += left_stack.pop()[1] \n                # count += 1\n            left_less[i] = count\n            left_stack.append([A[i], count])\n        for i in range(n-1, -1, -1):\n            count = 1\n            while right_stack and right_stack[-1][0] >= A[i]:\n                count += right_stack.pop()[1]\n                # count += 1\n            right_less[i] = count\n            right_stack.append([A[i], count])\n            \n        mod = 10**9 + 7\n        return sum(A[i]*right_less[i]*left_less[i] for i in range(n)) % mod", "class Solution(object):\n    def sumSubarrayMins(self, A):\n        MOD = 10**9 + 7\n        N = len(A)\n\n        # prev has i* - 1 in increasing order of A[i* - 1]\n        # where i* is the answer to query j\n        stack = []\n        prev = [None] * N\n        for i in range(N):\n            count = 1\n            while stack and A[i] <= A[stack[-1][0]]:\n                x,c = stack.pop()\n                count += c\n            stack.append((i, count))\n            prev[i] = stack[-1][1] if stack else -1\n            \n        print(prev)\n        # next has k* + 1 in increasing order of A[k* + 1]\n        # where k* is the answer to query j\n        stack = []\n        nxt = [None] * N\n        for k in range(N-1, -1, -1):\n            count = 1\n            while stack and A[k] < A[stack[-1][0]]:\n                x, c = stack.pop()\n                count += c\n            stack.append((k, count))    \n            nxt[k] = stack[-1][1] if stack else N\n            \n\n        # Use prev/next array to count answer\n        print(nxt)\n        return sum((prev[i]) * (nxt[i]) * A[i]\n                   for i in range(N)) % MOD", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        n, mod = len(A), 10**9 + 7\n        left, right, stack1, stack2 = [0]*n, [0]*n, [], []\n        \n        for i in range(n):\n            count = 1\n            while stack1 and stack1[-1][0] > A[i]:\n                count += stack1.pop()[1]\n            left[i] = count\n            stack1.append([A[i], count])\n        \n        for i in range(n-1, -1, -1):\n            count = 1\n            while stack2 and stack2[-1][0] >= A[i]:\n                count += stack2.pop()[1]\n            right[i] = count\n            stack2.append([A[i], count])\n        \n        return sum(a * l * r for a, l, r in zip(A, left, right)) % mod", "class Solution(object):\n    def sumSubarrayMins(self, A):\n        MOD = 10**9 + 7\n        n = len(A)\n\n        stack = []\n        left = [-1] * n\n        for i in range(n):\n            while stack and A[i] <= A[stack[-1]]:\n                stack.pop()\n            if stack:\n                left[i] = stack[-1]\n            stack.append(i)\n\n        stack = []\n        right = [n] * n\n        for k in range(n-1, -1, -1):\n            while stack and A[k] < A[stack[-1]]:\n                stack.pop()\n            if stack:\n                right[k] = stack[-1]\n            stack.append(k)\n\n        return sum((i - left[i]) * (right[i] - i) * A[i] for i in range(n)) % MOD", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        \n        res=[0]*(len(A)+1)\n        A=[0]+A\n        stack=[(0,0)]\n        \n        for i,num in enumerate(A):\n            while stack and stack[-1][0]>num:\n                stack.pop()\n            j=stack[-1][1]\n            res[i]=res[j]+(i-j)*num\n            stack.append((num,i))\n        return sum(res) % (10**9+7)\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        n = len(A)\n        left = [0] * n\n        right = [0] * n\n        s = []\n        \n        for i in range(n):\n            count = 1\n            while s and s[-1][0] >= A[i]:\n                count += s.pop()[1]\n            left[i] = count\n            s.append((A[i], count))\n        s = []\n        for i in range(n-1, -1, -1):\n            count = 1\n            while s and s[-1][0] > A[i]:\n                count += s.pop()[1]\n            right[i] = count\n            s.append((A[i], count))\n        print(left)\n        print(right)\n        s = 0\n        for i in range(n):\n            s += (left[i]) * (right[i]) * A[i]\n        return s % (10 **9 + 7)", "class Solution:\n    def sumSubarrayMins(self, A):\n        n, mod = len(A), 10**9 + 7\n        left, right, s1, s2 = [0] * n, [0] * n, [], []\n        for i in range(n):\n            count = 1\n            while s1 and s1[-1][0] > A[i]: count += s1.pop()[1]\n            left[i] = count\n            s1.append([A[i], count])\n        for i in range(n)[::-1]:\n            count = 1\n            while s2 and s2[-1][0] >= A[i]: count += s2.pop()[1]\n            right[i] = count\n            s2.append([A[i], count])\n        return sum(a * l * r for a, l, r in zip(A, left, right)) % mod\n    \n        \n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        m = 10 ** 9 + 7\n        prev_stack = []\n        next_stack = []\n        \n        prev_smaller = {}\n        next_smaller = {}\n                \n        for i in range(len(A)):\n            while len(next_stack) > 0 and next_stack[-1][0] >= A[i]:\n                elem, idx = next_stack.pop()\n                next_smaller[idx] = i\n                \n            next_stack.append([A[i], i])\n            \n        while len(next_stack) != 0:\n            elem, idx = next_stack.pop()\n            next_smaller[idx] = len(A)\n    \n        \n        for i in range(len(A) - 1, -1, -1):\n            while len(prev_stack) > 0 and prev_stack[-1][0] > A[i]:\n                elem, idx = prev_stack.pop()\n                prev_smaller[idx] = i\n                \n            prev_stack.append([A[i], i])\n            \n        while len(prev_stack) != 0:\n            elem, idx = prev_stack.pop()\n            prev_smaller[idx] = -1\n        \n        # print(prev_smaller)\n        # print(next_smaller)\n        \n        result = 0\n        for i in range(len(A)):\n            left_count = i - prev_smaller[i] - 1\n            right_count = next_smaller[i] - i - 1\n            num_occurrences = (left_count + 1) * (right_count + 1)\n            result = (result + num_occurrences * A[i]) % m\n            \n        return result\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        mod = 10**9+7\n        A = [0] + A + [0]\n        n = len(A)\n        stack = []\n        res = 0\n        \n        for i in range(n):\n            while stack and A[stack[-1]]>A[i]:\n                curr = stack.pop(-1)\n                left = stack[-1]\n                right = i\n                res += A[curr]*(curr-left)*(right-curr)   \n            stack.append(i)\n        res %= 10 ** 9 + 7\n        return res\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        n = len(A)\n        stack = []\n        l_count = []\n        for i in range(n):\n            while stack and A[stack[-1]]>A[i]:\n                stack.pop()\n            l_c = 0\n            if stack:\n                l_c = stack[-1] + 1\n            stack.append(i)\n            l_count.append(l_c)\n        \n        stack = []\n        r_count = []\n        for i in range(n):\n            while stack and A[stack[-1]]>=A[n-i-1]:\n                stack.pop()\n            r_c = n-1\n            if stack:\n                r_c = stack[-1] - 1\n            stack.append(n-i-1)\n            r_count.append(r_c)\n        \n        r_count = r_count[::-1]\n        \n        t = 0\n        print(l_count)\n        print(r_count)\n        for i in range(n):\n            l = l_count[i]\n            r = r_count[i]\n            t += (i-l+1)*(r-i+1)*A[i]\n        \n        return t % (10**9+7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        mod = 10 ** 9 + 7\n        stack = []\n        ans = dot = 0\n        for idx, val in enumerate(A):\n            count = 1\n            while stack and stack[-1][0] >= val:\n                x,c = stack.pop()\n                count += c\n                dot -= x*c\n            \n            stack.append((val,count))\n            dot += val * count\n            ans += dot\n        return ans % mod", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        N = len(A)\n        stack = []\n        res = 0\n        instack = 0\n        for i in range(N):\n            tmp = 1\n            while stack and stack[-1][0]>=A[i]:\n                x, cnt = stack.pop()\n                tmp += cnt\n                instack -= x*cnt\n            stack.append( (A[i], tmp) )\n            instack += A[i]*tmp\n            \n            res += instack\n        return res % (10**9+7)", "from collections import deque\nclass Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        stack = deque()\n        left = [0] * len(A)\n        right = [len(A)] * len(A)\n        mod = 10**9 + 7\n        \n        for i in range(len(A)):\n            #print(stack, left, right)\n            while stack and A[stack[-1]] > A[i]:\n                right[stack[-1]] = i\n                stack.pop()\n            left[i] = stack[-1] if stack else -1\n            stack.append(i)\n        \n        res = 0\n        for i in range(len(A)):\n            res += A[i] * (i-left[i]) * (right[i]-i)\n        return res%mod", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        length = len(A)\n        left = [-1 for _ in range(length)]\n        right = [length for _ in range(length)]\n        stack, res, N = [], 0, 10 ** 9 + 7\n        \n        for i in range(length):\n            while stack and A[stack[-1]] > A[i]:\n                right[stack.pop()] = i\n            if stack: left[i] = stack[-1]\n            stack.append(i)\n        \n        # print(left)\n        # print(right)\n        \n        for i in range(length):\n            res += (i - left[i]) * (right[i] - i) * A[i]\n        return res % N\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        length = len(A)\n        left = [-1 for _ in range(length)]\n        right = [length for _ in range(length)]\n        stack, res, N = [], 0, 10 ** 9 + 7\n        \n        for i in range(length):\n            while stack and A[stack[-1]] > A[i]:\n                right[stack.pop()] = i\n            if stack: left[i] = stack[-1]\n            stack.append(i)\n        \n        for i in range(length):\n            res += (i - left[i]) * (right[i] - i) * A[i]\n        return res % N\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        mod = 10 ** 9 + 7\n        left, right = self.findFirstSmaller(A)\n        ans = 0\n        for i in range(len(A)):\n            ans += ((A[i] % mod)  * ((right[i] - 1 - i + 1) * (i - (left[i] + 1) + 1))) % mod\n    \n        return ans % mod\n        \n    \n    \n    def findFirstSmaller(self, A):\n        left, right = [-1] * len(A), [len(A)] * len(A)\n        \n        stack = []\n        \n        for i, n in enumerate(A):\n            while stack and stack[-1][0] > n:\n                right[stack.pop()[1]] = i\n            \n            if stack:\n                left[i] = stack[-1][1]\n            \n            stack.append((n, i))\n            \n        return left, right", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        res = 0\n        s = []\n        A = [0] + A + [0]\n        for i, x in enumerate(A):\n            while s and A[s[-1]] > x:\n                j = s.pop()\n                k = s[-1]\n                res += A[j] * (i - j) * (j - k)\n            s.append(i)\n        return res % (10**9 + 7)\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        stack=[-1]\n        A.append(float('-inf'))\n        res=0\n        for i, num in enumerate(A):\n            while A[stack[-1]] > num:\n                center= stack.pop()\n                res+= (i-center)* (center-stack[-1])*A[center]\n            stack.append(i)\n        return res% (10**9 + 7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        n, mod = len(A), 10**9+7\n        s = []\n        left = [i + 1 for i in range(n)]\n        right = [n - i for i in range(n)]\n        \n        res = 0\n        \n        for i in range(n):\n            while s and A[s[-1]] > A[i]:\n                k = s.pop()\n                right[k] = i - k\n            left[i] = i + 1 if not s else i - s[-1]\n            s.append(i)\n        print(right)\n        print(left)\n        \n        return sum(a*i*j for a,i,j in zip(A,left,right)) % mod", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        left = []\n        right = []\n        stack = []\n        \n        for i in range(len(A)):\n            left.append(i + 1)\n            right.append(len(A) - i)\n        \n        for i in range(len(A)):\n            while stack and A[i] < A[stack[-1]]:\n                poppedIdx = stack.pop()\n                right[poppedIdx] = i - poppedIdx\n            \n            if stack:\n                left[i] = i - stack[-1]\n            else:\n                left[i] = i + 1\n            \n            stack.append(i)\n        \n        ans = 0\n        for i in range(len(A)):\n            ans = (ans + left[i] * right[i] * A[i]) % 1000000007\n            \n        return ans", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        \n        N = len(A)\n        stack = []\n        left, right = [None]*N,  [None]*N\n        \n        for i in range(N):\n            # print(stack)\n            while stack and A[i] <= A[stack[-1]]:\n                stack.pop()\n                \n            left[i] = stack[-1] if stack else -1\n            stack.append(i)\n        # print(left)\n        stack.clear()\n        \n        for i in range(N-1, -1, -1):\n            while stack and A[i] < A[stack[-1]]:\n                stack.pop()\n            right[i] = stack[-1] if stack else N\n            stack.append(i)\n        # print(right)\n        \n        count = 0\n        \n        for i in range(N):\n            count += (i-left[i])* (right[i]-i)*A[i]\n        return count % (10**9 + 7)\n        \n        \n        \n        \n        \n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        MOD = 10 ** 9 + 7           \n        n = len(A)\n        \n        # previous less element\n        stack = []\n        left = [None] * n\n        for i in range(n):\n            while stack and A[i] <= A[stack[-1]]:\n                stack.pop()\n            if stack:\n                left[i] = stack[-1]\n            else:\n                left[i] = -1\n            stack.append(i)\n        # next less element\n        # stack = []\n        # right = [None] * n\n        # for i in range(n-1,-1,-1):\n        #     # note A[i] < A[stack[-1]]\n        #     while stack and A[i] < A[stack[-1]]:\n        #         stack.pop()\n        #     # note right[i] = n if not stack\n        #     right[i] = stack[-1] if stack else n\n        #     stack.append(i)\n        stack = []\n        right = [n] * n\n        for i in range(n):\n            while stack and A[i] <= A[stack[-1]]:\n                right[stack.pop()] = i\n            stack.append(i)\n        \n        res = 0\n        for i in range(n):\n            res += (i-left[i]) * (right[i]-i) * A[i]\n        \n        return res % MOD", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        N = len(A)\n        if N == 0: return 0\n        mod = 10**9 + 7                \n        \n        stack, left, right = [], [0] * N, [0] * N\n        \n        for i in range(N):\n            count = 1\n            while stack and stack[-1][0] > A[i]: count += stack.pop()[1]\n            left[i] = count\n            stack.append((A[i], count))\n            \n        stack.clear() \n        \n        for i in range(N - 1, -1, -1):\n            count = 1\n            while stack and stack[-1][0] >= A[i]: count += stack.pop()[1]\n            right[i] = count            \n            stack.append((A[i], count))\n            \n        return sum([l*r*v for l,r,v in zip(left, right, A)]) % mod", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        N = len(A)\n        if N == 0: return 0\n        mod = 10**9 + 7                \n        \n        stack, left, right = [], [0] * N, [0] * N\n        \n        for i in range(N):\n            while stack and A[stack[-1]] > A[i]: stack.pop()\n            left[i] = i - (stack[-1] if stack else -1)       \n            stack.append(i)\n            \n        stack.clear() \n        \n        for i in range(N - 1, -1, -1):\n            while stack and A[stack[-1]] >= A[i]: stack.pop()\n            right[i] = stack[-1] - i if stack else N - i        \n            stack.append(i)\n            \n        return sum([l*r*v for l,r,v in zip(left, right, A)]) % mod\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        # https://buptwc.com/2018/09/16/Leetcode-907-Sum-of-Subarray-Minimums/\n        mod = 10 ** 9 + 7\n        left = [-1] * len(A)\n        right = [len(A)] * len(A)\n        \n        # \u8ba1\u7b97left\u6570\u7ec4\n        stack = [0]\n        for i in range(1,len(A)):\n            if A[i] > A[stack[-1]]:\n                left[i] = stack[-1]\n            else:\n                while stack and A[i] <= A[stack[-1]]: \n                    stack.pop()\n                if not stack: \n                    left[i] = -1\n                else: \n                    left[i] = stack[-1]\n            stack.append(i)\n            \n        # \u8ba1\u7b97right\u6570\u7ec4\n        stack = [len(A)-1]\n        for i in range(len(A)-2,-1,-1):\n            if A[i] > A[stack[-1]]:\n                right[i] = stack[-1]\n            else:\n                while stack and A[i] < A[stack[-1]]: \n                    stack.pop()\n                if not stack: \n                    right[i] = len(A)\n                else: \n                    right[i] = stack[-1]\n            stack.append(i)\n\n        res = 0\n        for i in range(len(A)):\n            res += A[i] * (i - left[i]) * (right[i]-  i)\n            \n        return res % mod", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        res = 0\n        #stack store the index of non-decreasing numbers\n        stack = []\n        A = [float('-inf')] + A + [float('-inf')]\n        \n        for i, n in enumerate(A):\n            #if n is smaller than the last element in stack\n            #pop until it is the largest\n            while stack and A[stack[-1]] > n:\n                cur = stack.pop()\n                #after pop, the stack[-1] has the index of the first element that is smaller than cur. i is the right boundary \n                res += A[cur] * (cur - stack[-1]) * (i - cur)\n            stack.append(i)\n        \n        return res % (10**9+7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        N = len(A)\n        if N == 0: return 0\n        mod = 10**9 + 7                \n        \n        stackLeft, stackRight, left, right = [], [], [0] * N, [0] * N\n        \n        for L in range(N):\n            while stackLeft and A[stackLeft[-1]] > A[L]: stackLeft.pop()\n            left[L] = L - (stackLeft[-1] if stackLeft else -1)       \n            stackLeft.append(L)\n            R = N - L - 1\n            while stackRight and A[stackRight[-1]] >= A[R]: stackRight.pop()\n            right[R] = stackRight[-1] - R if stackRight else N - R        \n            stackRight.append(R)\n            \n        return sum([l*r*v for l,r,v in zip(left, right, A)]) % mod\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        n = len(A)\n        left, right = [i + 1 for i in range(n)], [n - i for i in range(n)]\n        stackp, stackn = [], []\n        for i, num in enumerate(A):\n            while stackp and num < A[stackp[-1]]: stackp.pop()\n            if stackp: left[i] = i - stackp[-1]\n            stackp.append(i)\n            \n            while stackn and num < A[stackn[-1]]:\n                curr = stackn.pop()\n                right[curr] = i - curr\n            stackn.append(i)\n\n\n        res = 0\n        mod = 10**9 + 7\n        for i, num in enumerate(A):\n            res = (res + left[i]*right[i]*num) % mod\n        return res", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        MOD = pow(10,9)+7\n        N = len(A)\n        prev = [None]*N\n        next_ = [None]*N\n        \n        stack=[]\n        for i in range(N):\n            while stack and A[i]<=A[stack[-1]]:\n                stack.pop()\n            prev[i] = stack[-1] if stack else -1\n            stack.append(i)\n        \n        stack=[]\n        for k in range(N-1,-1,-1):\n            while stack and A[k]<A[stack[-1]]:\n                stack.pop()\n            next_[k] = stack[-1] if stack else N\n            stack.append(k)\n        \n        # print(prev)\n        # print(next_)\n        \n        return sum((i-prev[i])*(next_[i]-i)*A[i] for i in range(N))%MOD\n", "class Solution:\n    # def sumSubarrayMins(self, A: List[int]) -> int:\n    #     mins = []\n    #     for i, x in enumerate(A):\n    #         mins.append(x)\n    #         current_min = x\n    #         for j in range(i+1, len(A)):\n    #             if A[j] < current_min:\n    #                 current_min = A[j]\n    #             mins.append(current_min)\n    #     # print(mins)\n    #     return int((sum(mins) % (10**9 + 7)))\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        ple_stack = []\n        left = [-1] * len(A)\n        for i in range(len(A)):\n            # print(ple_stack)\n            while ple_stack and A[i] < A[ple_stack[-1]]:\n                ple_stack.pop()\n            left[i] = ple_stack[-1] if ple_stack else -1\n            # print(left)\n            ple_stack.append(i)\n        for i in range(len(A)):\n            left[i] =  i - left[i]\n        # print(left)\n        \n        \n        nle_stack = []\n        right = [-1] * len(A)\n        for j in reversed(range(len(A))):\n            # print(nle_stack)\n            while nle_stack and A[j] <= A[nle_stack[-1]]:\n                nle_stack.pop()\n            right[j] = nle_stack[-1] if nle_stack else len(A)\n            # print(right)\n            nle_stack.append(j)\n        for j in range(len(A)):\n            right[j] = right[j] - j\n        # print(right)\n        \n        return sum([x * y * z for x, y, z in zip(left, right, A)]) % (10**9 + 7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        N = len(A)\n        if N == 0: return 0\n        mod = 10**9 + 7                \n        \n        stack, left, right = [], [0] * N, [0] * N\n        \n        for i in range(N):\n            count = 1\n            while stack and stack[-1][0] > A[i]: count += stack.pop()[1]\n            left[i] = count\n            stack.append((A[i], count))\n            \n        stack.clear() \n        \n        for i in range(N - 1, -1, -1):\n            count = 1\n            while stack and stack[-1][0] >= A[i]: count += stack.pop()[1]\n            right[i] = count            \n            stack.append((A[i], count))\n            \n        total = 0\n            \n        for l,r,v in zip(left, right, A):\n            total += l*r*v\n                \n        \n        return total % mod\n    \n    \n        # # [2,3,1,2,4,6]\n        # # 21 subarrays\n        #      2 1 1 1 1\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        n = len(A)\n        left, right = [i + 1 for i in range(n)], [n - i for i in range(n)]\n        stackp, stackn = [], []\n        for i, num in enumerate(A):\n            while stackp and num < A[stackp[-1]]: stackp.pop()\n            left[i] = i - stackp[-1] if stackp else i + 1\n            stackp.append(i)\n            \n            while stackn and num < A[stackn[-1]]:\n                curr = stackn.pop()\n                right[curr] = i - curr\n            stackn.append(i)\n\n\n        res = 0\n        mod = 10**9 + 7\n        for i, num in enumerate(A):\n            res = (res + left[i]*right[i]*num) % mod\n        return res", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        mod=10**9+7\n        left,right=self.PLE(A),self.NLE(A)\n        return sum(a*i*j for (a,i,j) in zip(A,left,right)) % mod\n    \n    def PLE(self,A):\n        n=len(A)\n        left=[-1]*n\n        stack=[]\n        for i in range(n):\n            while stack and A[stack[-1]]>A[i]:\n                stack.pop()\n            if stack:\n                left[i]=stack[-1]\n            stack.append(i)\n        \n        for i in range(n):\n            left[i]=i+1 if left[i]==-1 else i-left[i]\n        return left\n    \n    def NLE(self,A):\n        n=len(A)\n        right=[-1]*n\n        stack=[]\n        for i in range(n):\n            while stack and A[stack[-1]]>A[i]:\n                right[stack.pop()]=i\n            stack.append(i)\n        \n        for i in range(n):\n            right[i]=n-i if right[i]==-1 else right[i]-i\n        return right\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        n, mod = len(A), 10**9 + 7\n        left, right, s1, s2 = [0] * n, [0] * n, [], []\n        for i in range(n):\n            count = 1\n            while s1 and s1[-1][0] > A[i]: count += s1.pop()[1]\n            left[i] = count\n            s1.append([A[i], count])\n        for i in range(n)[::-1]:\n            count = 1\n            while s2 and s2[-1][0] >= A[i]: count += s2.pop()[1]\n            right[i] = count\n            s2.append([A[i], count])\n        return sum(a * l * r for a, l, r in zip(A, left, right)) % mod\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        \n        MOD = 10**9 + 7\n        cl = []\n        stack = []\n        for i in range(len(A)):\n            \n            while stack and A[stack[-1]] > A[i]:\n                stack.pop()\n            \n            if not stack:\n                l = i+1\n            else:\n                l = i - stack[-1]\n            cl.append(l)\n            stack.append(i)\n        \n        \n        cr = []\n        stack = []\n        for i in range(len(A)-1, -1, -1):\n            while stack and A[stack[-1]] >= A[i]:\n                stack.pop()\n            \n            if not stack:\n                r = len(A) - i\n            else:\n                r = stack[-1] - i\n            \n            stack.append(i)\n            cr.append(r)\n        \n        cr = cr[::-1]\n        \n        tot = 0\n        for i in range(len(A)):\n            tot += A[i]*cl[i]*cr[i]\n            tot %= 10**9 + 7\n        \n        return tot\n        '''\n        queue = deque()\n        MOD = 10**9 + 7\n        \n        tot = 0\n        for indx, num in enumerate(A):\n            tot += num\n            queue.append((num,indx+1))\n            \n        while queue:\n            sub_min, indx = queue.popleft()\n            if indx < len(A):\n                new_sub_min = min(sub_min, A[indx])\n                queue.append((new_sub_min, indx+1))\n                tot += new_sub_min\n                tot %= MOD\n        \n        return tot\n        '''", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        res = 0\n        s = []\n        A = [0] + A + [0]\n        for i, x in enumerate(A):\n            while s and A[s[-1]] > x:\n                j = s.pop()\n                k = s[-1]\n                res += A[j] * (i - j) * (j - k)\n            s.append(i)\n        return res % (10**9 + 7)\n", "from queue import deque\nfrom collections import defaultdict\nclass Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        A=[float('-inf')]+A+[float('-inf')]\n        \n        left=deque()\n        left.append(0)\n        right=deque()\n        right.appendleft(len(A)-1)\n        \n        left_b=defaultdict(int)\n        right_b=defaultdict(int)\n        \n        for i in range(1,len(A)-1):\n            while left and A[left[-1]]>A[i]:\n                left.pop()\n            left_b[i]=left[-1]+1\n            left.append(i)\n        \n        for i in reversed(range(1,len(A)-1)):\n            while right and A[right[0]]>=A[i]:\n                right.popleft()\n            right_b[i]=right[0]-1\n            right.appendleft(i)\n        \n        \n        \n        res=0\n        for i in range(1,len(A)-1):\n            res+=(i-left_b[i]+1)*(right_b[i]-i+1)*A[i]\n        return res%(10**9+7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        l = len(A)\n        left = [0 for _ in range(l)]\n        right = [0 for _ in range(l)]\n        s = []\n        res = 0\n        for i in range(l):\n            if s:\n                if A[i] > A[s[-1]]:\n                    s.append(i)\n                else:\n                    while s and A[i] < A[s[-1]]:\n                        s.pop()\n                    if s == []:\n                        left[i] = i\n                    else:\n                        left[i] = i - s[-1] - 1\n                    s.append(i)\n            else:\n                s.append(i)\n        A = A[::-1]\n        s = []\n        for i in range(l):\n            if s:\n                if A[i] > A[s[-1]]:\n                    s.append(i)\n                else:\n                    while s and A[i] <= A[s[-1]]:\n                        s.pop()\n                    if s == []:\n                        right[i] = i\n                    else:\n                        right[i] = i - s[-1] -1\n                    s.append(i)\n            else:\n                s.append(i)\n        for i in range(l):\n            res += A[l-1-i] * (left[i]+1) * (right[l-1-i]+1)\n        return res % (10**9 + 7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        l = len(A)\n        left = [0 for _ in range(l)]\n        right = [0 for _ in range(l)]\n        s = []\n        res = 0\n        for i in range(l):\n            if s:\n                if A[i] < A[s[-1]]:\n                    while s and A[i] < A[s[-1]]:\n                        s.pop()\n                    if s == []:\n                        left[i] = i\n                    else:\n                        left[i] = i - s[-1] - 1\n            s.append(i)\n        A.reverse()\n        s.clear()\n        for i in range(l):\n            if s:\n                if A[i] <= A[s[-1]]:\n                    while s and A[i] <= A[s[-1]]:\n                        s.pop()\n                    if s == []:\n                        right[i] = i\n                    else:\n                        right[i] = i - s[-1] -1\n            s.append(i)\n        for i in range(l):\n            if left[i] == 0 and right[l-1-i] == 0:\n                res += A[l-1-i]\n            else:\n                res += A[l-1-i] * (left[i]+1) * (right[l-1-i]+1)\n        return res % (10**9 + 7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        # \uc790\uc874\uac10\uc774 \ub0ae\uc544\uc9c0\uba74 \ud798\ub4e4\ub2e4...\n        # \ub0b4\uac00 \ub178\ub825\ud55c \uc591\uc5d0 \ube44\ud574 \ub0a8\ub4e4\uc758 \ud3c9\uac00\uac00 \ub0ae\uac8c \ub3cc\uc544\uc624\ub294\uac83 \uac19\uae30\uc5d0\n        # \uc774\uac83\ub610\ud55c \ub0b4\uac00 \uc0dd\uac01\ud558\ub294 \uae30\uc900! \n        \n        # when i see this is minimum on num on left side\n        # i can count the number \n        # cnt = 1\n        # while st and st[-1][0] > curr_num:\n        #     pop and increment\n        # what happend for increase case? then this case count only once when it used by itself\n        N = len(A)\n        lefts = []\n        st = []\n        for i,num in enumerate(A):\n            cnt = 1\n            while st and st[-1][0] > num:\n                prev_num, prev_cnt = st.pop()\n                cnt += prev_cnt\n            st.append([num, cnt])\n            lefts.append(cnt)\n        rights = []\n        st = []\n        for i,num in reversed(list(enumerate(A))):\n            cnt = 1\n            while st and st[-1][0] >= num:\n                prev_num, prev_cnt = st.pop()\n                cnt += prev_cnt\n            st.append([num, cnt])\n            rights.append(cnt)\n\n        \n        ans = 0\n        for lc, num, rc in zip(lefts, A, rights[::-1]):\n            ans += lc*num*rc\n        return ans % (10**9+7)\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        s=[]\n        n = len(A)\n        left =[1]*n\n        right = [1]*n\n        for i in range(n):\n            while len(s)>0 and s[-1][0]>=A[i]:\n                val, cnt = s.pop()\n                left[i] += cnt\n            s.append([A[i], left[i]])\n            \n        s = []\n        for i in range(n-1, -1, -1):\n            while len(s)>0 and s[-1][0]>A[i]:\n                val, cnt = s.pop()\n                right[i] += cnt\n            s.append((A[i], right[i]))\n            \n        total = 0\n        for a, l, r in zip(A, left, right):\n            total += a*l*r\n        return total%(10**9 + 7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        mod = 10**9+7\n        curr_sum = 0\n        last_sum = 0\n        stack = []\n\n        for a in A:\n            cnt = 1\n            last_sum = (last_sum + a)%mod\n            while stack and a < stack[-1][0]:\n                b, c = stack.pop()\n                cnt = (cnt + c)%mod\n                last_sum = (last_sum - (b-a)*c)%mod\n\n            if stack and stack[-1][0] == a:\n                stack[-1][1] = (stack[-1][1] + cnt)%mod\n            else:\n                stack.append([a, cnt])\n\n            curr_sum = (curr_sum + last_sum)%mod\n\n        return curr_sum", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        result = 0\n        tempDq = []\n        A = [0] + A + [0]\n        for idx in range(len(A)):\n            while tempDq and A[tempDq[-1]] > A[idx]:\n                prevIdx = tempDq.pop()\n                lastIdx = tempDq[-1]\n                result += A[prevIdx] * (prevIdx - lastIdx) * (idx - prevIdx)\n            tempDq.append(idx)\n        return result % (10 ** 9 + 7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        s=[]\n        n = len(A)\n        left =[1]*n\n        right = [1]*n\n        for i in range(n):\n            while len(s)>0 and s[-1][0]>A[i]:\n                val, cnt = s.pop()\n                left[i] += cnt\n            s.append([A[i], left[i]])\n            \n        s = []\n        for i in range(n-1, -1, -1):\n            while len(s)>0 and s[-1][0]>=A[i]:\n                val, cnt = s.pop()\n                right[i] += cnt\n            s.append((A[i], right[i]))\n            \n        total = 0\n        for a, l, r in zip(A, left, right):\n            total += a*l*r\n        return total%(10**9 + 7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        A = [0] + A\n        stack = [0]\n        result = [0] * len(A)\n        \n        for i in range(len(A)):\n            while A[stack[-1]] > A[i]:\n                stack.pop()\n                \n            j = stack[-1]\n            result[i] = result[j] + (i - j) * A[i]\n            stack.append(i)\n        return sum(result) % (10 ** 9 + 7)\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        s = []\n        left = [None]*len(A)\n        for i in range(len(A)):\n            count=1\n            while len(s)>0 and A[i]<=s[-1][0]:\n                count += s.pop()[1]\n            s.append((A[i],count))\n            left[i] = count\n        s = []\n        right = [None]*len(A)\n        for i in range(len(A)-1,-1,-1):\n            count=1\n            while len(s)>0 and A[i]<s[-1][0]:\n                count+=s.pop()[1]\n            s.append((A[i],count))\n            right[i] = count\n        _sum = 0\n        for i in range(len(A)):\n            _sum=_sum+A[i]*(left[i]*right[i])\n        return int(_sum%(1e9 + 7))\n        \n            \n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        l = len(A)\n        left = [0] * l\n        right = [0] * l\n        s = []\n        res = 0\n        for i in range(l):\n            if s and A[i] < A[s[-1]]:\n                while s and A[i] < A[s[-1]]:\n                    s.pop()\n                if s == []:\n                    left[i] = i\n                else:\n                    left[i] = i - s[-1] - 1\n            s.append(i)\n        A.reverse()\n        s.clear()\n        for i in range(l):\n            if s and A[i] <= A[s[-1]]:\n                while s and A[i] <= A[s[-1]]:\n                    s.pop()\n                if s == []:\n                    right[i] = i\n                else:\n                    right[i] = i - s[-1] - 1\n            s.append(i)\n        for i in range(l):\n            res += A[l-1-i] * (left[i]+1) * (right[l-1-i]+1)\n        return res % (10**9 + 7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        l = len(A)\n        left = [0 for _ in range(l)]\n        right = [0 for _ in range(l)]\n        s = []\n        res = 0\n        for i in range(l):\n            if s:\n                if A[i] > A[s[-1]]:\n                    s.append(i)\n                else:\n                    while s and A[i] < A[s[-1]]:\n                        s.pop()\n                    if s == []:\n                        left[i] = i\n                    else:\n                        left[i] = i - s[-1] - 1\n                    s.append(i)\n            else:\n                s.append(i)\n        A = A[::-1]\n        s = []\n        for i in range(l):\n            if s:\n                if A[i] <= A[s[-1]]:\n                    while s and A[i] <= A[s[-1]]:\n                        s.pop()\n                    if s == []:\n                        right[i] = i\n                    else:\n                        right[i] = i - s[-1] -1\n            s.append(i)\n        for i in range(l):\n            res += A[l-1-i] * (left[i]+1) * (right[l-1-i]+1)\n        return res % (10**9 + 7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        ans=0\n        \n        \n        st=[]\n        n=len(A)\n        left=[0]*n\n        right=[0]*n\n        mod=pow(10,9)+7\n        for i in range(len(A)):\n            c=1\n            while st and st[-1][0]>A[i]:\n                c+=st.pop()[1]\n            \n            left[i]=c\n            st.append((A[i],c))\n        \n        \n        st=[]\n        for i in list(range(len(A)))[::-1]:\n            c=1\n            while st and st[-1][0]>=A[i]:\n                c+=st.pop()[1]\n            \n            right[i]=c\n            \n            st.append((A[i],c))\n        \n        ans=0\n        m=pow(10,9)+7\n        \n        print(left)\n        print(right)\n        for a,b,c in zip(A,left,right):\n            ans+=a*b*c \n            ans=ans%m\n                      \n        return ans", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        s1,s2 = [],[]\n        left = [None]*len(A)\n        right = [None]*len(A)\n        \n        for i in range(len(A)):\n            count=1\n            while len(s1)>0 and A[i]<=s1[-1][0]:\n                count += s1.pop()[1]\n            s1.append((A[i],count))\n            left[i] = count\n        \n        for i in range(len(A)-1,-1,-1):\n            count=1\n            while len(s2)>0 and A[i]<s2[-1][0]:\n                count+=s2.pop()[1]\n            s2.append((A[i],count))\n            right[i] = count\n        _sum = 0\n        for i in range(len(A)):\n            _sum=_sum+A[i]*(left[i]*right[i])\n        return int(_sum%(1e9 + 7))\n        \n            \n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        N = len(A)\n        if N == 0: return 0\n        mod = 10**9 + 7                \n        \n        res = 0\n        s = []\n        A = [0] + A + [0]\n        for i, x in enumerate(A):\n            while s and A[s[-1]] > x:\n                j = s.pop()\n                k = s[-1]\n                res += A[j] * (i - j) * (j - k)\n            s.append(i)\n        return res % mod\n", "class Solution:\n\n    def next_smallest(self, A):\n        \n        inds = [-1]*len(A)\n\n        stack = []\n\n        for i, val in enumerate(A):\n\n            while len(stack)>0 and A[stack[-1]]>val:\n                inds[stack[-1]] = i\n                stack.pop()\n\n            stack+=[i]\n            \n        return inds\n\n    def last_smallest(self, A):\n\n        inds = [-1]*len(A)\n\n        stack = []\n\n        for i, val in reversed(list(enumerate(A))):\n\n            while len(stack)>0 and A[stack[-1]]>=val:\n                inds[stack[-1]] = i\n                stack.pop()\n\n            stack+=[i]\n            \n        return inds\n        \n\n    def sumSubarrayMins(self, A):\n\n        left = self.last_smallest(A)\n        right = self.next_smallest(A)\n\n        tot = 0\n\n        n = len(A)\n\n        for i, val in enumerate(A):\n            \n            p = left[i]\n            q = right[i]\n\n            a = i-p\n            b = q-i\n\n            if p==-1:\n                a = i+1\n\n            if q==-1:\n                b = n-i\n\n            nseqs = a*b\n\n            tot+=nseqs*val\n\n        return tot % (10**9+7)\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        ans = 0\n        A = [float('-inf')] + A + [float('-inf')]\n        stack = []\n        for i, a in enumerate(A):\n            while stack and A[stack[-1]] > a:\n                cur = stack.pop()\n                ans += A[cur] * (i-cur) * (cur-stack[-1])\n            stack.append(i)\n        return ans % (10**9 + 7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        l = len(A)\n        left = [0 for _ in range(l)]\n        right = [0 for _ in range(l)]\n        s = []\n        res = 0\n        for i in range(l):\n            if s:\n                if A[i] > A[s[-1]]:\n                    s.append(i)\n                else:\n                    while s and A[i] < A[s[-1]]:\n                        pre = s.pop()\n                    if s == []:\n                        left[i] = i\n                    else:\n                        left[i] = i - s[-1] - 1\n                    s.append(i)\n            else:\n                s.append(i)\n            #print(s)\n        #print(left)\n        A = A[::-1]\n        s = []\n        for i in range(l):\n            if s:\n                if A[i] > A[s[-1]]:\n                    s.append(i)\n                else:\n                    while s and A[i] <= A[s[-1]]:\n                        pre = s.pop()\n                    if s == []:\n                        right[i] = i\n                    else:\n                        right[i] = i - s[-1] -1\n                    s.append(i)\n            else:\n                s.append(i)\n        right = right[::-1]\n        #print(right)\n        A = A[::-1]\n        for i in range(l):\n            res += A[i] * (left[i]+1) * (right[i]+1)\n        return res % (10**9 + 7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        s1,s2 = [],[]\n        left = [None]*len(A)\n        right = [None]*len(A)\n        \n        for i in range(len(A)):\n            count1=1\n            while len(s1)>0 and A[i]<=s1[-1][0]:\n                count1=count1+s1.pop()[1]\n            s1.append((A[i],count1))\n            left[i] = count1\n            #for j in range(len(A)-1,-1,-1):\n            j = len(A)-1-i\n            count2=1\n            while len(s2)>0 and A[j]<s2[-1][0]:\n                count2+=s2.pop()[1]\n            s2.append((A[j],count2))\n            right[j] = count2\n        _sum = 0\n        for i in range(len(A)):\n            _sum=_sum+A[i]*(left[i]*right[i])\n        return int(_sum%(1e9 + 7))\n        \n            \n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        l, r = [None]*len(A), [None]*len(A)\n        s1, s2 =[], []\n        for i in range(len(A)):\n            c = 1\n            while s1 and (s1[-1][0]>= A[i]):\n                c += s1[-1][1]\n                s1.pop(-1)\n                \n            s1.append([A[i], c])\n            l[i] = c\n            \n        for i in range(len(A)-1, -1, -1):\n            c = 1\n            while s2 and(s2[-1][0] > A[i]):\n                c += s2[-1][1]\n                s2.pop(-1)\n            s2.append([A[i], c])\n            r[i] = c\n        result = 0\n        \n        for i in range(len(A)):\n            result += A[i]*l[i]*r[i]\n        return result%(10**9 + 7)\n    \n", "MOD = 1000000007\nclass Solution:\n    def sumSubarrayMins(self, A):\n        A = [0] + A + [0]\n        stack = []\n        res = 0\n        for right in range(len(A)):\n            while stack and A[stack[-1]] > A[right]:\n                mid = stack.pop()\n                left = stack[-1]\n                res += A[mid] * (mid - left) * (right - mid)\n                res %= MOD\n            stack.append(right)\n        return res", "class Solution:\n    def previousLessNumber(self, A: List[int]) -> List[int]:\n        plmStack = []\n        plmResult = [-1] * len(A)\n        i = 0\n        while (i < len(A)):\n            while(len(plmStack) > 0 and A[plmStack[-1]] >= A[i]):\n                plmStack.pop()\n            plmResult[i] = -1 if len(plmStack) == 0 else plmStack[-1]\n            plmStack.append(i)\n            i += 1\n        return plmResult\n    \n    def nextLessNumber(self, A: List[int]) -> List[int]:\n        nlmStack = []\n        nlmResult = [-1] * len(A)\n        i = len(A)-1\n        while (i >= 0):\n            while(len(nlmStack) > 0 and A[nlmStack[-1]] > A[i]):\n                nlmStack.pop()\n            nlmResult[i] = -1 if len(nlmStack) == 0 else nlmStack[-1]\n            nlmStack.append(i)\n            i -= 1\n        return nlmResult\n        \n    def sumSubarrayMins(self, A: List[int]) -> int:\n        plmResult = self.previousLessNumber(A)\n        nlmResult = self.nextLessNumber(A)\n        print(plmResult)\n        print(nlmResult)\n        sum = 0\n        for i in range(len(A)):\n            leftDist = 0 \n            if plmResult[i] == -1:\n                leftDist = i + 1\n            else:\n                leftDist = i - plmResult[i]\n                \n            rightDist = 0 \n            if nlmResult[i] == -1:\n                rightDist = len(A) - i\n            else:\n                rightDist = nlmResult[i] - i\n            \n            # print(\\\"index\\\", i , \\\"left\\\", leftDist, \\\"right\\\", rightDist)\n            sum = (sum + (A[i] * leftDist * rightDist)) % (10**9 + 7)\n        return sum\n", "class Solution:\n    def previousLessNumber(self, A: List[int]) -> List[int]:\n        plmStack = []\n        plmResult = [-1] * len(A)\n        i = 0\n        while (i < len(A)):\n            while(len(plmStack) > 0 and A[plmStack[-1]] > A[i]):\n                plmStack.pop()\n            plmResult[i] = -1 if len(plmStack) == 0 else plmStack[-1]\n            plmStack.append(i)\n            i += 1\n        return plmResult\n    \n    def nextLessNumber(self, A: List[int]) -> List[int]:\n        nlmStack = []\n        nlmResult = [-1] * len(A)\n        i = len(A)-1\n        while (i >= 0):\n            while(len(nlmStack) > 0 and A[nlmStack[-1]] >= A[i]):\n                nlmStack.pop()\n            nlmResult[i] = -1 if len(nlmStack) == 0 else nlmStack[-1]\n            nlmStack.append(i)\n            i -= 1\n        return nlmResult\n        \n    def sumSubarrayMins(self, A: List[int]) -> int:\n        plmResult = self.previousLessNumber(A)\n        nlmResult = self.nextLessNumber(A)\n        sum = 0\n        for i in range(len(A)):\n            leftDist = 0 \n            if plmResult[i] == -1:\n                leftDist = i + 1\n            else:\n                leftDist = i - plmResult[i]\n                \n            rightDist = 0 \n            if nlmResult[i] == -1:\n                rightDist = len(A) - i\n            else:\n                rightDist = nlmResult[i] - i\n            sum = (sum + (A[i] * leftDist * rightDist)) % (10**9 + 7)\n        return sum\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        m = 10 ** 9 + 7\n        prev_stack = []\n        next_stack = []\n        \n        prev_smaller = {}\n        next_smaller = {}\n                \n        for i in range(len(A)):\n            while len(next_stack) > 0 and A[next_stack[-1]] >= A[i]:\n                idx = next_stack.pop()\n                next_smaller[idx] = i\n                \n            next_stack.append(i)\n            \n        while len(next_stack) != 0:\n            idx = next_stack.pop()\n            next_smaller[idx] = len(A)\n    \n        for i in range(len(A) - 1, -1, -1):\n            while len(prev_stack) > 0 and A[prev_stack[-1]] > A[i]:\n                idx = prev_stack.pop()\n                prev_smaller[idx] = i\n                \n            prev_stack.append(i)\n            \n        while len(prev_stack) != 0:\n            idx = prev_stack.pop()\n            prev_smaller[idx] = -1\n        \n        # print(prev_smaller)\n        # print(next_smaller)\n        \n        result = 0\n        for i in range(len(A)):\n            left_count = i - prev_smaller[i] - 1\n            right_count = next_smaller[i] - i - 1\n            num_occurrences = (left_count + 1) * (right_count + 1)\n            result = (result + num_occurrences * A[i]) % m\n            \n        return result\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        res = 0\n        A = [0] + A + [0]\n        stack = []\n        for i in range(len(A)):\n            while stack and A[stack[-1]] > A[i]:\n                j = stack.pop()\n                res += A[j] * (i-j) * (j-stack[-1])\n            stack.append(i)\n        return res % (10**9+7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        res = 0\n        stack = []\n        A = [float('-inf')] + A + [float('-inf')]\n        for i, n in enumerate(A):\n            while stack and A[stack[-1]] > n:\n                cur = stack.pop()\n                res += A[cur]*(i-cur)*(cur-stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)\n\n        \n# class Solution:\n#     def sumSubarrayMins(self, A):\n#         res = 0\n#         stack = []  #  non-decreasing \n#         A = [float('-inf')] + A + [float('-inf')]\n#         for i, n in enumerate(A):\n#             while stack and A[stack[-1]] > n:\n#                 cur = stack.pop()\n#                 res += A[cur] * (i - cur) * (cur - stack[-1]) \n#             stack.append(i)\n#         return res % (10**9 + 7)\n", "import numpy as np\n\nclass Solution:\n#     def __init__(self):\n#         self.subar = []\n#         self.mins = []\n#         self.mins_sum = 0\n    \n#     def getSubarrays(self, A):\n#         min_cur = A[0]\n#         for i in range(len(A)):\n#             if A[i] < min_cur: \n#                 min_cur = A[i]\n#                 # print(min_cur)\n#             self.mins_sum += min_cur\n#             # print(A[:(i+1)], \\\"min {} sum {}\\\".format(min_cur, self.mins_sum))\n#             # self.mins.append(min_cur)\n#             # self.subar.append(A[:i])\n        \n#         if len(A) > 1:\n#             self.getSubarrays(A[1:])\n    \n    \n    \n#     def sumSubarrayMins(self, A: List[int]) -> int:\n#         if len(A) > 0: self.getSubarrays(A)\n#         # print(self.subar)\n#         # mins = [np.min(arr) for arr in self.subar]\n#         # print(mins)\n#         # return int(np.sum(mins) % (10**9 + 7))\n#         return int(self.mins_sum % (10**9 + 7))\n        \n    \n     def sumSubarrayMins(self, A: List[int]) -> int:\n            stack = []\n            left, right = [],[]\n            for i in range(len(A)):\n                cnt = 1\n                while stack and A[i] <= stack[-1][0]:\n                    cnt += stack[-1][1]\n                    stack.pop()\n                stack.append([A[i], cnt])\n                left.append(cnt)\n            \n            stack = []\n            for i in range(len(A)-1,-1,-1):\n                cnt = 1\n                while stack and A[i] < stack[-1][0]:\n                    cnt += stack[-1][1]\n                    stack.pop()\n                stack.append([A[i], cnt])\n                right.append(cnt)\n            \n            right = right[::-1]\n            # print(left, right)\n            res = 0\n            for i in range(len(A)):\n                res += A[i] * left[i] * right[i]\n            \n            return res % (10**9 + 7)\n            \n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        MOD=10**9+7\n        result=0\n        stack=[]\n        my_dict={}\n        \n        for i in range(0,len(A)):\n            if stack==[]:\n                stack.append((i,A[i]))\n                my_dict[(i,A[i])]=[0]\n            elif A[i]>=stack[-1][1]:\n                stack.append((i,A[i]))\n                my_dict[(i,A[i])]=[0]\n            else:\n                while(stack!=[] and A[i]<stack[-1][1]):\n                    temp=stack.pop()\n                    my_dict[temp].append(i-temp[0]-1)\n                if stack==[]:\n                    stack.append((i,A[i]))\n                    my_dict[(i,A[i])]=[i]\n                else:\n                    stack.append((i,A[i]))\n                    my_dict[(i,A[i])]=[i-1-stack[-2][0]]\n        for key in my_dict:\n            if len(my_dict[key])==1:\n                my_dict[key].append(len(A)-1-key[0])\n            result+=key[1]*(my_dict[key][0]+1)*(my_dict[key][1]+1)\n        return result%MOD\n                \n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        stack = []\n        bound = [[0, 0] for x in range(0, len(A))]\n        for i in range(0, len(A)):\n            while 0 < len(stack) and A[i] <= stack[-1][0]: \n                bound[stack[-1][1]][1] = i\n                stack.pop()\n            stack.append((A[i], i))\n        while 0 < len(stack): \n            bound[stack[-1][1]][1] = len(A)\n            stack.pop()\n        index = len(A)-1\n        while 0 <= index:\n            while 0 < len(stack) and A[index] < stack[-1][0]: \n                bound[stack[-1][1]][0] = index\n                stack.pop()\n            stack.append((A[index], index))\n            index -= 1\n        while 0 < len(stack): \n            bound[stack[-1][1]][0] = -1\n            stack.pop()\n        sum = 0\n        for i in range(0, len(bound)):\n            sum += A[i]*(i-bound[i][0])*(bound[i][1]-i)\n            sum %= (10**9 + 7)\n        return sum", "class Solution:\n    # def sumSubarrayMins(self, A):\n    #     n, mod = len(A), 10**9 + 7\n    #     left, right, s1, s2 = [0] * n, [0] * n, [], []\n    #     for i in range(n):\n    #         count = 1\n    #         while s1 and s1[-1][0] > A[i]: count += s1.pop()[1]\n    #         left[i] = count\n    #         s1.append([A[i], count])\n    #     for i in range(n)[::-1]:\n    #         count = 1\n    #         while s2 and s2[-1][0] >= A[i]: count += s2.pop()[1]\n    #         right[i] = count\n    #         s2.append([A[i], count])\n    #     print(left)\n    #     print(right)\n    #     return sum(a * l * r for a, l, r in zip(A, left, right)) % mod\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        n = len(A)\n        l_large = [0] * n\n        l_stack = [(A[0], 0)] # mono increasing\n        r_large = [0] * n\n        r_stack = [(A[n-1], n-1)] # mono increasing\n        for i in range(1, n):\n            while l_stack and A[i] < l_stack[-1][0]:\n                _, idx = l_stack.pop()\n                l_large[i] = max(l_large[i], i-idx+l_large[idx])\n            else: l_stack.append((A[i], i))     \n            while r_stack and A[n-i-1] <= r_stack[-1][0]:\n                _, idx = r_stack.pop()\n                r_large[n-i-1] = max(r_large[n-i-1], idx-(n-i-1)+r_large[idx])\n            else: r_stack.append((A[n-i-1], n-i-1))     \n        return sum((1+l_large[i] + r_large[i] + l_large[i] * r_large[i])*A[i] for i in range(n)) % int(1000000007)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        res, curr_sum, min_arr = 0, 0, [(float('-inf'),-1)]\n        for i,a in enumerate(A):\n            while min_arr and a < min_arr[-1][0]:\n                b,j = min_arr.pop()\n                curr_sum -= b*(j-min_arr[-1][1])\n            curr_sum += a*(i-min_arr[-1][1])\n            min_arr.append((a,i))\n            res += curr_sum\n        return res%(10**9+7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        mod = 10 ** 9 + 7\n        A = [0] + A + [0]\n        q = [-1]\n        res = 0\n        cur = 0\n        \n        for i, x in enumerate(A):\n            while q and A[q[-1]] > x:\n                cur -= A[q[-1]] * (q[-1] - q[-2])\n                q.pop()\n            \n            res += x * (i - q[-1]) + cur\n            cur += x * (i - q[-1])\n            \n            q.append(i)\n        \n        return res % mod\n", "class Solution:\n    # def sumSubarrayMins(self, A):\n    #     n, mod = len(A), 10**9 + 7\n    #     left, right, s1, s2 = [0] * n, [0] * n, [], []\n    #     for i in range(n):\n    #         count = 1\n    #         while s1 and s1[-1][0] > A[i]: count += s1.pop()[1]\n    #         left[i] = count\n    #         s1.append([A[i], count])\n    #     for i in range(n)[::-1]:\n    #         count = 1\n    #         while s2 and s2[-1][0] >= A[i]: count += s2.pop()[1]\n    #         right[i] = count\n    #         s2.append([A[i], count])\n    #     print(left)\n    #     print(right)\n    #     return sum(a * l * r for a, l, r in zip(A, left, right)) % mod\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        n = len(A)\n        l_large = [0] * n\n        l_stack = [(A[0], 0)] # mono increasing\n        r_large = [0] * n\n        r_stack = [(A[n-1], n-1)] # mono increasing\n        for i in range(1, n):\n            while l_stack and A[i] <= l_stack[-1][0]:\n                _, idx = l_stack.pop()\n                l_large[i] = max(l_large[i], i-idx+l_large[idx])\n            else: l_stack.append((A[i], i))     \n            while r_stack and A[n-i-1] < r_stack[-1][0]:\n                _, idx = r_stack.pop()\n                r_large[n-i-1] = max(r_large[n-i-1], idx-(n-i-1)+r_large[idx])\n            else: r_stack.append((A[n-i-1], n-i-1))     \n        return sum((1+l_large[i] + r_large[i] + l_large[i] * r_large[i])*A[i] for i in range(n)) % int(1000000007)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        left=[1]*len(A)\n        right=[1]*len(A)\n        stack=[]\n        for i,v in enumerate(A):\n            if i==0:\n                stack.append(i)\n                left[i]=1\n            else:\n                count=1\n                while stack and A[stack[-1]] >v:\n                    count+=left[stack.pop()]\n                left[i]=count\n                stack.append(i)\n        stack=[]\n        for i in range(len(A)-1,-1,-1):\n            count=1\n            while stack and A[stack[-1]]>=A[i]:\n                count+=right[stack.pop()]\n            right[i]=count\n            stack.append(i)\n       # print(left,right)\n        sum=0\n        for i in range(len(A)):\n            sum=sum+(left[i]*right[i]*A[i])\n        return sum%1000000007", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        A = [float('-inf')] + A + [float('-inf')]\n    # The -inf at the beginning makes sure that the stack is never empty. The\n    # -inf at the end makes sure that every element in the original A gets\n    # popped from the stack eventually.\n        stack = [0]\n        res = 0\n        \n        for i in range(1, len(A)):\n            while A[i] < A[stack[-1]]:\n                j = stack.pop()\n                k = stack[-1]\n                res += A[j] * (i - j) * (j - k)\n    #eg.\u4e24\u4e2a\u533a\u95f4\u4f1a\u6709\u4e00\u4e2a\u91cd\u5408\uff0c\u5728j\uff0c \u6bd4\u5982j\u70b9A\u7b49\u4e8e3\uff0c \u8fd9\u6837\u5c31\u53ef\u7b97\u4e0asubarray [3] \u4e86\n                res %= 10 ** 9 + 7\n            stack.append(i)\n        return res\n        \n'''\n        if not A:\n            return 0\n        curmin = []\n        res = 0\n        for i in A:\n            curminlevel = []\n            if not curmin:\n                curminlevel.append(i)\n                res += i\n            else:\n                for j in range(len(curmin[-1])):\n                    minnum = min(curmin[-1][j], i)\n                    curminlevel.append(minnum)\n                    res += minnum\n                curminlevel.append(i)\n                res += i\n            curmin.append(curminlevel)\n        return res%(10**9 + 7)'''\n                    \n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        l = len(A)\n        left = [0 for _ in range(l)]\n        right = [0 for _ in range(l)]\n        s = []\n        res = 0\n        for i in range(l):\n            if s:\n                if A[i] > A[s[-1]]:\n                    s.append(i)\n                else:\n                    while s and A[i] < A[s[-1]]:\n                        pre = s.pop()\n                    if s == []:\n                        left[i] = i\n                    else:\n                        left[i] = i - s[-1] - 1\n                    s.append(i)\n            else:\n                s.append(i)\n        A = A[::-1]\n        s = []\n        for i in range(l):\n            if s:\n                if A[i] > A[s[-1]]:\n                    s.append(i)\n                else:\n                    while s and A[i] <= A[s[-1]]:\n                        pre = s.pop()\n                    if s == []:\n                        right[i] = i\n                    else:\n                        right[i] = i - s[-1] -1\n                    s.append(i)\n            else:\n                s.append(i)\n        for i in range(l):\n            res += A[l-1-i] * (left[i]+1) * (right[l-1-i]+1)\n        return res % (10**9 + 7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        \n        stack = []\n        mult = 0\n        ans = 0\n        \n        for curr_val in A:\n            curr_cnt = 1\n            while stack and stack[-1][0] >= curr_val:\n                val_p, cnt_p = stack.pop()\n                curr_cnt += cnt_p\n                mult -= val_p * cnt_p\n            stack.append((curr_val, curr_cnt))\n            mult += curr_val * curr_cnt\n            ans += mult\n        return ans % (10**9 + 7)\n        \n        \n        \n        \n        ## Two-Pass\n#         CNT = 0\n#         VAL = 1\n#         N = len(A)\n#         left = [0] * N\n#         right = [0] * N\n        \n#         def sum_of_single_min(idx):\n#             return A[idx] * left[idx] * right[idx]\n        \n#         stack = []\n#         for i, curr_val in enumerate(A):\n#             curr_cnt = 1\n#             while stack and stack[-1][VAL] > curr_val:\n#                 curr_cnt += stack.pop()[CNT]\n#             stack.append((curr_cnt, curr_val))\n#             left[i] = curr_cnt\n        \n#         stack = []\n#         for i in range(N-1, -1, -1):\n#             curr_val = A[i]\n#             curr_cnt = 1\n#             while stack and stack[-1][VAL] >= curr_val:\n#                 curr_cnt += stack.pop()[CNT]\n#             stack.append((curr_cnt, curr_val))\n#             right[i] = curr_cnt\n        \n#         return sum(sum_of_single_min(i) for i in range(N)) % (10**9 + 7)\n        \n        \n        \n        \n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        stack = []\n        bound = [[0, 0] for x in range(0, len(A))]\n        for i in range(0, len(A)):\n            if 0 < len(stack):\n                if A[i] <= stack[-1][0]:\n                    while 0 < len(stack) and A[i] <= stack[-1][0]: \n                        bound[stack[-1][1]][1] = i\n                        stack.pop()\n            stack.append((A[i], i))\n        while 0 < len(stack): \n            bound[stack[-1][1]][1] = len(A)\n            stack.pop()\n        index = len(A)-1\n        while 0 <= index:\n            if 0 < len(stack):\n                if A[index] < stack[-1][0]:\n                    while 0 < len(stack) and A[index] < stack[-1][0]: \n                        bound[stack[-1][1]][0] = index\n                        stack.pop()\n            stack.append((A[index], index))\n            index -= 1\n        while 0 < len(stack): \n            bound[stack[-1][1]][0] = -1\n            stack.pop()\n        sum = 0\n        for i in range(0, len(bound)):\n            sum += A[i]*(i-bound[i][0])*(bound[i][1]-i)\n            sum %= (10**9 + 7)\n        return sum", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        # \u8fd9\u9053\u9898\u662fhulu2019\u5e74\u7f51\u6d4b\u7b2c\u4e8c\u9898 \u6539\u6210\u4e86\u6700\u5927\u503c\u3002\n        # medium\u96be\u5ea6\u3002\u9664\u4e86\u66b4\u529bO(n**2) \u5bf9\u4e8e\u6bcf\u4e2ai\uff0c\u53f3\u4fa7\u9010\u6e10\u4ecei\u5230n-1\n        # \u66f4\u597d\u7684\u529e\u6cd5\u662f\u5355\u8c03\u6808\u6216\u8005dp \u65f6\u95f4\u590d\u6742\u5ea6O(n)\u6216\u8005O(nlogn)\n        '''\n        # increasing stacks,\u6ce8\u610f\u662fsubarray\u95ee\u9898\uff0c\u6240\u4ee5\u662f\u8fde\u7eed\u7684\u4e00\u90e8\u5206\n        n = len(A)\n        mod = 10 ** 9 + 7\n        left, right = [0]*n, [0]*n\n        #left[i]\u8868\u793aA[i]\u5de6\u4fa7\uff0c\u4e25\u683c\u5927\u4e8e\u7684\u957f\u5ea6\n        #right[i]\u8868\u793aA[i]\u53f3\u4fa7\uff0c\u5927\u4e8e\u7684\u957f\u5ea6\n        #\u4e3a\u4ec0\u4e48\uff0c\u56e0\u4e3a\u62c5\u5fc3\u9047\u5230\u8fde\u7eed\u7684\u91cd\u590d\u4f8b\u59822\uff0c5\uff0c4\uff0c4\uff0c6 \uff0c\u56e0\u6b64\u53ef\u4ee5\u53bb\u6389\u91cd\u590d\u90e8\u5206\n        #\u8c28\u8bb0\uff0c\u53ef\u91cd\u590d\u51fa\u73b0\u7684\u6570\u7ec4\u91cc\uff0c\u4e3a\u4e86\u533a\u5206\u6700\u5c0f\u7684\u6570\u91cf\uff0c\u5de6\u53f3\u5355\u8c03\u6027\u8981\u6c42\u4e0d\u540c\n        s1, s2 = [], []\n        for i in range(n):\n            count = 1\n            while s1 and s1[-1][0] > A[i]:\n                count += s1.pop()[1]\n            left[i] = count\n            s1.append([A[i],count])\n        for i in range(n)[::-1]:\n            count = 1\n            while s2 and s2[-1][0] >= A[i]:\n                count += s2.pop()[1]\n            right[i] = count\n            s2.append([A[i],count])\n        return sum(a*l*r for a,l,r in zip(A,left,right)) % mod\n        '''\n        res = 0\n        s = []  # \u6700\u5c0f\u503c\u5c31\u7528\u5355\u8c03\u9012\u589e\u6808\uff0c\u6bcf\u4e00\u4e2a\u52a0\u8fdb\u6765\u7684\u6808\u90fd\u662f\u533a\u57df\u6700\u5c0f\u7684\uff0c\u56e0\u4e3a\u6700\u5927\u7684\u88abpop\u4e86\n        # \u9012\u589e\u6808\u7684\u4e00\u4e2a\u7279\u70b9\u5c31\u662f\u5de6\u53f3\u90fd\u75280\u6700\u540e\u6808\u4f1a\u6e05\u7a7a\u800c\u4e14\u7b2c\u4e00\u4e2a0\u957f\u671f\u5b58\u5728\u53ef\u4ee5\u4e0d\u7528\u8003\u8651stack\u7a7a\u7684\u95ee\u9898\n        A = [0] + A + [0]  # \u90fd\u662f\u5927\u4e8e1\u7684\u6570\u5b57\uff0c\u627e\u6700\u5c0f\u503c0\u6ca1\u5173\u7cfb\uff0c\u53cd\u6b63\u4e24\u4fa7\u800c\u4e14\u53ef\u4ee5\u62b5\u6d88\u56e0\u4e3a*0\n        for i, x in enumerate(A):\n            while s and A[s[-1]] > x:\n                j = s.pop()\n                k = s[-1]\n                res += A[j] * (i - j) * (j - k)\n            s.append(i)\n        return res % (10 ** 9 + 7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        \n        # # Naive DP N^2 time, N space, over time limit\n        # n = len(A)\n        # md = 10**9+7\n        # pre = A.copy()\n        # res = sum(pre)\n        # for i in range(1,n):\n        #     now = [0]*(n-i)\n        #     for j in range(n-i):\n        #         now[j] = min(pre[j],pre[j+1])\n        #         res = (res+now[j]) % md\n        #     pre = now\n        # return res\n        \n        # Copied from discussion\n        res = 0\n        s = []\n        A = [0] + A + [0]\n        for i, x in enumerate(A):\n            while s and A[s[-1]] > x:\n                j = s.pop()\n                k = s[-1]\n                res += A[j] * (i - j) * (j - k)\n            s.append(i)\n        return res % (10**9 + 7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int: \n        n = len(A)\n        left = self.first_left_smallest(A)\n        right = self.first_right_smallest(A)\n        count = 0\n        MOD = (10 ** 9) + 7\n        for i in range(n):\n            l = left[i] if left[i] != None else -1\n            r = right[i] if right[i] != None else n\n            n1 = i - l - 1\n            n2 = r - i - 1\n            num_of_sub = (n1+1)*(n2+1)\n            print((i, num_of_sub))\n            count += A[i] * num_of_sub\n        \n        return count % MOD\n    \n    def first_left_smallest(self, A):\n        n = len(A)\n        stack = []\n        res = [None] * n\n        for i in range(n-1, -1, -1):\n            while stack and A[i] <= A[stack[-1]]:\n                j = stack.pop()\n                res[j] = i\n            stack.append(i)\n        \n        return res\n        \n    def first_right_smallest(self, A):\n        n = len(A)\n        stack = []\n        res = [None] * n\n        for i in range(n):\n            while stack and A[i] < A[stack[-1]]:\n                j = stack.pop()\n                res[j] = i\n                \n            stack.append(i)\n        \n        return res\n            \n    def brute_force(self, A):\n        n = len(A)\n        s = 0\n        for i in range(n):\n            smallest = float('inf')\n            for j in range(i, n):\n                smallest = min(smallest, A[j])\n                s += smallest\n        \n        return s % (10**9 + 7)\n                \n                \n            \n    \n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        n = len(A)\n        pre_stack = []\n        pre_val = [-1] * n\n        for i,a in enumerate(A):\n            while pre_stack and A[pre_stack[-1]] >= a:\n                pre_stack.pop()\n            if pre_stack:\n                pre_val[i] = pre_stack[-1] + 1\n            else:\n                pre_val[i] = 0\n            pre_stack.append(i)\n        \n        post_stack = []\n        post_val = [-1] * n\n        for i in range(n-1, -1, -1):\n            while post_stack and A[post_stack[-1]] > A[i]:\n                post_stack.pop()\n            if post_stack:\n                post_val[i] = post_stack[-1] - 1\n            else:\n                post_val[i] = n-1\n            post_stack.append(i)\n        \n        #print(pre_val)\n        #print(post_val)\n        \n        ans = 0\n        mod_cst = 10**9 + 7\n        for i in range(n):\n            ans += (i - pre_val[i]+ 1) * (post_val[i] - i + 1) * A[i]\n            ans %= mod_cst\n        return ans\n            \n        \n        \n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        # build previous less element array\n        previous_less = [-1] * len(A)\n        p_stack = []\n        \n        # build next less element array\n        next_less = [-1] * len(A)\n        n_stack = []\n        \n        for i in range(len(A)):\n            n = A[i]\n            # remove larger until find the smaller one\n            while p_stack and A[p_stack[-1]] > n:\n                p_stack.pop()\n            # stack top is previous less of A[i]\n            # if empty, record -1, else record stack top index\n            if p_stack:\n                previous_less[i] = p_stack[-1]\n            else:\n                previous_less[i] = -1\n            p_stack.append(i)\n            \n            # remove larger until find the smaller one\n            while n_stack and A[n_stack[-1]] > n:\n                # index of the one need to be updated\n                # the one that is bigger than A[i]\n                x = n_stack[-1]\n                n_stack.pop()\n                next_less[x] = i\n            n_stack.append(i)\n            \n        print(previous_less)\n        print(next_less)\n        \n        ans = 0\n        mod = 10 ** 9 + 7\n        for i in range(len(A)):\n            # calculate distance to left and right\n            left = i - previous_less[i]\n            \n            if next_less[i] == -1:\n                right = len(A) - i\n            else:\n                right = next_less[i] - i\n            print(left)\n            print(right)\n            \n            ans = (ans + A[i] * left * right) % mod\n        return ans", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        res, stack, MOD = 0, [], 10**9 + 7\n        for i, x in enumerate(A):\n            while stack and A[stack[-1]] >= x:\n                idx = stack.pop()\n                left = stack[-1] if stack else -1\n                res += A[idx] * (idx - left) * (i - idx) % MOD\n            stack.append(i)\n        while stack:\n            idx = stack.pop()\n            left = stack[-1] if stack else -1\n            res += A[idx] * (idx - left) * (len(A) - idx) % MOD\n        return res % MOD", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        res = 0\n        s = []\n        A = [0] + A + [0]\n        for i, x in enumerate(A):\n            while s and A[s[-1]] > x:\n                j = s.pop()\n                k = s[-1]\n                res += A[j] * (i - j) * (j - k)\n            s.append(i)\n        return res % (10**9 + 7)", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        dp = [] \n        dp_forward = [0] * len(A) \n        dp_backward = [0] * len(A)\n        for i in range(len(A)):\n            while dp and A[i] < dp[-1][0]:\n                dp_forward[i] += dp.pop()[1] + 1\n            dp.append([A[i], dp_forward[i]])\n        print(dp_forward)\n        dp = []\n        for i in range(len(A)-1, -1, -1):\n            while dp and A[i] <= dp[-1][0]:\n                dp_backward[i] += dp.pop()[1] + 1\n            dp.append([A[i], dp_backward[i]])\n        print(dp_backward)\n        result = 0\n        for i in range(len(A)):\n            result += A[i]*(dp_forward[i] + 1)*(dp_backward[i] + 1)\n        return result % (10**9+7)\n        #return sum(a*(l+1)*(r+1) for a, l, r in zip(A, dp_forward, dp_backward)) % (10**9 + 7)\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        n = len(A)\n        left = [0] * n\n        right = [0] * n\n        s1 = []\n        s2 = []\n        mod = 10 ** 9 + 7\n        for i in range(n):\n            cnt = 1\n            while s1 and s1[-1][0] > A[i]:\n                cnt += s1.pop()[1]\n            s1.append((A[i], cnt))\n            left[i] = cnt\n        for i in range(n-1, -1, -1):\n            cnt = 1\n            while s2 and s2[-1][0] >= A[i]:\n                cnt += s2.pop()[1]\n            s2.append((A[i], cnt))\n            right[i] = cnt\n        return sum(A[i] * left[i] * right[i] for i in range(n)) % mod\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        prev_stack = []\n        next_stack = []\n        \n        prev_smaller = []\n        next_smaller = []\n        \n        for i in range(len(A)):\n            prev_smaller.append(i)\n            next_smaller.append(len(A) - i - 1)\n        \n        \n        for i in range(len(A)):\n            while len(next_stack) > 0 and A[next_stack[-1]] >= A[i]:\n                idx = next_stack.pop()\n                next_smaller[idx] = i - idx - 1\n                \n            next_stack.append(i)\n            \n            \n        for i in range(len(A) - 1, -1, -1):\n            while len(prev_stack) > 0 and A[prev_stack[-1]] > A[i]:\n                idx = prev_stack.pop()\n                prev_smaller[idx] = idx - i - 1\n                \n            prev_stack.append(i)\n        \n        m = 10 ** 9 + 7\n        result = 0\n        for i in range(len(A)):\n            num_occurrences = (prev_smaller[i] + 1) * (next_smaller[i] + 1)\n            result = (result + num_occurrences * A[i]) % m\n            \n        return result\n", "# class Solution:\n#     def sumSubarrayMins(self, A: List[int]) -> int:\n#         MOD = 10**9+7\n#         N = len(A)\n        \n#         stack = []\n#         left, right = [None]*N, [None]*N\n        \n#         for i in range(N):\n#             while stack and A[i]<=A[stack[-1]]:\n#                 stack.pop()\n#             left[i] = stack[-1] if stack else -1\n#             stack.append(i)\n            \n#         stack = []\n#         for k in range(N-1,-1,-1):\n#             while stack and A[k]<A[stack[-1]]:\n#                 stack.pop()\n#             right[k] = stack[-1] if stack else N\n#             stack.append(k)\n        \n#         return sum((i-left[i])*(right[i]-i)*A[i] for i in range(N)) % MOD\n\nclass Solution(object):\n    def sumSubarrayMins(self, A):\n        MOD = 10**9 + 7\n\n        stack = []\n        ans = dot = 0\n        for j, y in enumerate(A):\n            # Add all answers for subarrays [i, j], i <= j\n            count = 1\n            while stack and stack[-1][0] >= y:\n                x, c = stack.pop()\n                count += c\n                dot -= x * c\n\n            stack.append((y, count))\n            dot += y * count\n            ans += dot\n        return ans % MOD", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        def right_boundry(A, dupl):\n            res = [0] * len(A)\n            A.append(-math.inf)\n            stack = []\n            \n            for i in range(len(A)):\n                if dupl:\n                    while stack and A[stack[-1]] >  A[i]:\n                        j = stack.pop()\n                        res[j] = i - j\n                else:\n                    while stack and A[stack[-1]] >=  A[i]:\n                        j = stack.pop()\n                        res[j] = i - j\n                    \n                stack.append(i)\n            \n            A.pop()\n            return res\n        \n        right = right_boundry(A, False)\n        left = right_boundry(A[::-1], True)[::-1]\n        \n        ans = sum([right[i]*left[i]*A[i] for i in range(len(A))]) \n        \n        return ans %(10**9+7)\n\n    \n#         dp = [0] * (len(A) + 1)\n#         N = len(A)\n        \n#         for i in range(1,N+1):\n#             mn = A[i-1]\n#             dp[i] = dp[i-1]\n#             for j in range(i, 0, -1):\n#                 mn = min(mn, A[j-1])\n#                 dp[i] = (dp[i] + mn) % (10**9 + 7)\n        \n#         return dp[-1]\n        \n        \n#         cnt = 0\n#         k = 1\n        \n#         while k <= len(A):\n#             stack = []\n#             for i in A:\n#                 if len(stack) < k: \n#                     stack.append(i)\n#                     if len(stack) == k:\n#                         cnt += min(stack)\n#                         stack.pop(0)\n                        \n#             k += 1\n            \n#         return cnt\n                    \n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        \n        larr=[-1]*len(A)\n        rarr=[-1]*len(A)\n        \n        for i in range(len(A)):\n            lefti=i-1\n            while lefti>-1 and A[lefti]>A[i]:\n                lefti=larr[lefti]-1\n                \n            larr[i]=lefti+1\n            \n        \n        for i in range(len(A)-1,-1,-1):\n            righti=i+1\n            \n            while righti<len(A) and A[righti]>=A[i]:\n                righti=rarr[righti]+1\n                \n            rarr[i]=righti-1\n            \n        # print(larr)\n        # print(rarr)\n            \n        count=0\n        for i in range(len(A)):\n            r,l=rarr[i]-i,i-larr[i]\n            count+=((1+l+r+(l*r))*A[i])\n            \n        return count%(10**9+7)\n    \n    \n\n", "class Solution:\n    def sumSubarrayMins(self, A: List[int]) -> int:\n        left, right = [], []\n        stack = []\n        for i in range(len(A)):\n            count = 1\n            while stack and stack[-1][0] > A[i]:\n                count += stack.pop()[1]\n            stack.append([A[i], count])\n            left.append(count)\n        stack = []\n        for i in reversed(range(len(A))):\n            count = 1\n            while stack and stack[-1][0] >= A[i]:\n                count += stack.pop()[1]\n            stack.append([A[i], count])\n            right.append(count)\n        right = right[::-1]\n        \n        res = 0\n        for i in range(len(A)):\n            res += left[i]*right[i]*A[i]\n        return res % (10**9+7)"]
["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\n\nclass Solution:\n    def bfs(self, root, col_table):\n        min_col = 0\n        max_col = 0\n        queue = deque([(root, 0, 0)])\n        \n        while queue:\n            node, col, row = queue.popleft()\n            col_value = col_table.get(col, [])\n            col_value.append((row, node.val))\n            col_table[col] = col_value\n            min_col = min(min_col, col)\n            max_col = max(max_col, col)\n            if node.left:\n                queue.append((node.left, col - 1, row + 1))\n            if node.right:\n                queue.append((node.right, col + 1, row + 1))\n        return min_col, max_col\n                \n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        col_table = dict()\n        min_col, max_col = self.bfs(root, col_table)\n        \n        res = []\n        for col_idx in range(min_col, max_col + 1):\n            col_res = []\n            col = sorted(col_table[col_idx])\n            for i in range(len(col)):\n                col_res.append(col[i][1])\n            res.append(col_res)\n        return res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        nMap = collections.defaultdict(list)\n        queue = collections.deque([(root,0)])\n        xMin, xMax = 0, 0\n        while queue:\n            tmp = collections.defaultdict(list)\n            for i in range(len(queue)):\n                node, nX = queue.popleft()\n                tmp[nX].append(node.val)\n                if node.left:\n                    queue.append((node.left,nX-1))\n                    xMin = min(xMin,nX-1)\n                if node.right:\n                    queue.append((node.right,nX+1))\n                    xMax = max(xMax,nX+1)\n            for i in tmp:\n                nMap[i] += sorted(tmp[i])\n        traversalLst = []\n        return [nMap[i] for i in range(xMin,xMax+1)]", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        \n        XYAndNode = namedtuple('XYAndNode', ('x', 'y', 'node'))\n\n        q = deque([XYAndNode(0, 0, root)])\n        group_by_x = defaultdict(list)\n        min_x = max_x = 0\n        \n        while q:\n            x, y, node = q.popleft()\n            group_by_x[x].append((y, node.val))\n            min_x = min(min_x, x)\n            max_x = max(max_x, x)\n            \n            if node.left:\n                q.append(XYAndNode(x - 1, y + 1, node.left))\n            if node.right:\n                q.append(XYAndNode(x + 1, y + 1, node.right))\n\n        output = []\n        for x in range(min_x, max_x + 1):\n            column = [i[1] for i in sorted(group_by_x[x])]\n            output.append(column)\n        \n        return output\n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        if root is None:\n            return []\n\n        columnTable = defaultdict(list)\n        min_column = max_column = 0\n\n        def BFS(root):\n            nonlocal min_column, max_column\n            queue = deque([(root, 0, 0)])\n\n            while queue:\n                node, row, column = queue.popleft()\n\n                if node is not None:\n                    columnTable[column].append((row, node.val))\n                    min_column = min(min_column, column)\n                    max_column = max(max_column, column)\n\n                    queue.append((node.left, row + 1, column - 1))\n                    queue.append((node.right, row + 1, column + 1))\n\n        # step 1). BFS traversal\n        BFS(root)\n        \n         # step 2). extract the values from the columnTable\n        ret = []\n        for col in range(min_column, max_column + 1):\n            # sort first by 'row', then by 'value', in ascending order\n            ret.append([val for row, val in sorted(columnTable[col])])\n\n        return ret", "class Solution(object):\n    def verticalTraversal(self, root):\n        colTable = defaultdict(list)\n        minCol, maxCol = 0, 0\n        q = [(root, 0, 0)]\n        \n        while q:\n            node, x, y = q.pop()\n            if x < minCol: minCol = x\n            if x > maxCol: maxCol = x\n            colTable[x].append((-y, node.val))\n            if node.left: q.append((node.left, x-1, y-1))\n            if node.right: q.append((node.right, x+1, y-1))\n            \n        return [[x[1] for x in sorted(colTable[col])] \n                      for col in range(minCol, maxCol+1)]        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import defaultdict\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        self.dictionary = defaultdict()\n        \n        def dfs(node, x, y):\n            if not node:\n                return None\n            if x not in self.dictionary:\n                self.dictionary[x] = defaultdict(list)\n            self.dictionary[x][y].append(node.val)\n            dfs(node.left, x - 1, y - 1)\n            \n            dfs(node.right, x + 1, y - 1)\n        \n        dfs(root, 0, 0)\n        ans = []\n        for k in sorted(self.dictionary.keys()):\n            tmp = []\n            for l in sorted(self.dictionary[k].keys(), key=lambda y: -y):\n                tmp += sorted(self.dictionary[k][l])\n            \n            ans.append(tmp)\n        return ans", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        if not root: return []\n        q = deque()\n        q.append((root, 0, 0))\n        res_l = []\n        res_r = []\n        while q:\n            node, x, y = q.popleft()\n            if node.left: q.append((node.left, x - 1, y + 1))\n            if node.right: q.append((node.right, x + 1, y + 1))\n            if x >= 0:\n                if x == len(res_r): res_r.append([])\n                res_r[x].append((y, node.val))\n            else:\n                x = - x - 1\n                if x == len(res_l): res_l.append([])\n                res_l[x].append((y, node.val))\n        res = []\n        for line in res_l[::-1] + res_r:\n            res.append([val for _, val in sorted(line)])\n        return res\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n\\\"\\\"\\\"\n        if not root:\n            return []\n        nodeset = []\n        queue = deque()\n        queue.append((root, 0, 0))\n        while queue:\n            node, x, y = queue.popleft()\n            nodeset.append((x, y, node.val))            \n            if node.left:\n                queue.append((node.left, x-1, y+1))\n            if node.right:\n                queue.append((node.right, x+1, y+1))\n                \n        nodeset = sorted(nodeset)\n        res = {}\n        for (x, y, val) in nodeset:\n            if x not in res:\n                res[x] = []\n            res[x].append(val)\n        return res.values()\n\\\"\\\"\\\"", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import deque\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n\n        if not root: return []\n        q = deque()\n        q.append((root, 0, 0))\n        nodeset = []\n        while q:\n            node, x, y = q.popleft()\n            nodeset.append((x, y, node.val))\n            if node.left: q.append((node.left, x - 1, y + 1))\n            if node.right: q.append((node.right, x + 1, y + 1))\n        res = []\n        nodeset.sort()\n        x = nodeset[0][0] - 1\n        for node in nodeset:\n            if node[0] > x: \n                res.append([])\n                x = node[0]\n            res[-1].append(node[-1])\n        return res\n        \n        \n      \n        \n        \n        \n        \n        \n\\\"\\\"\\\"\n        if not root: return []\n        q = deque()\n        q.append((root, 0, 0))\n        res_l = []\n        res_r = []\n        while q:\n            node, x, y = q.popleft()\n            if node.left: q.append((node.left, x - 1, y + 1))\n            if node.right: q.append((node.right, x + 1, y + 1))\n            if x >= 0:\n                if x == len(res_r): res_r.append([])\n                res_r[x].append((y, node.val))\n            else:\n                x = - x - 1\n                if x == len(res_l): res_l.append([])\n                res_l[x].append((y, node.val))\n        res = []\n        for line in res_l[::-1] + res_r:\n            res.append([val for _, val in sorted(line)])\n        return res\n\\\"\\\"\\\"        \n        \n        \n        \n        \n        \n        \n        \n\\\"\\\"\\\"\n        if not root:\n            return []\n        nodeset = []\n        queue = deque()\n        queue.append((root, 0, 0))\n        while queue:\n            node, x, y = queue.popleft()\n            nodeset.append((x, y, node.val))            \n            if node.left:\n                queue.append((node.left, x-1, y+1))\n            if node.right:\n                queue.append((node.right, x+1, y+1))\n                \n        nodeset = sorted(nodeset)\n        res = {}\n        for (x, y, val) in nodeset:\n            if x not in res:\n                res[x] = []\n            res[x].append(val)\n        return res.values()\n\\\"\\\"\\\"", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        res = []\n        frontier = [(root, 0)]\n        h = defaultdict(list)\n        while frontier:\n            next = []\n            for u, x in frontier:\n                h[x].append(u.val)\n                if u.left: next.append((u.left, x-1)) \n                if u.right: next.append((u.right, x+1))\n                next.sort(key = lambda x: (x[1], x[0].val))\n            frontier = next\n        for k in sorted(h):\n            res.append(h[k])\n        return res", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        from queue import Queue\n        Q = Queue()\n        dic = {}\n        horizontal_distance = 0\n        level = 1\n        Q.put([root, horizontal_distance, level])\n        \n        dic[horizontal_distance] = dic.get(horizontal_distance, [])+[[root.val, level]]\n        \n        while not Q.empty():\n            p = Q.get()\n            currentRoot = p[0]\n            currentHD = p[1]\n            currentLevel = p[2]\n            \n            if currentRoot.left:\n                Q.put([currentRoot.left, currentHD-1, currentLevel+1])\n                dic.setdefault(currentHD-1, []).append([currentRoot.left.val, currentLevel+1])\n            if currentRoot.right:\n                Q.put([currentRoot.right, currentHD+1, currentLevel+1])\n                dic.setdefault(currentHD+1, []).append([currentRoot.right.val, currentLevel+1])\n        \n        del currentRoot, currentHD, currentLevel, p, Q\n        templist = []\n        \n        from operator import itemgetter\n  \n        for key in sorted(dic.keys()):\n            templist.append(i[0] for i in sorted(dic[key], key = itemgetter(1,0)))\n        \n        \n        return templist\n\n            \n            \n        \n       \n         \n        \n            \n        \n\n            \n        \n        \n        \n            \n            # templist.append(sorted(dic[key]))\n            \n        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        hmap = defaultdict(list)\n        x_min, x_max = 0, 0\n        queue = deque()\n        report = list()\n        if root:\n            queue.append((root, 0, 1))\n        else:\n            return report\n        \n        while queue:\n            root, x, y = queue.popleft()\n            \n            x_min = min(x, x_min)\n            x_max = max(x, x_max)\n            while y > len(hmap[x]):\n                hmap[x].append([])\n            hmap[x][-1].append(root.val)\n                \n            if root.left:\n                queue.append((root.left, x - 1, y + 1))\n            if root.right:\n                queue.append((root.right, x + 1, y + 1))\n                \n        print(hmap) \n        print(x_min, x_max)\n        for i in range(x_min, x_max + 1):\n            report.append([])\n            for l in hmap[i]:\n                print(l)\n                print(report)\n                if l:\n                    l.sort()\n                    report[-1].extend(l)\n        return report"]
["# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:\n        if root and root.val > val:\n            root.right = self.insertIntoMaxTree(root.right, val)\n            return root\n        node = TreeNode(val)\n        node.left = root\n        return node", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:\n        if root is None:\n            return TreeNode(val)\n        elif val > root.val:\n            n = TreeNode(val)\n            n.left = root\n            return n\n        else:\n            n = root\n            p = None\n            while n is not None and val < n.val:\n                n, p = n.right, n\n            m = TreeNode(val)\n            p.right = m\n            m.left = n\n            return root", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n  def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:\n    if root and root.val > val:\n      root.right = self.insertIntoMaxTree(root.right, val)\n      return root\n\n    node = TreeNode(val)\n    node.left = root\n    return node", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n'''\nAlso recursive.\nBase case: old tree is empty\n    - TreeNode(new elem, None, None)\nCase 1: new elem > max elem in tree.\n    - Then new tree should be TreeNode(new elem, old tree, None)\nCase 2: new elem < max elem in tree\n    - Then right subtree needs to be updated (recurse)\n    - New tree = TreeNode(max elem, left subtree, new right subtree)\n'''\n\n\nclass Solution:\n    def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:\n        if not root:\n            return TreeNode(val, None, None)\n        if val > root.val:\n            return TreeNode(val, root, None)\n        else:\n            # val < root.val\n            return TreeNode(root.val, root.left, self.insertIntoMaxTree(root.right, val))", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:\n        node = TreeNode(val)\n        if not root:\n            return node\n        if val > root.val:\n            node.left = root\n            return node\n        right = self.insertIntoMaxTree(root.right, val)\n        root.right = right\n        return root", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findTree(self,root,node):\n        if not root:\n            return node\n        if node.val>root.val:\n            node.left = root\n            return node\n        root.right = self.findTree(root.right, node)\n        return root\n        \n    def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:\n        return self.findTree(root, TreeNode(val))", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n    def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:\n        def helper(root,val):\n            if root is None:\n                return TreeNode(val)\n            if val > root.val:\n                return TreeNode(val,root,None)\n            root.right = helper(root.right,val)\n            return root\n        return helper(root,val)        \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:\n        node = TreeNode(val)\n        if not root or val > root.val:\n            node.left = root\n            return node\n        else:\n            root.right = self.insertIntoMaxTree(root.right, val)\n            return root", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:\n            \n        if not root: return TreeNode(val)\n        \n        if root.val<val: \n            node = TreeNode(val)\n            node.left=root\n            return node\n        else:\n            root.right = self.insertIntoMaxTree(root.right, val)\n                    \n        return root\n    \n    \n        # if(root==None):\n        #     return TreeNode(val)       \n        # if(root.val<val):\n        #         temp = TreeNode(val)\n        #         temp.left = root\n        #         return temp\n        # else:\n        #         root.right = self.insertIntoMaxTree(root.right, val)\n        # return root    \n", "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    \n    def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:\n        self.arr = []\n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.arr.append(root.val)\n                inorder(root.right)\n        def solve(nums):\n            if len(nums):\n                #print(nums)\n                mx = nums.index(max(nums))\n                root  = TreeNode(nums[mx])\n                root.left = solve(nums[:mx])\n                root.right = solve(nums[mx+1:])\n                return root\n        \n    \n        inorder(root)\n        self.arr.append(val)\n        return solve(self.arr)\n        \n"]
["from collections import defaultdict\nfrom itertools import chain\nimport re\n\nPARSE = re.compile(r'[pP]\\d+|q')\n\ndef magic_call_depth_number(prog):\n    \n    def parse(it, p=''):\n        for m in it:\n            if m[0].startswith('p'): parse(it, m[0])\n            elif m[0]=='q':          return\n            else:                    pCmds[p].append(m[0].lower())\n    \n    def travel(p, seen, d=1):\n        if not pCmds[p]:\n            yield 0\n        else:\n            for n in pCmds[p]:\n                if n in seen: yield d\n                else:         yield from travel(n, seen|{n}, d+1)\n    \n    pCmds = defaultdict(list)\n    parse(PARSE.finditer(prog))\n    inf = list(chain.from_iterable(travel(p, {p}) for p in pCmds['']))\n    \n    return [min(inf, default=0), max(inf, default=0)]\n", "import re\nfrom collections import defaultdict, deque\ndef magic_call_depth_number(s):\n    adjacent = defaultdict(list)\n    for i, j, k in re.findall(r'(p\\d+)(.+?)(q)', s):\n        for n in re.findall(r'P\\d+', j):\n            adjacent[i.upper()].append(n)\n    \n    s, depths = re.sub(r'p.+?q', '', s), []\n    \n    def BFS(start):\n        Q = deque([[start, 1, []]])\n        while Q:\n            node, depth, path = Q.popleft()\n            path.append(node)\n            if not adjacent[node] : depths.append(0)\n            for i in adjacent[node]:\n                if i not in path : Q.append([i, depth + 1, path[:]])\n                else : depths.append(depth)\n                \n    [BFS(i) for i in re.findall(r'P\\d+', s)]\n    return [min(depths), max(depths)] if depths else [0,0]", "import re\ndef functrion_L(Q):\n     findall_elements = {F : re.findall('P(\\d+)',V) for F,V in re.findall('p(\\d+)([^q]+)',Q)}\n     return findall_elements\n\ndef H(Q) :\n  M = functrion_L(Q)\n  R = [9E9,0]\n  def H(V,S = set(),C = 0) :\n    if V in S :\n      R[:] = min(R[0],C),max(R[1],C)\n      return 9\n    S.add(V)\n    T = 0\n    for B in M[V] : T = H(B,S,-~C) or T\n    R[0] = R[0] if T else 0\n    S.remove(V)\n    return R[0]\n  for V in re.findall('P(\\d+)',re.sub('p(\\d+)([^q]+)','',Q)) : H(V)\n  return [R[0] if R[0] < 9E9 else 0,R[1]]\nmagiCallDepthNumber = magic_call_depth_number = H", "import re\ndef H(Q) :\n    M,R = {F : re.findall('P(\\d+)',V) for F,V in re.findall('p(\\d+)([^q]+)',Q)},[9E9,0]\n    def H(V,S = set(),C = 0) :\n        if V in S :\n            R[:] = min(R[0],C),max(R[1],C)\n            return 9\n        S.add(V)\n        T = 0\n        for B in M[V] : T = H(B,S,-~C) or T\n        R[0] = R[0] if T else 0\n        S.remove(V)\n        return R[0]\n    for V in re.findall('P(\\d+)',re.sub('p(\\d+)([^q]+)','',Q)) : H(V)\n    return [R[0] if R[0] < 9E9 else 0,R[1]]\nmagiCallDepthNumber = magic_call_depth_number = H", "from re import compile\nbuild = compile(r\"P(\\d+)\").findall\nread = compile(r\"p(\\d+)(.*?)q\").sub\n\ndef magic_call_depth_number(pattern):\n    P = {}\n    def filling(w):\n        k, v = w.groups()\n        P[k] = set(build(v))\n        return \"\"\n    \n    def minimum(id1, S):\n        if id1 in S: return (False, -1)\n        if not P[id1]: return (True, 0)\n        mini = float('inf')\n        for id2 in P[id1]:\n            b, x = minimum(id2, S|{id1})\n            if b: return (True, 0)\n            mini = min(mini, x+1)\n        return (False, mini)\n    \n    def maximum(id1, S):\n        if id1 in S: return (True, -1)\n        if not P[id1]: return (False, 0)\n        res, maxi = (False, 0)\n        for id2 in P[id1]:\n            b, x = maximum(id2, S|{id1})\n            if b: res, maxi = res or b, max(maxi, x+1)\n        return (res, maxi)\n    \n    P[None] = set(build(read(filling, pattern)))\n    return [minimum(None, set())[1], maximum(None, set())[1]]", "def magic_call_depth_number(program):\n    templates = dict()\n    code = str()\n    \n    i = 0\n    while i < len(program):\n    \n        if program[i] != 'p':\n            code += program[i]\n        else:\n            i += 1\n            n = str()\n            while program[i].isdigit():\n                n += program[i]\n                i += 1\n            \n            template = str()\n            while program[i] != 'q':\n                template += program[i]\n                i += 1\n            \n            templates[n] = template\n        \n        i += 1\n    \n    mymin = 999\n    mymax = 0\n    \n    i = 0\n    while i < len(code):\n        while code[i] == 'F' or code[i] == 'L' or code[i] == 'R':\n            i += 1\n            while code[i].isdigit():\n                i += 1\n        \n        i += 1\n        n = str()\n        while i < len(code) and code[i].isdigit():\n            n += code[i]\n            i += 1\n        \n        # \u043e\u0431\u0440\u0430\u0440\u0431\u043e\u0442\u0430\u0442\u044c \u0432\u044b\u0437\u043e\u0432 Pn\n        min_max = calc_min_max([n], n, templates, 0)\n        mymin = min(mymin, min_max[0])\n        mymax = max(mymax, min_max[1])\n        \n    if mymax == 0:\n        mymin = 0\n    \n    return [mymin, mymax]\n\ndef calc_min_max(used, c, templates, depth):\n    mymin = 999\n    mymax = 0\n    \n    flag = 0\n    i = 0\n    while i < len(templates[c]):\n        while i < len(templates[c]) and (templates[c][i] == 'F' or templates[c][i] == 'L' or templates[c][i] == 'R'):\n            i += 1\n            while i < len(templates[c]) and (templates[c][i].isdigit()):\n                i += 1\n        \n        if not (i < len(templates[c])):\n            break\n        \n        i += 1\n        n = str()\n        while i < len(templates[c]) and templates[c][i].isdigit():\n            n += templates[c][i]\n            i += 1\n        \n        # \u0432 \u0432\u044b\u0437\u043e\u0432\u0435 Pc \u043f\u0440\u043e\u0438\u0437\u043e\u0448\u0451\u043b \u0432\u044b\u0437\u043e\u0432 Pn\n        flag = 1\n        if used.count(n):\n            loop_with_depth = depth + 1\n            mymin = min(mymin, loop_with_depth)\n            mymax = max(mymax, loop_with_depth)\n        else:\n            used_copy = used.copy()\n            used_copy.append(n)\n            min_max = calc_min_max(used_copy, n, templates, depth + 1)\n            mymin = min(mymin, min_max[0])\n            mymax = max(mymax, min_max[1])\n    \n    return [mymin if flag else 0, mymax]\n", "import re\n\nclass Pattern:\n    def __init__(self, definition, patterns):\n        self._name = re.findall(\"p([0-9]+)\", definition)[0]\n        self._calls = re.findall(\"P([0-9]+)\", definition)\n        patterns[self._name] = self\n    \n    def simulate(self, patterns, visited, depths, depth=0):\n        if self._name in visited:\n            depths.append(depth)\n            return\n            \n        if len(self._calls) == 0:\n            depths.append(0)\n            return\n            \n        visited.add(self._name)\n        for call in self._calls:\n            patterns[call].simulate(patterns, visited, depths, depth+1)\n        visited.remove(self._name)\n\ndef magic_call_depth_number(pattern):\n    patterns = {}\n    while True:\n        match = re.search(\"p[0-9]+[^q]*q\", pattern)\n        if match == None:\n            break\n        (start, end) = match.span()\n        pattern = pattern[0:start] + pattern[end:]\n        Pattern(match.group(0), patterns)\n        \n    depths = []\n    for e in re.findall(\"P([0-9]+)\", pattern):\n        visited = set()\n        patterns[e].simulate(patterns, visited, depths)\n    \n    if len(depths) == 0:\n        return [0, 0]\n    else:\n        return [min(depths), max(depths)]", "import re\n\ndef magic_call_depth_number(pattern):\n    subroutines = {} # list them by number\n    s = re.compile(r'p(\\d+)((P\\d+|[FLR]*\\d*)+)q')\n    subrout = s.search(pattern)\n    while subrout:\n        # put the subroutine in the dictionary\n        subroutines[\"P\" + subrout.group(1)] = tokens(subrout.group(2))\n        # extract this subroutine from the pattern and see if there are more\n        pattern = pattern.replace(subrout.group(0), \"\")\n        subrout = s.search(pattern)\n    # Make a tree\n    depths = walk_tree(tokens(pattern), [], subroutines)\n    return [min(depths), max(depths)]\n    \ndef tokens(pattern):\n    return re.findall(r'([PFLR]\\d*)', pattern)\n    \ndef walk_tree(token_list, stack, subroutine_dict):\n    depths = []\n    stops_here = True\n    for t in token_list:\n        if t.startswith(\"P\"):\n            stops_here = False\n            if t in stack:\n                depths.append(len(stack))\n            else:\n                depths.extend(walk_tree(subroutine_dict[t], stack + [t], subroutine_dict))\n    if stops_here:\n        depths.append(0)\n    return depths", "UPPER_BOUND = 1000000000\n\ndef test_call (current_function: str, functions: dict, stack: set):\n    min_n = UPPER_BOUND\n    max_n = 0\n\n    stack.add(current_function)\n    #print(\"    \" * len(stack), current_function, ' ', functions,\n    #        current_function in stack, sep='')\n    for next_funcion in functions[current_function]:\n        if next_funcion in stack:\n            min_n = min(min_n, 1)\n            max_n = max(max_n, 1)\n\n        else:\n            current_min, current_max = \\\n                    test_call(next_funcion, functions, stack)\n            current_min += 1\n            current_max += 1\n            if current_min < min_n:\n                min_n = current_min\n            if current_min == 1:\n                min_n = 0\n            if current_max != 1 and current_max > max_n:\n                max_n = current_max\n    stack.remove(current_function)\n    if min_n == UPPER_BOUND:\n        min_n = 0\n    if max_n < min_n:\n        max_n = min_n\n    return (min_n, max_n)\n\ndef read_function(s: str):\n    \"\"\"\n    return:\n        (function_#, [functions called])\n    \"\"\"\n    i = 0;\n    while (s[i] in \"0123456789\"):\n        i += 1\n\n    function_no = int(s[0:i])\n    function_calls = []\n\n    #print(\"Reading\", function_no)\n\n    while 1:\n        i = s.find('P', i)\n        if i < 0:\n            break;\n        nums = i + 1\n        i += 1\n        while i < len(s) and s[i] in \"0123456789\":\n            i += 1\n        nume = i\n        #print(\"    call from\", nums, \"to\", nume)\n        function_call = int(s[nums:nume])\n        function_calls.append(function_call)\n\n    return (function_no, function_calls)\n\ndef parse_program (program_s: str):\n    i = 0;\n    functions = {}\n\n    while 1:\n        i = program_s.find('p', i)\n        if i < 0:\n            break\n        funs = i + 1\n        i = program_s.find('q', i)\n        fune = i\n        func_no, fun_calls = read_function(program_s[funs:fune])\n        functions[func_no] = fun_calls\n\n\n    #print(\"Finish parsing\")\n    i = 0;\n    min_n, max_n = UPPER_BOUND, 0\n\n    while 1:\n        next_sof = program_s.find('p', i)\n        next_eof = program_s.find('q', i)\n        if (next_sof < 0):\n            next_sof = len(program_s)\n\n        #print(\"WTF\", next_sof, next_eof)\n\n        while 1:\n            i = program_s.find('P', i)\n            if i < 0 or i >= next_sof:\n                break;\n            nums = i + 1\n            i += 1\n            while i < len(program_s) and program_s[i] in \"0123456789\":\n                i += 1\n            nume = i\n            #print(\"Calling\", nums, nume)\n            function_call = int(program_s[nums:nume])\n            c_min_n, c_max_n = test_call(function_call, functions, set())\n            if c_min_n < min_n:\n                min_n = c_min_n\n            if c_max_n > max_n:\n                max_n = c_max_n\n\n        if i < 0 or next_eof < 0:\n            break\n        i = next_eof + 1\n\n\n    if min_n == UPPER_BOUND:\n        min_n = 0\n        max_n = 0\n\n    return [min_n, max_n]\n\n\ndef magic_call_depth_number(pattern):\n    return parse_program(pattern)\n\n\n"]
["def is_prime(n):\n    return n == 2 or n % 2 != 0 and all(n % k != 0 for k in range(3, root(n) + 1, 2))\n\ndef root(p):\n    return int(p ** 0.5)\n\ndef statement1(s):\n    return not(s % 2 == 0 or is_prime(s - 2))\n\ndef statement2(p):\n    return sum(statement1(i + p / i) for i in range(2, root(p) + 1) if p % i == 0) == 1\n\ndef statement3(s):\n    return sum(statement2(i * (s - i)) for i in range(2, s / 2 + 1)) == 1\n\ndef is_solution(a, b):\n    return statement1(a + b) and statement2(a * b) and statement3(a + b)\n", "# two numbers >= 2\ndef statement1(s):\n    #task: determine if\n    #sum determines that numbers cannot be determined from product without other info\n    return not prime(s-2) and not s%2 == 0 \n    #conclusion made:\n    #--> sum is odd --> two numbers are even,odd\n    #--> sum not prime + 2 --> two numbers are not 2,prime\ndef statement2(p):\n    #task: determine if\n    #numbers can be determined from product after knowing that statement 1 is true\n    l = [i for i in factor_pairs(p) if (i[0]>=2 and i[1] >=2)]\n    l_ = [i for i in l if statement1(sum(i))]\n    return l != l_ and len(l_) == 1\n    #conclusion made:\n    #--> statement one is true about exactly one factor pair's sum --> statement one\n    #(cont) is true about only one combination of numbers that make the sum\ndef statement3(s):\n    #task: determine if\n    #numbers can be determined from sum after knowing that statement 2 is true\n    return len([(i,s-i) for i in range(2,s//2+1) if statement2(i*(s-i))])==1\ndef is_solution(a, b):\n    #task: determine if\n    #statement 1,two,and 3 are true about the two numbers\n    return statement1(a+b) and statement2(a*b) and statement3(a+b)\ndef prime(x):\n    #determines if a number is prime\n    x = int(x)\n    for i in range(2,x):\n        if x % i == 0:\n            return False\n    return True\ndef factor_pairs(x):\n    res = set([])\n    for i in range(1,x):\n        if x%i == 0:\n            res.add(tuple(sorted(([i,x/i]))))\n    return sorted([[int(j) for j in i]for i in list(res)],key = lambda x: x[0])", "from math import sqrt\nis_prime    = lambda x: all(x%y!=0 for y in range(2,int(sqrt(x))+1))\nstatement1  = lambda s: s%2>0 and not is_prime(s-2)\nstatement2  = lambda p: 1 == sum(p%i==0 and statement1(i + p//i) for i in range(2,int(sqrt(p))+1))\nstatement3  = lambda s: 1 == sum(statement2(i * (s-i)) for i in range(2,s//2+1))\nis_solution = lambda a,b: statement1(a+b) and statement2(a*b) and statement3(a+b)\n", "from functools import reduce\n\ndef isPrime(n):\n    d = 2\n\n    while True:\n        if n % d == 0:\n            return False\n        if d * d > n:\n            return True\n        d += 1\n\ndef primeFactor(n):\n    d = 2\n    factors = []\n    while True:\n        if n % d == 0:\n            factors.append(d)\n            n = n // d\n        else:\n            d += 1\n        \n        if n == 1:\n            return factors\n        elif d * d > n:\n            return factors + [n]        \n\ndef get_cases(nums):\n    nums_plus = list(map(lambda x : x + 1, nums))\n    total_cases = reduce( lambda x, y: x * y, nums_plus)\n\n    for i in range(total_cases):\n        v = i\n        cases = []\n        for n in nums_plus:\n            cases.append(v % n)\n            v = v // n\n        yield(cases)\n\ndef statement1(s):\n    if s % 2 == 0:\n        return False\n    return not isPrime( s - 2)\n\ndef statement2(p):\n    factors = primeFactor(p)\n    \n    if len(factors) == 2:\n        return False\n\n    factors_set = set(factors)\n    factor_tuples = []\n    for factor in factors_set:\n        factor_tuples.append( (factor, factors.count(factor)) )\n    \n    sum_set = set()\n    nums = [x[1] for x in factor_tuples]    \n    for case in get_cases(nums):\n        v1 = v2 = 1\n        if sum(case) == 0 or sum(case) == len(factors):\n            continue\n\n        for i, n in enumerate(case):            \n            v1 *= factor_tuples[i][0] ** (factor_tuples[i][1] - n)\n            v2 *= factor_tuples[i][0] ** n            \n        \n        sum_set.add(v1 + v2)\n\n    if sum([statement1(x) for x in sum_set]) == 1:\n        return True\n    return False\n\ndef statement3(s):\n    if statement1(s) == False:\n        return False\n    \n    if sum([statement2(x * (s - x)) for x in range(2, s // 2 + 1)]) == 1:\n        return True\n    return False\n\ndef is_solution(a, b):\n    return statement3(a + b)", "import math\n\ndef statement1(s):\n    if s % 2 == 0: return False\n    if is_prime(s - 2): return False\n    return True\n\ndef statement2(p):\n    if p % 2 != 0: return False\n    facs = []\n    for i in range(2,int(math.sqrt(p))+1):\n        if p % i == 0:\n            facs.append((i, int(p / i)))\n    c = 0\n    for f in facs:\n        if statement1(f[0] + f[1]):\n            c += 1\n            if c > 1:\n                return False\n    return c == 1\n\ndef statement3(s):\n    c = 0\n    if not statement1(s): return False\n    for i in range(2, s // 2):\n        if statement2(i * (s - i)):\n            c += 1\n            if c > 1: return False\n    return c == 1\n\ndef is_solution(a, b):\n    return statement1(a + b) and statement2(a * b) and statement3(a + b)\n\n\ndef is_prime(n):\n    if n < 2 or (n > 2 and n % 2 == 0):\n        return False\n\n    for i in range(3,int(math.sqrt(n))+1,2):\n        if n % i== 0: \n            return False\n    return True", "def is_prime(n):\n    if n==2:\n        return True\n    for i in range(2, int(n**.5)+1):\n        if n%i==0: # no remainder\n            return False\n    return True\n        \ndef factor(n):\n    res = []\n    for i in range(2, int(n**.5)+1):\n        if n%i==0:\n            res.append((i,n//i))\n    return res\n\ndef statement1(s):\n    # Statement 1: \"Patricia cannot know what the two numbers are.\"\n    # so sum is not sum of 2 primes, since goldbach conjecture says\n    # all even numbers>3 can be written as sum of 2 primes\n    # then sum is not even\n    # if sum is even then statement 1 cannot be made\n    if s%2==0: return False\n    # so sum is odd, need to make sure that s-2 is not prime\n    elif is_prime(s-2): return False\n    # otherwise we are sure s cannot be written as sum of two primes  \n    else: return True\n\ndef statement2(p):\n    # Statement 2: \"In that case, I do know what the two numbers are.\"\n    # a,b not primes but patricia knows the numbers\n    # we know that sam's number is odd and cannot be written as 2+prime\n    # factor p into pairs of factors and sum the pairs up\n    # if sum is even, remove. if sum can be written as 2+prime, remove.\n    # if numbers in pair are both prime, remove\n    # if left with only one pair -> True; else -> False\n    factors = factor(p)\n    count = 0\n    for (f1, f2) in factors:\n        tests = [(f1+f2)%2!=0, not is_prime(f1+f2-2), not (is_prime(f1) and is_prime(f2))]\n        if all(tests): \n            count += 1\n    return count==1\n\ndef statement3(s):\n    # s needs to pass statement1 first\n    # then, get all pairs of number that sum up to s\n    # make sure that only 1 such pair passes statement2\n    if not statement1(s): return False\n    pairs = [(x, s-x) for x in range(2, s//2)]\n    count = 0\n    for p1, p2 in pairs:\n        if statement2(p1*p2):\n            count += 1\n    return count==1\n\ndef is_solution(a, b):\n    return all([statement1(a+b), statement2(a*b), statement3(a+b)])\n", "def isPrime(n):\n    return n is 2 or n % 2 is not 0 and all(n % i != 0 for i in range(3, int(n ** 0.5) + 1, 2))\n\ndef statement1(s):\n    return not (s % 2 is 0 or isPrime(s - 2))\n\ndef statement2(p):\n    return sum(statement1(i + int(p / i)) for i in range(2, int(p ** 0.5) + 1) if p % i == 0) is 1\n\ndef statement3(s):\n    return sum(statement2(i * (s - i)) for i in range(2, int(s / 2) + 1)) is 1\n\ndef is_solution(a, b):\n    return statement3(a + b)", "def statement1(s):\n    return not prime(s-2) and not s%2 == 0\ndef statement2(p):\n    l = [i for i in factor_pairs(p) if (i[0]>=2 and i[1] >=2)]\n    l_ = [i for i in l if statement1(sum(i))]\n    return l != l_ and len(l_) == 1\ndef statement3(s):\n    return len([(i,s-i) for i in range(2,s//2+1) if statement2(i*(s-i))])==1\ndef is_solution(a, b):\n    return statement1(a+b) and statement2(a*b) and statement3(a+b)\ndef prime(x):\n    for i in range(2,int(x)):\n        if int(x) % i == 0:\n            return False\n    return True\ndef factor_pairs(x):\n    res = set([])\n    for i in range(1,x):\n        if x%i == 0:\n            res.add(tuple(sorted(([i,x/i]))))\n    return sorted([[int(j) for j in i]for i in list(res)],key = lambda x: x[0])", "import itertools\n\ndef statement1(s):\n    return s%2 and not(is_prime(s-2))\n\ndef statement2(p):\n    \n    return len(get_posses(p)) == 1\n\n\n\ndef statement3(s):\n    posses = ( [a,s-a] for a in range(s))\n    posses = {tuple(sorted(i) ) for i in posses if min(i) >=2}\n    \n    finals = [ [a,b] for [a,b] in posses if statement2(a*b)]\n    return len(finals) == 1\n\ndef is_solution(a, b):\n    return statement1(a+b) and statement2(a*b) and statement3(a+b)\n    \ndef get_posses(p):\n    posses = [ (a,b)\n    for a,b in ineff_poss_factors(p)\n        if statement1(a+b)\n        ]\n    return posses\n    \ndef is_prime(n):\n    return len(list(prime_factors(n))) == 1\n    \ndef ineff_poss_factors(n):\n    for i in itertools.count(start = 2):\n        if i**2 > n: break\n        \n        if not (n%i):\n            yield (i, n//i)\n    \ndef prime_factors(n):\n    \n    for i in itertools.count(start = 2):\n        if i**2 > n: break\n        if not n% i:\n            yield i\n            n//= i\n    if n > 1:\n        yield n", "primes=[2,3,5,7,11,13,17,19,23,29,31]\nfor i in range(37,500,2):\n    if all(i%j for j in primes): primes.append(i)\n\ndef statement1(s): return s%2 and s-2 not in primes\n\ndef statement2(p):\n    possible_pairs=set()\n    for i in range(2,int(p**.5)+2):\n        if p%i==0:\n            possible_pairs.add((i,p//i))\n    good_pairs=[statement1(i+j) for i,j in possible_pairs]\n    return sum(good_pairs)==1\n\ndef statement3(s):\n    possible_pairs=set()\n    for i in range(2,s//2+2):\n        possible_pairs.add((i,s-i))\n    good_pairs=[statement2(i*j) for i,j in possible_pairs]\n    return sum(good_pairs)==1\n\ndef is_solution(a, b):\n    return statement1(a+b) and statement2(a*b) and statement3(a+b)"]
["class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        dcosts = sorted(costs, key=lambda i: i[0] - i[1])\n        n = len(costs) // 2\n        acost = sum(c[0] for c in dcosts[:n])\n        bcost = sum(c[1] for c in dcosts[n:])\n        return acost + bcost", "class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        # https://leetcode.com/problems/two-city-scheduling/discuss/297143/Python-faster-than-93-28-ms\n        # https://leetcode.com/problems/two-city-scheduling/discuss/278944/3-ways-to-solve.\n        res = 0\n        costs.sort(key = lambda x: x[1]-x[0], reverse = True)\n        for i in range(len(costs)//2):\n            res += costs[i][0]\n        for i in range(len(costs)//2, len(costs)):\n            res += costs[i][1]\n            \n        return res\n            \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        costs.sort(key=lambda x: (x[1]-x[0]), reverse=True)\n        print (costs)\n        ans=0\n        half=len(costs)//2\n        for i in range(half):\n            ans+= costs[i][0]\n        for i in range(half,len(costs)):\n            ans+=costs[i][1]\n        return ans\n            \n        \n", "\n# class Solution {\n#     public int twoCitySchedCost(int[][] costs) {\n#         int N = costs.length / 2;\n#         int[][] dp = new int[N + 1][N + 1];\n#         for (int i = 1; i <= N; i++) {\n#             dp[i][0] = dp[i - 1][0] + costs[i - 1][0];\n#         }\n#         for (int j = 1; j <= N; j++) {\n#             dp[0][j] = dp[0][j - 1] + costs[j - 1][1];\n#         }\n#         for (int i = 1; i <= N; i++) {\n#             for (int j = 1; j <= N; j++) {\n#                 dp[i][j] = Math.min(dp[i - 1][j] + costs[i + j - 1][0], dp[i][j - 1] + costs[i + j - 1][1]);\n#             }\n#         }\n#         return dp[N][N];\n#     }\n# }\n\n\nclass Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        N = len(costs) //2\n        dp = [[0]*(N+1) for _ in range(N+1)]\n        for i in range(1, N+1):\n            dp[i][0] = dp[i-1][0] + costs[i-1][0]\n        for j in range(1, N+1):\n            dp[0][j] = dp[0][j-1] + costs[j-1][1]\n        for i in range(1, N+1):\n            for j in range(1, N+1):\n                dp[i][j] = min(dp[i-1][j] + costs[i+j-1][0],\n                              dp[i][j-1] + costs[i+j-1][1])\n        for row in dp:\n            print(row)\n        return dp[N][N]\n", "class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        lc = len(costs)\n        c = lc//2\n        cost1 = 0\n        cost2 = 0\n        al = c\n        bl = c\n        for i in range(lc):\n            for j in range(i+1, lc):\n                if abs(costs[i][0]-costs[i][1]) < abs(costs[j][0]-costs[j][1]):\n                    costs[i], costs[j] = costs[j], costs[i]\n        \n        for i in range(lc):\n            if (costs[i][0] <= costs[i][1] and al>0) or bl==0:\n                cost1 += costs[i][0]\n                al -= 1\n            elif bl>0:\n                cost1 += costs[i][1]\n                bl -= 1\n        al = c\n        bl = c\n        for i in range(lc):\n            if (costs[i][0] < costs[i][1] and al>0) or bl == 0:\n                cost2 += costs[i][0]\n                al -= 1\n            elif bl>0:\n                cost2 += costs[i][1]\n                bl -= 1\n        return min(cost1,cost2)\n", "class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        N = len(costs)\n        dp = [0]+[float('inf')]*(N//2)\n        \n        for i in range(1, N+1):\n            \n            for j in range(N//2, 0, -1):\n                dp[j] = min(dp[j]+costs[i-1][1], dp[j-1]+costs[i-1][0])\n            dp[0] += costs[i-1][1]\n        # print(dp)\n        return dp[-1]", "class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        N = len(costs)//2\n        dp = [[0]*(N+1) for _ in range(N+1)]\n        for i in range(1, N+1):\n            dp[i][0] = dp[i-1][0]+costs[i-1][0]    \n        for i in range(1, N+1):\n            dp[0][i] = dp[0][i-1]+costs[i-1][1]\n            \n        for i in range(1, N+1):\n            for j in range(1, N+1):\n                dp[i][j] = min(dp[i-1][j]+costs[i+j-1][0], dp[i][j-1]+costs[i+j-1][1])\n                \n        return dp[-1][-1]\n            \n        \n", "class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        n = len(costs)\n        m = n // 2\n        dp = [10 ** 6] * (m + 1)\n        dp[m] = 0\n        for i in range(n - 1, -1, -1):\n            for j in range(m + 1):\n                k = i - j\n                c = 10 ** 6\n                if j < m:\n                    c = min(c, costs[i][0] + dp[j + 1])\n                if k < m:\n                    c = min(c, costs[i][1] + dp[j])\n                dp[j] = c\n        return dp[0]\n", "class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        m = len(costs)\n        n = m // 2\n        f = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(min(n, i) + 1):\n                f[i][j] = math.inf\n                if j > 0:\n                    f[i][j] = costs[i - 1][0] + f[i - 1][j - 1]\n                if i - j > 0:\n                    f[i][j] = min(f[i][j], costs[i - 1][1] + f[i - 1][j])\n        return f[m][n]", "class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        \n        c = []\n        asum = 0\n        for i in range(len(costs)):\n            a,b = costs[i]\n            price = b - a\n            asum += a\n            c.append(price)\n\n        refunds = sorted(c)\n        \n        for i in range(len(refunds) // 2):\n            asum += refunds[i]\n        \n        return asum", "class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        A, B, n = [], [], len(costs) // 2 # person id list\n        diff = []\n        for i, (a, b) in enumerate(costs):\n            diff.append((i, (a - b)))\n            if a < b:\n                A.append(i)\n            else:\n                B.append(i)\n            \n        \n        # print(diff)\n        # new_A, new_B = [], []\n        # diff_num = abs(len(A)-len(B))\n        flag = 0\n        if len(A) > len(B): # \u98de\u5230A\u7684\u591a, \u628adiff<0\u4e14\u503c\u8f83\u5c0f\u7684A\u653e\u5230B, \n            flag = 1\n            # \u4ece\u5927\u5230\u5c0f\u6392\u5e8f\n            diff = sorted(diff, key = lambda x: x[1], reverse=True)\n            for i, x in diff:\n                if x > 0 or i in B:\n                    continue\n                B.append(i)\n                if len(B) == n:\n                    break\n            \n        elif len(A) < len(B): # \u98de\u5230B\u7684\u591a, \u628adiff>0\u4e14\u503c\u8f83\u5c0f\u7684B\u653e\u5230A\n            # new_A = A\n            flag = 2\n            # \u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n            diff = sorted(diff, key = lambda x: x[1])\n            \n            for i, x in diff:\n                if i in A: continue\n                A.append(i)\n                if len(A) == n:\n                    break\n            \n        # print(flag, A, B)\n        res = 0\n        for i in range(2 * n):\n            a, b = costs[i]\n            if flag == 1:\n                res += b if i in B else a\n                  \n            if flag == 2 or flag == 0:\n                res += a if i in A else b                        \n      \n        return res\n            \n            \n            \n            \n            \n# [1,2], [2,3] ,[3,5],[4,5]\n       \n# 1 -> A 10\n# 2 -> A 30\n# 3 -> B 50\n# 4 -> B 20\n\n# # A = [10,30]\n# # B = [20,200]\n\n\n# 1 -> A 259\n\n\n# 2 -> B 54 -54 + 448 = 394\n# 3 -> B 667 -667 + 926 = 259 \n# 4 -> B 139 - 139 + 184 = 45 -> A\n# 5 -> B 118 - 118 + 840 = 772\n# 6 -> B 469 - 469 + 577 = 108\n\n# A = [259, 184, 577]\n# B = [54\uff0c 667\uff0c 118]\n\n\n# min(sum(A) + sum(B)) s.t. len(A) == len(B)\n\n\n\n", "class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        \n        diff = [cost[1]-cost[0] for cost in costs]\n        heapq.heapify(diff)\n        s = 0\n        for cost in costs:\n            s+=cost[0]\n        \n        for i in range(len(costs)//2):\n            s+=heapq.heappop(diff)\n        \n        \n        return s\n", "class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        \n        diffs = []\n        n = len(costs) / 2\n        \n        for i, cost in enumerate(costs):\n            a, b = cost\n            diff = abs(a-b)\n            diffs.append((i, diff))\n        \n        diffs = sorted(diffs, key=lambda x: x[1], reverse=True)\n        a_count = 0\n        b_count = 0\n        cost = 0\n        print(diffs)\n        for i, diff in diffs:\n            city_a = True\n            if costs[i][0] > costs[i][1]:\n                if b_count < n:\n                    b_count += 1\n                    cost += costs[i][1]\n                else:\n                    a_count += 1\n                    cost += costs[i][0]\n            else:\n                if a_count < n:\n                    a_count += 1\n                    cost += costs[i][0]\n                else:\n                    b_count += 1\n                    cost += costs[i][1]\n        return cost\n", "class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        \n        \n        hashmap = collections.defaultdict(int)\n        \n        for item in costs:\n            hashmap[tuple(item)] = abs(item[0]-item[1])\n            \n        print(hashmap)\n        \n        \n        ll = sorted(hashmap, key = lambda x:-hashmap[x])\n        \n        print(ll)\n        \n        n = len(ll)//2\n        mincostA = []\n        mincostB = []\n        \n        for i in range(2*n):\n            if len(mincostA) < n and len(mincostB) < n:\n                if ll[i][0] < ll[i][1]:\n                    mincostA.append(ll[i][0]) \n                else:\n                    mincostB.append(ll[i][1]) \n                    \n            elif len(mincostA) < n:\n                mincostA.append(ll[i][0])\n                \n            elif len(mincostB) < n:\n                mincostB.append(ll[i][1]) \n        \n        mincost  = 0\n        final = mincostA+mincostB\n        for i in range(2*n):\n            mincost += final[i] \n        \n        return mincost\n            \n            \n            \n        \n        \n        \n        \n        \n", "class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        costs.sort(key = lambda x:x[0]-x[1])\n        print(costs)\n        firsthalf = costs[0:len(costs)//2]\n        secondhalf = costs[len(costs)//2:]\n        return sum(f[0] for f in firsthalf) + sum(s[1] for s in secondhalf)\n", "class Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        n=len(costs)//2\n        dp=[ [0 for _ in range(n+1)] for _ in range(n+1) ]\n        \n        for i in range(1,n+1):\n            dp[i][0]=dp[i-1][0] +costs[i-1][0]\n        \n        for j in range(1,n+1):\n            dp[0][j] = dp[0][j-1] + costs[j-1][1]\n            \n        for a in range(1,n+1):\n            for b in range(1,n+1):\n                dp[a][b]=min(dp[a-1][b]+costs[a+b-1][0],dp[a][b-1]+costs[a+b-1][1])\n        #print (dp)\n        return dp[n][n]\n        \n", "# sort by difference, where greatest difference is first?\n# [[400, 50], [30, 200], [30, 20], [10, 20]]\n#   B           A           B         A\n\n# [[840, 118], [259, 770], [448, 54], [926, 667], [577, 469], [184, 139]]\n#       B           A           B          B          A            A \n\n# [[631, 42], [343, 819], [457, 60], [650, 359], [451, 713], [536, 709], [855, 779], [515, 563]]\n#      B          A           B          B           A           A           B           A\n\n# seemingly works for the given cases\n\n# why??\n\n# positives outweight the negatives \n# we will be positive for at least the first n iterations (worst case we pick one city for the first n iterations)\n\n# since we sorted by greatest difference first we will be maximizing our profits by taking \n# the optimal choice when the difference is greatest\n\n# we have costs[i] and costs[j] where i <= n and n < j < 2n and difference[i] > difference[j]\n# if we make the optimal choice we will be up difference[i] - difference[j]\n\nclass Solution:\n    def twoCitySchedCost(self, costs: List[List[int]]) -> int:\n        sortedCosts = sorted(costs, key = lambda x: abs(x[0] - x[1]), reverse=True)\n        numA = 0\n        numB = 0\n        res = 0\n        \n        for cost in sortedCosts:\n            if numB >= len(sortedCosts) / 2:\n                res += cost[0]\n            \n            elif numA >= len(sortedCosts) / 2:\n                res += cost[1]\n            \n            else:\n                if cost[0] < cost[1]:\n                    res += cost[0]\n                    numA += 1\n                else:\n                    res += cost[1]\n                    numB += 1\n        \n        return res\n"]
["# cook your dish here\nfrom collections import defaultdict\n\nclass sol():\n    def __init__(self,n,edges):\n        self.n = n\n        self.edges = edges\n        self.graph = self.create_graph()\n        self.precompute()\n        \n    def create_graph(self):\n        graph = defaultdict(list)\n        for e in self.edges:\n            u = e[0]\n            v = e[1]\n            w = e[2]\n            graph[u].append([v,w])\n            graph[v].append([u,w])\n        return graph\n        \n    def precompute(self):\n        self.maxiedges = [0]*6\n        self.B = [[0 for i in range(101)] for i in range(101)]\n        def func(u,v,l):\n            if l==2:\n                self.B[u][self.maxiedges[l]] += 1\n            else:\n                for j in self.graph[v]:\n                    self.maxiedges[l+1] = max(self.maxiedges[l],j[1])\n                    func(u,j[0],l+1)\n        for i in range(1,self.n+1):\n            func(i,i,0)\n            \n    def paths(self,X):\n        freq = 0\n        for u in range(1,self.n+1):\n            for x in range(X+1):\n                freq += 2*self.B[u][X]*self.B[u][x]\n            freq -= self.B[u][X]*self.B[u][X]\n        return freq\n        \nn, m = map(int, input().split())\nedges = []\nwhile m:\n    uvw = list(map(int, input().split()))\n    edges.append(uvw)\n    m -= 1\nq = int(input())\nGraph = sol(n,edges)\nwhile q:\n    query = int(input())\n    print(Graph.paths(query))\n    q -= 1\n", "# cook your dish here\nfrom collections import defaultdict\n\nclass sol():\n    def __init__(self,n,edges):\n        self.n = n\n        self.edges = edges\n        self.graph = self.create_graph()\n        self.precompute()\n        \n    def create_graph(self):\n        graph = defaultdict(list)\n        for e in self.edges:\n            u = e[0]\n            v = e[1]\n            w = e[2]\n            graph[u].append([v,w])\n            graph[v].append([u,w])\n        return graph\n        \n    def precompute(self):\n        self.maxiedges = [0]*6\n        self.B = [[0 for i in range(101)] for i in range(101)]\n        def func(u,v,l):\n            if l==2:\n                self.B[u][self.maxiedges[l]] += 1\n            else:\n                for j in self.graph[v]:\n                    self.maxiedges[l+1] = max(self.maxiedges[l],j[1])\n                    func(u,j[0],l+1)\n        for i in range(1,self.n+1):\n            func(i,i,0)\n            \n    def paths(self,X):\n        freq = 0\n        for u in range(1,self.n+1):\n            for x in range(X+1):\n                freq += 2*self.B[u][X]*self.B[u][x]\n            freq -= self.B[u][X]*self.B[u][X]\n        return freq\n        \nn, m = map(int, input().split())\nedges = []\nwhile m:\n    uvw = list(map(int, input().split()))\n    edges.append(uvw)\n    m -= 1\nq = int(input())\nGraph = sol(n,edges)\nwhile q:\n    query = int(input())\n    print(Graph.paths(query))\n    q -= 1\n    ", "# cook your dish here\n# cook your dish here\n\nfrom collections import defaultdict\n\nclass sol():\n    def __init__(self,n,edges):\n        self.n = n\n        self.edges = edges\n        self.graph = self.create_graph()\n        self.precompute()\n        \n    def create_graph(self):\n        graph = defaultdict(list)\n        for e in self.edges:\n            u = e[0]\n            v = e[1]\n            w = e[2]\n            graph[u].append([v,w])\n            graph[v].append([u,w])\n        return graph\n        \n    def precompute(self):\n        self.maxiedges = [0]*6\n        self.B = [[0 for i in range(101)] for i in range(101)]\n        def func(u,v,l):\n            if l==2:\n                self.B[u][self.maxiedges[l]] += 1\n            else:\n                for j in self.graph[v]:\n                    self.maxiedges[l+1] = max(self.maxiedges[l],j[1])\n                    func(u,j[0],l+1)\n        for i in range(1,self.n+1):\n            func(i,i,0)\n            \n    def paths(self,X):\n        freq = 0\n        for u in range(1,self.n+1):\n            for x in range(X+1):\n                freq += 2*self.B[u][X]*self.B[u][x]\n            freq -= self.B[u][X]*self.B[u][X]\n        return freq\n        \nn, m = map(int, input().split())\nedges = []\nwhile m:\n    uvw = list(map(int, input().split()))\n    edges.append(uvw)\n    m -= 1\nq = int(input())\nGraph = sol(n,edges)\nwhile q:\n    query = int(input())\n    print(Graph.paths(query))\n    q -= 1\n    ", "# cook your dish here\n# cook your dish here\n\nfrom collections import defaultdict\n\nclass sol():\n    def __init__(self,n,edges):\n        self.n = n\n        self.edges = edges\n        self.graph = self.create_graph()\n        self.precompute()\n        \n    def create_graph(self):\n        graph = defaultdict(list)\n        for e in self.edges:\n            u = e[0]\n            v = e[1]\n            w = e[2]\n            graph[u].append([v,w])\n            graph[v].append([u,w])\n        return graph\n        \n    def precompute(self):\n        self.maxiedges = [0]*6\n        self.B = [[0 for i in range(101)] for i in range(101)]\n        def func(u,v,l):\n            if l==2:\n                self.B[u][self.maxiedges[l]] += 1\n            else:\n                for j in self.graph[v]:\n                    self.maxiedges[l+1] = max(self.maxiedges[l],j[1])\n                    func(u,j[0],l+1)\n        for i in range(1,self.n+1):\n            func(i,i,0)\n            \n    def paths(self,X):\n        freq = 0\n        for u in range(1,self.n+1):\n            for x in range(X+1):\n                freq += 2*self.B[u][X]*self.B[u][x]\n            freq -= self.B[u][X]*self.B[u][X]\n        return freq\n        \nn, m = map(int, input().split())\nedges = []\nwhile m:\n    uvw = list(map(int, input().split()))\n    edges.append(uvw)\n    m -= 1\nq = int(input())\nGraph = sol(n,edges)\nwhile q:\n    query = int(input())\n    print(Graph.paths(query))\n    q -= 1\n    ", "# cook your dish here\n\nfrom collections import defaultdict\n\nclass sol():\n    def __init__(self,n,edges):\n        self.n = n\n        self.edges = edges\n        self.graph = self.create_graph()\n        self.precompute()\n        \n    def create_graph(self):\n        graph = defaultdict(list)\n        for e in self.edges:\n            u = e[0]\n            v = e[1]\n            w = e[2]\n            graph[u].append([v,w])\n            graph[v].append([u,w])\n        return graph\n        \n    def precompute(self):\n        self.maxiedges = [0]*6\n        self.B = [[0 for i in range(101)] for i in range(101)]\n        def func(u,v,l):\n            if l==2:\n                self.B[u][self.maxiedges[l]] += 1\n            else:\n                for j in self.graph[v]:\n                    self.maxiedges[l+1] = max(self.maxiedges[l],j[1])\n                    func(u,j[0],l+1)\n        for i in range(1,self.n+1):\n            func(i,i,0)\n            \n    def paths(self,X):\n        freq = 0\n        for u in range(1,self.n+1):\n            for x in range(X+1):\n                freq += 2*self.B[u][X]*self.B[u][x]\n            freq -= self.B[u][X]*self.B[u][X]\n        return freq\n        \nn, m = map(int, input().split())\nedges = []\nwhile m:\n    uvw = list(map(int, input().split()))\n    edges.append(uvw)\n    m -= 1\nq = int(input())\nGraph = sol(n,edges)\nwhile q:\n    query = int(input())\n    print(Graph.paths(query))\n    q -= 1\n    ", "# cook your dish here\n\nfrom collections import defaultdict\n\nclass sol():\n    def __init__(self,n,edges):\n        self.n = n\n        self.edges = edges\n        self.graph = self.create_graph()\n        self.precompute()\n        \n    def create_graph(self):\n        graph = defaultdict(list)\n        for e in self.edges:\n            u = e[0]\n            v = e[1]\n            w = e[2]\n            graph[u].append([v,w])\n            graph[v].append([u,w])\n        return graph\n        \n    def precompute(self):\n        self.maxiedges = [0]*6\n        self.B = [[0 for i in range(101)] for i in range(101)]\n        def func(u,v,l):\n            if l==2:\n                self.B[u][self.maxiedges[l]] += 1\n            else:\n                for j in self.graph[v]:\n                    self.maxiedges[l+1] = max(self.maxiedges[l],j[1])\n                    func(u,j[0],l+1)\n        for i in range(1,self.n+1):\n            func(i,i,0)\n            \n    def paths(self,X):\n        freq = 0\n        for u in range(1,self.n+1):\n            for x in range(X+1):\n                freq += 2*self.B[u][X]*self.B[u][x]\n            freq -= self.B[u][X]*self.B[u][X]\n        return freq\n        \nn, m = map(int, input().split())\nedges = []\nwhile m:\n    uvw = list(map(int, input().split()))\n    edges.append(uvw)\n    m -= 1\nq = int(input())\nGraph = sol(n,edges)\nwhile q:\n    query = int(input())\n    print(Graph.paths(query))\n    q -= 1\n    ", "\nfrom collections import defaultdict\n\nclass sol():\n    def __init__(self,n,edges):\n        self.n = n\n        self.edges = edges\n        self.graph = self.create_graph()\n        self.precompute()\n        \n    def create_graph(self):\n        graph = defaultdict(list)\n        for e in self.edges:\n            u = e[0]\n            v = e[1]\n            w = e[2]\n            graph[u].append([v,w])\n            graph[v].append([u,w])\n        return graph\n        \n    def precompute(self):\n        self.maxiedges = [0]*6\n        self.B = [[0 for i in range(101)] for i in range(101)]\n        def func(u,v,l):\n            if l==2:\n                self.B[u][self.maxiedges[l]] += 1\n            else:\n                for j in self.graph[v]:\n                    self.maxiedges[l+1] = max(self.maxiedges[l],j[1])\n                    func(u,j[0],l+1)\n        for i in range(1,self.n+1):\n            func(i,i,0)\n            \n    def paths(self,X):\n        freq = 0\n        for u in range(1,self.n+1):\n            for x in range(X+1):\n                freq += 2*self.B[u][X]*self.B[u][x]\n            freq -= self.B[u][X]*self.B[u][X]\n        return freq\n        \nn, m = map(int, input().split())\nedges = []\nwhile m:\n    uvw = list(map(int, input().split()))\n    edges.append(uvw)\n    m -= 1\nq = int(input())\nGraph = sol(n,edges)\nwhile q:\n    query = int(input())\n    print(Graph.paths(query))\n    q -= 1\n    ", "# cook your dish here\nfrom collections import defaultdict\n\nclass sol():\n    def __init__(self,n,edges):\n        self.n = n\n        self.edges = edges\n        self.graph = self.create_graph()\n        self.precompute()\n        \n    def create_graph(self):\n        graph = defaultdict(list)\n        for e in self.edges:\n            u = e[0]\n            v = e[1]\n            w = e[2]\n            graph[u].append([v,w])\n            graph[v].append([u,w])\n        return graph\n        \n    def precompute(self):\n        self.maxiedges = [0]*6\n        self.B = [[0 for i in range(101)] for i in range(101)]\n        def func(u,v,l):\n            if l==2:\n                self.B[u][self.maxiedges[l]] += 1\n            else:\n                for j in self.graph[v]:\n                    self.maxiedges[l+1] = max(self.maxiedges[l],j[1])\n                    func(u,j[0],l+1)\n        for i in range(1,self.n+1):\n            func(i,i,0)\n            \n    def paths(self,X):\n        freq = 0\n        for u in range(1,self.n+1):\n            for x in range(X+1):\n                freq += 2*self.B[u][X]*self.B[u][x]\n            freq -= self.B[u][X]*self.B[u][X]\n        return freq\n        \nn, m = map(int, input().split())\nedges = []\nwhile m:\n    uvw = list(map(int, input().split()))\n    edges.append(uvw)\n    m -= 1\nq = int(input())\nGraph = sol(n,edges)\nwhile q:\n    query = int(input())\n    print(Graph.paths(query))\n    q -= 1\n    ", "# cook your dish here\nfrom collections import defaultdict\n\nclass sol():\n    def __init__(self,n,edges):\n        self.n = n\n        self.edges = edges\n        self.graph = self.create_graph()\n        self.precompute()\n        \n    def create_graph(self):\n        graph = defaultdict(list)\n        for e in self.edges:\n            u = e[0]\n            v = e[1]\n            w = e[2]\n            graph[u].append([v,w])\n            graph[v].append([u,w])\n        return graph\n        \n    def precompute(self):\n        self.maxiedges = [0]*6\n        self.B = [[0 for i in range(101)] for i in range(101)]\n        def func(u,v,l):\n            if l==2:\n                self.B[u][self.maxiedges[l]] += 1\n            else:\n                for j in self.graph[v]:\n                    self.maxiedges[l+1] = max(self.maxiedges[l],j[1])\n                    func(u,j[0],l+1)\n        for i in range(1,self.n+1):\n            func(i,i,0)\n            \n    def paths(self,X):\n        freq = 0\n        for u in range(1,self.n+1):\n            for x in range(X+1):\n                freq += 2*self.B[u][X]*self.B[u][x]\n            freq -= self.B[u][X]*self.B[u][X]\n        return freq\n        \nn, m = map(int, input().split())\nedges = []\nwhile m:\n    uvw = list(map(int, input().split()))\n    edges.append(uvw)\n    m -= 1\nq = int(input())\nGraph = sol(n,edges)\nwhile q:\n    query = int(input())\n    print(Graph.paths(query))\n    q -= 1\n    "]
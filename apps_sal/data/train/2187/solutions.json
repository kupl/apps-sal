["\"\"\"\nCodeforces Round 257 Div 1 Problem C\n\nAuthor  : chaotic_iak\nLanguage: Python 3.3.4\n\"\"\"\n\ndef read(mode=2):\n    # 0: String\n    # 1: List of strings\n    # 2: List of integers\n    inputs = input().strip()\n    if mode == 0:\n        return inputs\n    if mode == 1:\n        return inputs.split()\n    if mode == 2:\n        return [int(x) for x in inputs.split()]\n\ndef write(s=\"\\n\"):\n    if isinstance(s, list): s = \" \".join(map(str,s))\n    s = str(s)\n    print(s, end=\"\")\n\n################################################### SOLUTION\n\n# croft algorithm to generate primes\n# from pyprimes library, not built-in, just google it\nfrom itertools import compress\nimport itertools\ndef croft():\n    \"\"\"Yield prime integers using the Croft Spiral sieve.\n\n    This is a variant of wheel factorisation modulo 30.\n    \"\"\"\n    # Implementation is based on erat3 from here:\n    #   http://stackoverflow.com/q/2211990\n    # and this website:\n    #   http://www.primesdemystified.com/\n    # Memory usage increases roughly linearly with the number of primes seen.\n    # dict ``roots`` stores an entry x:p for every prime p.\n    for p in (2, 3, 5):\n        yield p\n    roots = {9: 3, 25: 5}  # Map d**2 -> d.\n    primeroots = frozenset((1, 7, 11, 13, 17, 19, 23, 29))\n    selectors = (1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0)\n    for q in compress(\n            # Iterate over prime candidates 7, 9, 11, 13, ...\n            itertools.islice(itertools.count(7), 0, None, 2),\n            # Mask out those that can't possibly be prime.\n            itertools.cycle(selectors)\n            ):\n        # Using dict membership testing instead of pop gives a\n        # 5-10% speedup over the first three million primes.\n        if q in roots:\n            p = roots[q]\n            del roots[q]\n            x = q + 2*p\n            while x in roots or (x % 30) not in primeroots:\n                x += 2*p\n            roots[x] = p\n        else:\n            roots[q*q] = q\n            yield q\n\nn, = read()\ncr = croft()\nprimes = []\nfor i in cr:\n    if i < n:\n        primes.append(i)\n    else:\n        break\nprimes.reverse()\n\nused = [0] * (n+1)\nres = []\nfor p in primes:\n    k = n//p\n    tmp = []\n    while k:\n        if not used[k*p]:\n            tmp.append(k*p)\n            used[k*p] = 1\n        if len(tmp) == 2:\n            res.append(tmp)\n            tmp = []\n        k -= 1\n    if tmp == [p] and p > 2 and p*2 <= n and len(res) and res[-1][1] == p*2:\n        res[-1][1] = p\n        used[p*2] = 0\n        used[p] = 1\n\nprint(len(res))\nfor i in res:\n    print(\" \".join(map(str, i)))", "apples=int(input())\n\nif apples<=3:\n\n    print(0)\n\nelse:\n\n    halfpr=int(apples/2)\n\n    def primes(n):\n\n        isPrime = [True for i in range(n + 1)]\n\n        isPrime[0] = isPrime[1] = False\n\n        \n\n        idx = 2\n\n        while idx * idx <= n:\n\n            if isPrime[idx]:\n\n                for i in range(idx * 2, n, idx):\n\n                    isPrime[i] = False\n\n            idx += 1\n\n        \n\n        return isPrime\n\n\n\n    primeslist=primes(halfpr)\n\n    totallist=[False]*(apples+1)\n\n    applepairs=[]\n\n    for prime in range(len(primeslist)-1, 1, -1):\n\n        if primeslist[prime]:\n\n            numprimes=int(apples/prime)\n\n            primesx=[int(i*prime) for i in range(1, numprimes+1) if not totallist[i*prime]]\n\n            if len(primesx)%2==1:\n\n                primesx.remove(2*prime)\n\n            for pr in primesx:\n\n                 applepairs.append(pr)\n\n                 totallist[pr]=True\n\n    print(int(len(applepairs)/2))\n\n    for t in range(int(len(applepairs)/2)):\n\n        print(applepairs[2*t], applepairs[2*t+1])\n\n        \n\n\n\n\n\n# Made By Mostafa_Khaled\n"]
["\n import re\n \n \n class Solution:\n     def calc(self, a, b, op):\n         if op == '+':\n             for k, v in b.items():\n                 a[k] = a.get(k, 0) + v\n             return a\n         elif op == '-':\n             for k, v in b.items():\n                 a[k] = a.get(k, 0) - v\n             return a\n         elif op == '*':\n             t = {}\n             for k1, v1 in a.items():\n                 for k2, v2 in b.items():\n                     t[tuple(sorted(k1+k2))] = t.get(tuple(sorted(k1+k2)), 0) + v1 * v2\n             return t\n \n     def basicCalculatorIV(self, expression, evalvars, evalints):\n         vars = {n:v for n,v in zip(evalvars, evalints)}\n         d = []  # operands\n         op = []\n         priority = {'(': 0, '+': 1, '-': 1, '*': 2}\n         for t in re.findall(r'\\(|\\)|[a-z]+|[0-9]+|[\\+\\-\\*]', expression):\n             if t[0].isdigit():\n                 d.append({tuple():int(t)})\n             elif t[0].isalpha():\n                 if t in vars:\n                     d.append({tuple():vars[t]})\n                 else:\n                     d.append({(t,): 1})\n             elif t == '(':\n                 op.append(t)\n             elif t == ')':\n                 while op and op[-1] != '(':\n                     d.append(self.calc(d.pop(-2), d.pop(-1), op.pop()))\n                 op.pop()\n             elif t in '+-*':\n                 if not op or priority[t] > priority[op[-1]]:\n                     op.append(t)\n                 else:\n                     while op and priority[t] <= priority[op[-1]]:\n                         d.append(self.calc(d.pop(-2), d.pop(-1), op.pop()))\n                     op.append(t)\n         while op:\n             d.append(self.calc(d.pop(-2), d.pop(-1), op.pop()))\n \n         res = []\n         for k in sorted(d[0].keys(), key=lambda x: (-len(x), x)):\n             v = d[0][k]\n             if v != 0:\n                 if not k:\n                     res.append(str(v))\n                 else:\n                     res.append('%s*%s' % (v, '*'.join(k)))\n         return res\n", "from collections import Counter\n \n class Poly():\n     def __init__(self,v):\n         self.c = Counter()\n         self.c[''] = 0\n         \n         if isinstance(v,int):\n             self.c[''] = v\n         elif isinstance(v,str):\n             self.c[v] = 1\n         elif isinstance(v,Counter):\n             self.c = v\n     \n     def __add__(self,other):\n         cn = Counter()\n         for el,c in self.c.items():\n             cn[el] += c\n         for el, c in other.c.items():\n             cn[el] += c\n         return Poly(cn)\n     \n     def __sub__(self,other):\n         cn = Counter()\n         for el,c in self.c.items():\n             cn[el] += c\n         for el, c in other.c.items():\n             cn[el] -= c\n         return Poly(cn)\n     \n     def __mul__(self,other):\n         cn = Counter()\n         for el1, v1 in self.c.items():\n             for el2, v2 in other.c.items():\n                 #print(el1.split('*'))\n                 sn = '*'.join(sorted(it for it in el1.split('*')+el2.split('*') if it != ''))\n                 cn[sn] += v1*v2\n         return Poly(cn)\n     \n     def toList(self):\n         vet = []\n         def comp(key):\n             el = key[0]\n             v = [it for it in el.split('*') if it != '']\n             return (-len(v),v)\n         \n         for el,v in sorted(self.c.items(), key = comp):\n             #print(len(el),el,v)\n             if v == 0:\n                 continue\n             \n             vap = [str(v)]\n             vap += [it for it in el.split('*') if it != '']\n             #print(vap)\n             vet.append('*'.join(vap))\n         \n         return vet\n     \n     def __str__(self):\n         return str(self.c)\n \n def rfind(vet,v):\n     for i in range(len(vet)-1,-1,-1):\n         if vet[i] == v:\n             return i\n     return -1\n \n class Solution:\n     def basicCalculatorIV(self, expression, evalvars, evalints):\n         \"\"\"\n         :type expression: str\n         :type evalvars: List[str]\n         :type evalints: List[int]\n         :rtype: List[str]\n         \"\"\"\n         \n         valToInt = dict(zip(evalvars,evalints))\n         self.i = 0\n         def parse():\n             parsed = []\n             while self.i < len(expression):\n                 ch = expression[self.i]\n                 if ch.isalpha():\n                     s = ''\n                     while self.i < len(expression) and expression[self.i].isalpha():\n                         s += expression[self.i]\n                         self.i += 1\n                     parsed.append(s if s not in valToInt else valToInt[s])\n                 elif ch.isdigit():\n                     s = ''\n                     while self.i < len(expression) and expression[self.i].isdigit():\n                         s += expression[self.i]\n                         self.i += 1\n                     parsed.append(int(s))\n                 elif ch in '+-*':\n                     self.i += 1\n                     parsed.append(ch)\n                 elif ch == '(':\n                     self.i += 1\n                     parsed.append(parse())\n                 elif ch == ')':\n                     self.i += 1\n                     return parsed\n                 else:\n                     self.i += 1\n             return parsed\n         \n         parsed = parse()\n         \n         def polyPlus(vet):\n             if '+' in vet:\n                 i = vet.index('+')\n                 #print(polyPlus(vet[:i])+polyPlus(vet[i+1:]))\n                 return polyPlus(vet[:i])+polyPlus(vet[i+1:])\n             return polyMinus(vet)\n         \n         def polyMinus(vet):\n             if '-' in vet:\n                 i = rfind(vet,'-')\n                 #print(polyMinus(vet[:1])-polyMinus(vet[2:]))\n                 return polyMinus(vet[:i])-polyMinus(vet[i+1:])\n             return polyTimes(vet)\n         \n         def polyTimes(vet):\n             if '*' in vet:\n                 i = vet.index('*')\n                 return polyTimes(vet[:i])*polyTimes(vet[i+1:])\n             return polyElement(vet)\n         \n         def polyElement(vet):\n             if len(vet) == 0:\n                 return Poly(None)\n             assert len(vet) == 1\n             el = vet[0]\n             if isinstance(el,list):\n                 return polyPlus(el)\n             return Poly(el)\n             \n         polyAns = polyPlus(parsed)\n         ans = polyAns.toList()\n         return ans\n", "class Identifier:\n     def __init__(self, name):\n         self.name = name\n \n     def __str__(self):\n         return \"{}\".format(self.name)\n \n class Number:\n     def __init__(self, value):\n         self.value = value\n \n     def __str__(self):\n         return \"{}\".format(self.value)\n \n class Binary:\n     def __init__(self, op, left, right):\n         self.op = op\n         self.left = left\n         self.right = right\n \n     def __str__(self):\n         return \"({} {} {})\".format(self.left, self.op, self.right)\n \n class Solution:\n     def basicCalculatorIV(self, expression, evalvars, evalints):\n         \"\"\"\n         :type expression: str\n         :type evalvars: List[str]\n         :type evalints: List[int]\n         :rtype: List[str]\n         \"\"\"\n         variables = dict(zip(evalvars, evalints))\n \n         def lex(string):\n             output = []\n             i = 0\n             while i < len(string):\n                 if string[i] == \" \":\n                     i += 1\n                 elif string[i] in \"()*+-\":\n                     output.append(string[i])\n                     i += 1\n                 elif string[i].islower():\n                     j = i\n                     while j < len(string) and string[j].islower():\n                         j += 1\n                     name = string[i:j]\n                     output.append(Identifier(name))\n                     i = j\n                 elif string[i].isdigit():\n                     j = i\n                     while j < len(string) and string[j].isdigit():\n                         j += 1\n                     value = int(string[i:j])\n                     output.append(Number(value))\n                     i = j\n                 else:\n                     i += 1\n             return output\n \n         precedence = { \"*\" : 2, \"+\" : 1, \"-\" : 1 }\n \n         def parse(tokens, p = 0):\n             if not tokens:\n                 return tokens, None\n             elif tokens[0] == \"(\":\n                 tokens = tokens[1:]\n                 tokens, node = parse(tokens)\n                 if tokens[0] != \")\":\n                     return tokens, None\n                 tokens = tokens[1:]\n             elif isinstance(tokens[0], Identifier):\n                 name = tokens[0].name\n                 if name in variables:\n                     node = Number(variables[name])\n                 else:\n                     node = Identifier(name)\n                 tokens = tokens[1:]\n             elif isinstance(tokens[0], Number):\n                 node = Number(tokens[0].value)\n                 tokens = tokens[1:]\n             while tokens and tokens[0] in precedence and precedence[tokens[0]] > p:\n                 binary = tokens[0]\n                 tokens, right = parse(tokens[1:], precedence[binary])\n                 node = Binary(binary, node, right)\n             return tokens, node\n \n         def compare(a, b):\n             if a is None or b is None:\n                 return (b is None) - (a is None)\n             cmp = len(a) - len(b)\n             if cmp != 0:\n                 return cmp\n             a = \" \".join(a)\n             b = \" \".join(b)\n             return (a < b) - (a > b)\n \n         def evaluate(ast):\n             if isinstance(ast, Identifier):\n                 return [(1, [ast.name])]\n             elif isinstance(ast, Number):\n                 return [(ast.value, [])] if ast.value != 0 else []\n             elif isinstance(ast, Binary):\n                 left = evaluate(ast.left)\n                 right = evaluate(ast.right)\n                 if ast.op == \"*\":\n                     output = {}\n                     for a in left:\n                         for b in right:\n                             value = sorted(a[1] + b[1])\n                             key = \" \".join(value)\n                             if key not in output:\n                                 output[key] = 0\n                             output[key] += a[0] * b[0]\n                             if output[key] == 0:\n                                 del output[key]\n \n                     class K:\n                         def __init__(self, inner):\n                             self.inner = inner[1]\n                         \n                         def __lt__(self, other):\n                             return compare(self.inner, other.inner) > 0\n \n                     return sorted(map(lambda x: (x[1], x[0].split()), output.items()), key=K)\n                 elif ast.op in \"+-\":\n                     output = []\n                     left = iter(left)\n                     right = iter(right)\n                     a = next(left, None)\n                     b = next(right, None)\n                     while a or b:\n                         result = compare(a and a[1], b and b[1])\n                         if result > 0:\n                             output.append(a)\n                             a = next(left, None)\n                         elif result < 0:\n                             output.append(b if ast.op == \"+\" else (-b[0], b[1]))\n                             b = next(right, None)\n                         else:\n                             coeff = a[0] + b[0] if ast.op == \"+\" else a[0] - b[0]\n                             if coeff != 0:\n                                 output.append((coeff, a[1]))\n                             a = next(left, None)\n                             b = next(right, None)\n                     return output\n                 else:\n                     return None\n             else:\n                 return None\n \n         def format(expression):\n             return [\"*\".join([str(e[0])] + e[1]) for e in expression]\n \n         tokens = lex(expression)\n         _, ast = parse(tokens)\n         expression = evaluate(ast)\n         output = format(expression)\n \n         return output", "class Solution:\n     def basicCalculatorIV(self, expression, evalvars, evalints):\n         \"\"\"\n         :type expression: str\n         :type evalvars: List[str]\n         :type evalints: List[int]\n         :rtype: List[str]\n         \"\"\"\n         class C(collections.Counter):\n             def __add__(self, other):\n                 self.update(other)\n                 return self\n             def __sub__(self, other):\n                 self.subtract(other)\n                 return self\n             def __mul__(self, other):\n                 product = C()\n                 for x in self:\n                     for y in other:\n                         xy = tuple(sorted(x + y))\n                         product[xy] += self[x] * other[y]\n                 return product\n         vals = dict(zip(evalvars, evalints))\n         def f(s):\n             s = str(vals.get(s, s))\n             return C({(s,): 1}) if s.isalpha() else C({(): int(s)})\n         c = eval(re.sub('(\\w+)', r'f(\"\\1\")', expression))\n         return ['*'.join((str(c[x]),) + x)\n                 for x in sorted(c, key=lambda x: (-len(x), x))\n                 if c[x]]        ", "class Solution:\n     def basicCalculatorIV(self, expression, evalvars, evalints):\n         \"\"\"\n         :type expression: str\n         :type evalvars: List[str]\n         :type evalints: List[int]\n         :rtype: List[str]\n         \"\"\"\n         class C(collections.Counter):\n             def __add__(self, other):\n                 self.update(other)\n                 return self\n             def __sub__(self, other):\n                 self.subtract(other)\n                 return self\n             def __mul__(self, other):\n                 product = C()\n                 for x in self:\n                     for y in other:\n                         xy = tuple(sorted(x + y))\n                         product[xy] += self[x] * other[y]\n                 return product\n         vals = dict(zip(evalvars, evalints))\n         def f(s):\n             s = str(vals.get(s, s))\n             return C({(s,): 1}) if s.isalpha() else C({(): int(s)})\n         c = eval(re.sub('(\\w+)', r'f(\"\\1\")', expression))\n         return ['*'.join((str(c[x]),) + x)\n                 for x in sorted(c, key=lambda x: (-len(x), x))\n                 if c[x]]", "class Poly(collections.Counter):\n     def __add__(self, other):\n         self.update(other)\n         return self\n \n     def __sub__(self, other):\n         self.update({k: -v for k, v in other.items()})\n         return self\n \n     def __mul__(self, other):\n         ans = Poly()\n         for k1, v1 in self.items():\n             for k2, v2 in other.items():\n                 ans.update({tuple(sorted(k1 + k2)): v1 * v2})\n         return ans\n \n     def evaluate(self, evalmap):\n         ans = Poly()\n         for k, c in self.items():\n             free = []\n             for token in k:\n                 if token in evalmap:\n                     c *= evalmap[token]\n                 else:\n                     free.append(token)\n             ans[tuple(free)] += c\n         return ans\n \n     def to_list(self):\n         return [\"*\".join((str(v),) + k)\n                 for k, v in sorted(self.items(),\n                     key = lambda x: (-len(x[0]), x[0], x[1]))\n                 if v]\n \n # https://leetcode.com/problems/basic-calculator-iv/solution/\n class Solution(object):\n     def basicCalculatorIV(self, expression, evalvars, evalints):\n         evalmap = dict(zip(evalvars, evalints))\n \n         def combine(left, right, symbol):\n             if symbol == '+': return left + right\n             if symbol == '-': return left - right\n             if symbol == '*': return left * right\n             raise\n \n         def make(expr):\n             ans = Poly()\n             if expr.isdigit():\n                 ans.update({(): int(expr)})\n             else:\n                 ans[(expr,)] += 1\n             return ans\n \n         def parse(expr):\n             bucket = []\n             symbols = []\n             i = 0\n             while i < len(expr):\n                 if expr[i] == '(':\n                     bal = 0\n                     for j in range(i, len(expr)):\n                         if expr[j] == '(': bal += 1\n                         if expr[j] == ')': bal -= 1\n                         if bal == 0: break\n                     bucket.append(parse(expr[i+1:j]))\n                     i = j\n                 elif expr[i].isalnum():\n                     for j in range(i, len(expr)):\n                         if expr[j] == ' ':\n                             bucket.append(make(expr[i:j]))\n                             break\n                     else:\n                         bucket.append(make(expr[i:]))\n                     i = j\n                 elif expr[i] in '+-*':\n                     symbols.append(expr[i])\n                 i += 1\n \n             for i in range(len(symbols) - 1, -1, -1):\n                 if symbols[i] == '*':\n                     bucket[i] = combine(bucket[i], bucket.pop(i+1),\n                                         symbols.pop(i))\n \n             if not bucket: return Poly()\n             ans = bucket[0]\n             for i, symbol in enumerate(symbols, 1):\n                 ans = combine(ans, bucket[i], symbol)\n \n             return ans\n \n         P = parse(expression).evaluate(evalmap)\n         return P.to_list()\n         "]
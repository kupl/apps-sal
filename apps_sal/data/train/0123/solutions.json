["import math\nclass Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        s=0\n        c=0\n        r=0\n        x=math.factorial(N)\n        while(True):\n            c=x*((N-r-K)**(L-K))*(-1)**(r)//(math.factorial(N-r-K)*math.factorial(r))\n            if(c!=0):\n                s=(s+c)%(10**9+7)\n                r+=1\n            else:\n                return s\n", "import math\nclass Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        s=0\n        c=0\n        r=0\n        x=math.factorial(N)\n        while(True):\n            c=x*((N-r-K)**(L-K))*(-1)**(r)//(math.factorial(N-r-K)*math.factorial(r))\n            if(c!=0):\n                s=(s+c)%(10**9+7)\n                r+=1\n            else:\n                return s\n            \n", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        MOD = 10 ** 9 + 7\n        @lru_cache(None)\n        def dp(i, j):\n            if i < j: return 0\n            if i == 0:\n                return 1 if j == 0 else 0\n            # if i == j:\n            #     return math.factorial\n            a = dp(i - 1, j - 1) * (N - j + 1)\n            a += dp(i - 1, j) * (j - K if j > K else 0)\n            return a % MOD\n        return dp(L, N)\n            \n", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        mod = 10**9+7\n        def memo(f):\n            dic = {}\n\n            def f_alt(*args):\n                if args not in dic:\n                    dic[args] = f(*args)\n                return dic[args]\n            return f_alt\n\n        @memo\n        def play(N, L):\n            if L == 0:\n                return 1 if N == 0 else 0\n            if N > L:\n                return 0\n            return (N*play(N-1, L-1) + max(0, N-K)*play(N, L-1))%mod\n\n        return play(N, L)", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        dp = [[0] * (N + 1) for _ in range(L + 1)]\n        dp[0][0] = 1\n        for i in range(1, L + 1):\n            for j in range(1, N + 1):\n                dp[i][j] = dp[i - 1][j - 1] * (N - j + 1) #play new song\n                if j > K: #play old song\n                    dp[i][j] += dp[i - 1][j] * (j - K)\n        return dp[-1][-1]%(10 ** 9 + 7)\n                      \n                \n", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        mod = 10 ** 9 + 7\n        dp = [[0] * (L + 1) for _ in range(N + 1)]\n        \n        for i in range(1, N + 1):\n            for j in range(i, L + 1):\n                if i == K + 1:# or i == j:\n                    dp[i][j] = math.factorial(i)\n                else:\n                    dp[i][j] = dp[i - 1][j - 1] * i\n                    if j > i:\n                        dp[i][j] += dp[i][j - 1] * (i - K)\n                dp[i][j] %= mod\n        # print(dp)\n        return dp[N][L]\n", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        dp = [[0]*(N+1) for _ in range(L+1)]\n        dp[0][0] = 1\n        \n        for i in range(1,L+1):\n            for j in range(1,N+1):\n                dp[i][j] = dp[i-1][j-1]*(N-j+1)%(10**9+7)\n                if j > K:\n                    dp[i][j] = (dp[i][j] + dp[i-1][j] * (j-K))%(10**9+7)\n                    \n        return dp[L][N]            \n    \n        #T=O(NL) S=O(NL) \n        memo = {}\n        def DFS(i,j):\n            if i == 0:\n                return j==0\n            if (i,j) in memo:\n                return memo[(i,j)]\n            ans = DFS(i-1, j-1)*(N-j+1)\n            ans += DFS(i-1, j)* max(j-K,0)\n            memo[(i,j)] = ans%(10**9+7)\n            return memo[(i,j)]\n        \n        return DFS(L,N)", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        mod = 10 ** 9 + 7\n        dp = [[0] * (L + 1) for _ in range(N + 1)]\n        \n        for i in range(1, N + 1):\n            for j in range(i, L + 1):\n                if i == K + 1 or i == j:\n                    dp[i][j] = math.factorial(i)\n                else:\n                    dp[i][j] = dp[i - 1][j - 1] * i\n                    if j > i:\n                        dp[i][j] += dp[i][j - 1] * (i - K)\n                dp[i][j] %= mod\n        # print(dp)\n        return dp[N][L]\n", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        dp = [[0 for _ in range(N+1)] for _ in range(L+1)]\n        dp[0][0] = 1\n        mod = 10**9 + 7\n        for i in range(1, L+1):\n            for j in range(1, N+1):\n                dp[i][j] = dp[i-1][j-1] * (N-j+1)\n                if j > K:\n                    dp[i][j] += dp[i-1][j]*(j-K)\n                dp[i][j] %= mod\n                    \n        return dp[L][N]", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        dp = [1] * (L-N+1)\n        for p in range(2, N-K+1):\n            for i in range(1, L-N+1):\n                dp[i] += dp[i-1] * p\n                \n        ans = dp[-1]\n        for k in range(2, N+1):\n            ans *= k\n            \n        return ans % (10 ** 9 + 7)", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        # 11:35\n        # pick k+1 songs out of N Songs\n        # k+1 factorial\n        # you can pick a new song or old song from this k+1 => basically you got N options now\n        \n        mod=10**9+7\n        @lru_cache(None)\n        def helper(i,notplayed):\n            nonlocal mod\n            if i==L+1:\n                return 0 if notplayed!=0 else 1   \n            ans=(max((N-notplayed)-K,0)*helper(i+1,notplayed))%mod\n            if notplayed!=0:\n                ans+=(notplayed)*helper(i+1,notplayed-1)\n            return ans%mod\n        return helper(1,N)\n    \n    \n    \n            \n        \n                \n                \n           \n            \n        \n        \n        \n        \n        \n", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        BIG = 10**9+7\n        \n        @lru_cache(None)\n        def dp(r,n):\n            if r == 0: return 1 if n == 0 else 0\n            return ( dp(r-1,n-1) * (N-(n-1)) + dp(r-1,n) * max(0, n-K) ) % BIG\n        \n        \n        return dp(L, N)", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        @lru_cache(None)\n        def unique(length, uni):\n            if uni == 0:\n                return 0\n            if length == 1:\n                if uni == 1:\n                    return N\n                else:\n                    return 0\n            \n            ret = unique(length - 1, uni - 1) * (N - uni + 1)\n            ret += unique(length -1, uni) * max(0, uni - K)\n            \n            return ret % (10**9+7)\n        \n        return unique(L, N)", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        m = 10 ** 9 + 7\n        dp = [[0 for _ in range(N+1)] for _ in range(L+1)]\n        dp[0][0] = 1\n        for i in range(1,L+1):\n            for j in range(1,N+1):\n                dp[i][j] = (dp[i-1][j-1] * (N-j+1) + dp[i-1][j] * max(j-K,0))%m\n        \n        return int(dp[L][N])", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        mod = 10 ** 9 + 7\n        \n        @lru_cache(None)\n        def dp(l, n):\n            if not l:\n                return not n\n            return dp(l - 1, n - 1) * (N - n + 1) + dp(l - 1, n) * max(n - K, 0)\n        \n        return dp(L, N) % mod", "from functools import lru_cache\n\nclass Solution:\n    def numMusicPlaylists(self, N, L, K):\n        @lru_cache(None)\n        def dp(i, j):\n            if i == 0:\n                return +(j == 0)\n            ans = dp(i-1, j-1) * (N-j+1)\n            ans += dp(i-1, j) * max(j-K, 0)\n            return ans % (10**9+7)\n\n        return dp(L, N)", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        dp = [[0 for i in range(L+1)] for j in range(N+1)]\n        for i in range(1, len(dp)):\n            for j in range(1, len(dp[0])):\n                if i == j:\n                    dp[i][j] = math.factorial(i)\n                else:\n                    dp[i][j] = dp[i-1][j-1]*i + dp[i][j-1]*max((i-K), 0)\n        print(dp)\n        return dp[N][L]%(10**9+7)", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        dp = [0 for _ in range(L + 1)]\n        dp[0] = 1\n        for i in range(1, N + 1):\n            dp2 = [0 for _ in range (L + 1)]\n            for j in range(1, L + 1):\n                dp2[j] = dp[j - 1] * (N - i + 1) \n                dp2[j] += dp2[j - 1] * max(i - K, 0)\n            dp = dp2\n            \n        return dp[L] % (10**9 + 7)", "import math\nclass Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        mod = 10**9+7\n        dp = [[0 for _ in range(L+1)] for _ in range(N+1)]\n        dp[0][0]=1\n        for i in range(1,N+1):\n            for j in range(1,L+1):\n                    dp[i][j] = dp[i-1][j-1]*(N-i+1)%mod\n                    dp[i][j] += dp[i][j-1]*max(i-K,0)%mod\n        return dp[-1][-1]%mod", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        memo = {}\n        def dp(i, j):\n            if i == 0:\n                return j == 0\n            if (i, j) in memo: return memo[i, j]\n            memo[i, j] = dp(i - 1, j - 1) * (N - j + 1) + dp(i - 1, j) * max(j - K, 0)\n            return memo[i, j]\n        \n        return dp(L, N)%(10**9 + 7)\n                      \n                \n", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        # N = 10   L = 25    K = 4\n        # 1~10         24        3\n        # 2~9          23        2\n        #  Unique : L - N + 1       Extra : N-K+1\n        \n        dp = [1] * (L-N+1)\n        \n        for p in range(2,N-K+1):\n            for i in range(1,L-N+1):\n                dp[i] += p*dp[i-1]\n        \n        ans = dp[-1]\n        for k in range(2,N+1):\n            ans = ans * k\n        return ans% (10**9 + 7)\n        \n        \n        \n        \n        \n      \n        \n        \n        \n        \n        \n        \n        \n        \n        dp = [1] * (L-N+1)\n        print(dp)\n        for p in range(2, N-K+1):\n            for i in range(1, L-N+1):\n                \n                dp[i] += dp[i-1] * p\n                print((p,i, dp))\n        # Multiply by N!\n        ans = dp[-1]\n        for k in range(2, N+1):\n            ans *= k\n        return ans % (10**9 + 7)\n            \n", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        cache = {}\n        def dp(i, j):\n            if i == 0:\n                return +(j == 0)\n            if (i,j) in cache:\n                return cache[(i,j)]\n            ans = dp(i-1, j-1) * (N-j+1)\n            ans += dp(i-1, j) * max(j-K, 0)\n            ans %= (10**9+7)\n            cache[(i,j)] = ans\n            return ans\n\n        return dp(L, N)", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        \n        @lru_cache(None)\n        def dp(i, j):\n            if i == 0:\n                return j == 0\n            \n            return (dp(i-1, j) * max(0, j - K) + dp(i-1, j-1) * (N - j + 1)) % (10**9 + 7)\n        \n        return dp(L, N)", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        \n        dp = [[0 for n in range(N+1) ] for l in range(L+1)]\n        dp[0][0] = 1\n        for l in range(1, L+1):\n            for n in range(1, N+1):\n                dp[l][n] += dp[l-1][n-1] * (N-n+1)\n                dp[l][n] += dp[l-1][n] * max(n-K, 0)\n                dp [l][n] = dp [l][n] %  (10 **9+7)\n        return dp[L][N]", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        dp = [[0] * (N + 1) for _ in range(L + 1)]\n        dp[0][0] = 1;\n        for l in range(1, L + 1):\n            for n in range(1, N + 1):\n                dp[l][n] += dp[l - 1][n - 1] * (N - n + 1)\n                dp[l][n] += dp[l - 1][n] * max(n - K, 0)\n                dp[l][n] = dp[l][n] % (1000000007)\n        return dp[L][N]", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        mod = 10**9 + 7\n        memo = {}\n        # helper(i,j) returns the number of playlists of len i\n        # that have exactly j unique songs\n        def helper(i, j):\n            nonlocal N, K\n            if i==0:\n                if j==0:\n                    # base case\n                    # helper(0,0) returns 1\n                    return 1\n                else:\n                    return 0\n            if (i,j) in memo:\n                return memo[(i,j)]\n            ans = 0\n            # the jth song is unique,\n            # then the jth song has (N-(j-1)) possibilities\n            ans += helper(i-1, j-1)*(N-(j-1))\n            # the jth song is not unique\n            # it is the same as one of the previous songs\n            # then the jth song has max(0, j-K) possibilities\n            # since it can be the same as the previous K songs\n            ans += helper(i-1, j)*max(0, j-K)\n            memo[(i,j)]=ans%mod\n            return ans%mod\n        return helper(L, N)", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        memo = {}\n        def dp(i, j):\n            if i == 0: return 1 if j == 0 else 0\n            if (i, j) in memo: return memo[(i, j)]\n            # non repeat\n            ans = dp(i - 1, j - 1) * (N - (j - 1))\n            # repeat\n            ans += dp(i - 1, j) * max(0, j - K)\n            memo[(i, j)] = ans % (10 ** 9 + 7)\n            return memo[(i, j)]\n        return dp(L, N)", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        memo = {}\n        def dp(i, j):\n            if i == 0: return 1 if j == 0 else 0\n            if (i, j) in memo: return memo[(i, j)]\n            # non repeat\n            ans = dp(i - 1, j - 1) * (N - (j - 1))\n            # repeat\n            ans += dp(i - 1, j) * max(0, j - K)\n            memo[(i, j)] = ans % (10 ** 9 + 7)\n            return memo[(i, j)]\n        return dp(L, N)\n# from functools import lru_cache\n\n# class Solution:\n#     def numMusicPlaylists(self, N, L, K):\n#         @lru_cache(None)\n#         def dp(i, j):\n#             if i == 0:\n#                 return +(j == 0)\n#             ans = dp(i-1, j-1) * (N-j+1)\n#             ans += dp(i-1, j) * max(j-K, 0)\n#             return ans % (10**9+7)\n\n#         return dp(L, N)\n", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        @lru_cache(None)\n        def dp(i, j):\n            if i == 0:\n                return +(j == 0)\n            ans = dp(i-1, j-1) * (N-j+1)\n            ans += dp(i-1, j) * max(j-K, 0)\n            return ans % (10**9+7)\n\n        return dp(L, N)", "from functools import lru_cache\nclass Solution:\n    def numMusicPlaylists(self, N, L, K):\n        @lru_cache(None)\n        def dp(i, j):\n            if i == 0:\n                return +(j == 0)\n            ans = dp(i-1, j-1) * (N-j+1)\n            ans += dp(i-1, j) * (j-min(K, i-1))\n            return ans % (10**9+7)\n\n        return dp(L, N)\n            \n            \n", "from functools import lru_cache\n\nclass Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        # Dynamic Programming\n        # Let dp[i][j] be the number of playlists of length i that have exactly j unique songs.\n        # Time  complexity: O(NL)\n        # Space complexity: O(NL)\n        @lru_cache(None)\n        def dp(i, j):\n            if i == 0:\n                return +(j == 0)\n            ans = dp(i - 1, j - 1) * (N - j + 1)\n            ans += dp(i - 1, j) * max(j - K, 0)\n            return ans % (10**9 + 7)\n\n        return dp(L, N)\n\n", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        dp = [[0 for j in range(L+1)] for i in range(N+1)]\n        for i in range(K+1, N+1):\n            for j in range(i, L+1):\n                if i == j or i == K+1:\n                    dp[i][j] = math.factorial(i)\n                else:\n                    dp[i][j] = dp[i-1][j-1]*i + dp[i][j-1]*(i-K)\n        return dp[N][L]%(10**9+7)\n", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        '''\n         construct a 2d dp[i][j] where i is i different songs and\n         j is the length of the playlist, also track the remaining songs r:\n         for dp update, we have two options:\n         if i <= k:\n            1. add a new song to the list, r -= 1\n         else:\n            if r > L-j\n                1. add a new song to the list, r -= 1\n                2. add an existing song\n            else:\n                1. add a new song\n         ''' \n        @lru_cache(None)\n        def dp(unique, total, r):\n            if total == L:\n                return 1\n            if unique <= K:\n                return r * dp(unique+1, total+1, r-1)\n            else:\n                ans = 0\n                if r < L-total:\n                    # add an existing song\n                    ans += (unique-K) * dp(unique, total+1, r)\n                # add a new song\n                ans += r * dp(unique+1, total+1, r-1)\n                return ans\n\n        return dp(0, 0, N) % (10**9+7)", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        dp = [[0 for i in range(L + 1)] for j in range(N + 1)]\n        for i in range(K + 1, N + 1):\n            for j in range(i, L + 1):\n                if i == j or i == K + 1:\n                    dp[i][j] = math.factorial(i)\n                else:\n                    dp[i][j] = dp[i - 1][j - 1] * i + dp[i][j - 1] * (i - K)\n        return dp[N][L] % (10**9 + 7)", "class Solution:\n    import math\n    from functools import lru_cache\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        MOD = 1000000007\n\n        @lru_cache(maxsize=None)\n        def rec(n, l):\n            if l < n or n <= K:\n                return 0\n            elif l == n:\n                return math.factorial(n) % MOD\n            return (n * rec(n - 1, l - 1) + (n - K) * rec(n, l - 1)) % MOD\n\n        return rec(N, L)", "class Solution:\n    def numMusicPlaylists(self, N: int, L: int, K: int) -> int:\n        MOD = 10 ** 9 + 7\n        @lru_cache(None)\n        def dp(i, j):\n            if i < j: return 0\n            if i == 0:\n                return 1 if j == 0 else 0\n            if i == j:\n                return (math.factorial(N) // math.factorial(N - j)) % MOD\n            a = dp(i - 1, j - 1) * (N - j + 1)\n            a += dp(i - 1, j) * (j - K if j > K else 0)\n            return a % MOD\n        return dp(L, N)\n            \n"]
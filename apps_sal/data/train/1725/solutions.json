["mod = 12345787\nmat = [([1,1],[0,1,3]),\n       ([2,1,-1],[0,2,6,11]),\n       ([2,3,-1,-1],[0,2,10,23,70]),\n       ([3,3,-4,-1,1],[0,3,15,42,155,533]),\n       ([3,6,-4,-5,1,1],[0,3,21,69,301,1223,5103])]\n\nfor i in range(100): [m.append(sum(k*m[-1-i] for i,k in enumerate(c))%mod) for c,m in mat]\n\ndef circular_limited_sums(max_n, max_fn): return mat[max_fn-1][1][max_n]", "def circular_limited_sums(max_n, max_fn):\n    if max_n == 1:\n        return sum([1 for i in range(max_fn + 1) if i + i <= max_fn]) % 12345787\n\n    nexts = [list(filter(lambda x: i + x <= max_fn, range(max_fn + 1))) for i in range(max_fn + 1)]\n    result = 0\n    for ii in range(max_fn + 1):\n        v = [[1 if e in nexts[ii] else 0 for e in range(max_fn + 1)]]\n        for _ in range(max_n - 2):\n            v.append([0 for i in range(max_fn + 1)])\n            for i, e in enumerate(v[-2]):\n                for j in nexts[i]:\n                    v[-1][j] += e\n        result += sum([e for i, e in enumerate(v[-1]) if i + ii <= max_fn])\n    return result % 12345787", "# https://www.python-course.eu/python3_memoization.php\nclass Memoize:\n    def __init__(self, fn):\n        self.fn = fn\n        self.memo = {}\n    def __call__(self, *args):\n        if args not in self.memo:\n            self.memo[args] = self.fn(*args)\n        return self.memo[args]\n\n@Memoize\ndef linear_limited_sums(X,Y,head,tail):\n    if X == 1:\n        return 1 if head == tail else 0\n    if X == 2:\n        return 1 if head + tail <= Y else 0\n    return sum(linear_limited_sums(X-1,Y,head,T) for T in range(Y-tail+1))%12345787\n\ndef circular_limited_sums(X,Y):\n    return sum(linear_limited_sums(X,Y,head,tail) for head in range(Y+1) for tail in range(Y-head+1))%12345787", "dp = {}\n\ndef circular_limited_sums(max_n, max_fn):\n    if max_n == 1:\n        return (max_fn // 2) + 1\n    else:\n        s = 0\n        for i in range(max_fn + 1):\n            s += solve(max_n-1, max_fn, i, i)\n            s %= 12345787\n        return s\n\ndef solve(n, m, first, last):\n       \n    if (n,m,first,last) in dp:\n        return dp[(n,m,first,last)]\n        \n    if n == 1:\n        dp[(n,m,first,last)] = m - max(first, last) + 1\n        return dp[(n,m,first,last)]\n        \n        \n    \n    s = 0\n    for i in range(m - last + 1):\n        if first is None:\n            s += solve(n-1, m, i, i)\n        else:\n            s += solve(n-1, m, first, i) \n        s %= 12345787\n    \n    dp[(n,m,first,last)] = s\n    return dp[(n,m,first,last)]\n", "import numpy as np\n\ndef pow(mat, n):\n  if n == 1: return mat\n  mat2 = pow(mat, n//2)\n  mat2 = np.dot(mat2, mat2) % 12345787\n  if n % 2 == 1: mat2 = np.dot(mat2, mat) % 12345787\n  return mat2\n\ndef circular_limited_sums(max_n, m):\n  mat = np.zeros(shape=(m+1, m+1), dtype=np.int64)\n  for a in range(m+1):\n    for b in range(m+1):\n      if a+b <= m:\n        mat[a, b] = 1\n  return np.trace(pow(mat, max_n)) % 12345787\n\n", "def circular_limited_sums(max_n, max_fn):\n    p = 12345787\n    m = max_fn+1\n    v = [[int(f1==fn) for fn in range(m)] for f1 in range(m)]\n    for n in range(max_n-1):\n        v = [[sum(w[:m-fn])%p for fn in range(m)] for w in v]\n    return sum(sum(w[:m-f1])%p for f1, w in enumerate(v))%p\n", "MODULUS = 12345787\n\ndef circular_limited_sums(max_n, max_fn):\n    # Your Code Here\n    total = 0\n    for initial in range(max_fn + 1):\n        counts = {v: 0 for v in range(max_fn + 1)}\n        counts[initial] = 1\n        for n in range(1, max_n):\n            new_counts = {}\n            for v in range(max_fn + 1):\n                new_counts[v] = sum(counts[v_prev] for v_prev in range(max_fn - v + 1)) % MODULUS\n            counts = new_counts              \n        total += sum(counts[v] for v in range(max_fn - initial + 1)) % MODULUS\n    return total % MODULUS", "import numpy as np\n\ndef circular_limited_sums(max_n, max_fn):\n    if max_n == 1: return max_fn//2 + 1\n    if max_n == 2: return ((max_fn+1) * (max_fn+2))//2\n    t = np.matrix(np.flipud(np.tri(max_fn+1, max_fn+1, 0, object)))\n    k = t ** (max_n-2)\n    return (np.sum(k.dot(np.arange(max_fn+1, 0, -1)[:, None])) - np.sum(np.multiply(k.dot(t), np.logical_not(t)))) % 12345787", "def generate_table(max_n,max_fn):\n    a = []\n    a.append([[0 for __ in range(_ + 1) ] for _ in range(max_fn + 1)])\n    for j in range(max_fn + 1):\n        for k in range(j+1):\n            if j + k <= max_fn: a[0][j][k] = 1\n\n    i = 1\n    while 2**i + 1 <= max_n:\n        a.append([[0 for __ in range(_ + 1) ] for _ in range(max_fn + 1)])\n        for j in range(max_fn + 1):\n            for k in range(j+1):\n               a[i][j][k] = sum([a[i-1][max(j,c)][min(j,c)]*a[i-1][max(k,c)][min(k,c)] % 12345787 for c in range(max_fn+1)])\n        i += 1\n    return a\n\ndef linear(s1,s2,indices,table,max_fn):\n    index = indices[-1]\n    if len(indices) == 1:\n        return table[index][max(s1,s2)][min(s1,s2)] \n    else:\n        return sum([table[index][max(s1,s)][min(s1,s)]*linear(s,s2,indices[:-1],table, max_fn) for s in range(0,max_fn+1)])\n    \n\ndef circular_limited_sums(max_n, max_fn):\n    table = generate_table(max_n+1, max_fn)\n    lengths = [2**i + 1 for i in range(8)]\n    lengths = lengths[::-1]\n    m = max_n\n    indices = []\n    for index, length in enumerate(lengths):\n        while length - 1 <= m:\n            indices.append(7-index)\n            m -= (length - 1)\n    if len(indices) == 1:\n        return sum([table[indices[0]][s][s] for s in range(max_fn + 1)]) % 12345787\n    if len(indices) == 2:\n        return sum([table[indices[0]][max(s,t)][min(s,t)]*table[indices[1]][max(s,t)][min(s,t)] for s in range(max_fn+1) for t in range(max_fn+1)]) % 12345787\n    if len(indices) >= 3:\n        return sum([table[indices[0]][max(s,s1)][min(s,s1)]*table[indices[1]][max(s,s2)][min(s,s2)]*linear(s1,s2,indices[2:], table, max_fn) for s in range(max_fn+1) for s1 in range(max_fn+1) for s2 in range(max_fn+1)]) % 12345787\n", "def circular_limited_sums(max_n, max_fn):\n    FL=[[0]*(max_fn+1) for i in range(max_fn+1)]\n    for i in range(max_fn+1):\n        for j in range(max_fn+1):\n            if i==j: FL[i][j]=1\n    for x in range(max_n-1):\n        nextFL=[[0]*(max_fn+1) for i in range(max_fn+1)]\n        for i in range(max_fn+1):\n            for j in range(max_fn+1):\n                for k in range(max_fn+1):\n                    if j+k<=max_fn:\n                        nextFL[i][k]+=FL[i][j]\n        FL=nextFL\n    tot=0\n    for i in range(max_fn+1):\n        for j in range(max_fn+1):\n            if i+j<=max_fn: tot+=FL[i][j]\n    return tot%12345787"]
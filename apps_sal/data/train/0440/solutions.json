["class Solution:\n    def mirrorReflection(self, p: int, q: int) -> int:\n        while p % 2 == 0 and q % 2 == 0:\n            p = p // 2\n            q = q // 2\n        if p % 2 == 1 and q % 2 == 0:\n            return 0\n        elif p % 2 == 1 and q % 2 == 1:\n            return 1\n        else :\n            return 2        ", "class Solution:\n    def mirrorReflection(self, p: int, q: int) -> int:\n        pos = 0\n        wall = 0\n        traj = 1\n\n        while True:\n            if wall == 0 and pos == p:\n                return 2\n            elif wall == 1 and pos == p:\n                return 1\n            elif wall == 1 and pos == 0:\n                return 0\n\n            if traj == 1:\n                pos += q\n                if pos > p:\n                    pos = 2*p - pos\n                    traj *= -1\n            else:\n                pos -= q\n                if pos < 0:\n                    pos *= -1\n                    traj *= -1\n\n            wall = 1 - wall", "class Solution:\n    def mirrorReflection(self, p: int, q: int) -> int:\n        x, y = p, q\n        m = -q / p\n        wall = 1\n        while 1:\n            b = y - m * x\n            # print(x, y, m, b, wall)\n            # y = m * x + b\n            flag = 0\n            if flag == 0 and wall != 0:\n                # y = 0\n                temp = x\n                x = -b / m\n                if 0 <= x <= p:\n                    flag = 1\n                    y = 0\n                    wall = 0\n                else:\n                    x = temp\n            if flag == 0 and wall != 2:\n                # y = p\n                temp = x\n                x = (p - b) / m\n                if 0 <= x <= p:\n                    flag = 1\n                    y = p\n                    wall = 2\n                else:\n                    x = temp\n            if flag == 0 and wall != 3:\n                # x = 0\n                temp = y\n                y = b\n                if 0 <= y <= p:\n                    flag = 1\n                    x = 0\n                    wall = 3\n                else:\n                    y = temp\n            if flag == 0 and wall != 1:\n                # x = p\n                temp = y\n                y = m * p + b\n                if 0 <= y <= p:\n                    flag = 1\n                    x = p\n                    wall = 1\n                else:\n                    y = temp\n            if (round(x, 2), round(y,2)) == (p, 0):\n                return 0\n            if (round(x, 2), round(y,2)) == (p, p):\n                return 1\n            if (round(x, 2), round(y,2)) == (0, p):\n                return 2\n            m = -m\n", "class Solution:\n    def mirrorReflection(self, p: int, q: int) -> int:\n        def gcd(p, q):\n            while q > 0:\n                p, q = q, p % q \n            return p\n            \n        lcm = p * q // gcd(p, q)\n        if (lcm // q) % 2 == 0:\n            return 2\n        elif (lcm // p) % 2 == 1:\n            return 1\n        else:\n            return 0", "class Solution:\n    def mirrorReflection(self, p: int, q: int) -> int:\n        hm = {0: [p,0], 1:[p,p],2:[0,p]}\n        slope = (q-p)/p\n        if slope == 0:\n            return 1\n        start = [0,p]\n        while start:\n            #print(start)\n            \n            # Try y = 0\n            #slope * x2 = start[0] * slope - start[1]\n            x2 = start[0] - start[1]/slope\n            if x2 <= p:\n                start = [x2, p]\n                for i in hm:\n                    hm[i][1] = p - hm[i][1]\n            else: # X = p\n                #slope * (p - start[0]) = y2 - start[1]\n                y2 = start[1] + slope * (p - start[0])\n                #y2 = start[1]- slope * start[0]\n                start = [0, y2]\n                for i in hm:\n                    hm[i][0] = p - hm[i][0]\n        \n            for k in hm:\n                if hm[k] == [round(start[0], 5), round(start[1], 5)]:\n                    return k\n", "from fractions import Fraction as F\n\nclass Solution:\n    def mirrorReflection(self, p: int, q: int) -> int:\n        def line_y(x: int, x_0:int, y_0:int, d_x: int, d_y: int) -> int:\n            '''\n                Return the y coordinate of given x for the line defined by (x_0, y_0) and (d_x, d_y)\n            '''\n            return F(d_y, d_x) * (x - x_0) + y_0\n        \n        def line_x(y: int, x_0: int, y_0: int, d_x: int, d_y: int) -> int:\n            '''\n                Return the x coordinate of given y for the line defined by (x_0, y_0) and (d_x, d_y)\n            '''\n            return (y - y_0) / F(d_y, d_x) + x_0\n            \n        # (x, y) start position of the ray\n        # (d_x, d_y) direction of the ray\n        x_0, y_0, d_x, d_y = 0, 0, p, q\n        \n        while True:\n            if d_x > 0:\n                # Toward right                \n                y_intercept_right = line_y(p, x_0, y_0, d_x, d_y)\n\n                if y_intercept_right == p:\n                    return 1\n                elif y_intercept_right == 0:\n                    return 0\n                elif 0 < y_intercept_right < p:\n                    # hit right\n                    x_0, y_0, d_x, d_y = p, y_intercept_right, -d_x, d_y\n                elif y_intercept_right > p:\n                    # hit top\n                    x_0, y_0, d_x, d_y = line_x(p, x_0, y_0, d_x, d_y), p, d_x, -d_y\n                else:\n                    # y_intercept_right < 0\n                    # hit bottom\n                    x_0, y_0, d_x, d_y = line_x(0, x_0, y_0, d_x, d_y), 0, d_x, -d_y\n            else:\n                # Toward left\n                y_intercept_left = line_y(0, x_0, y_0, d_x, d_y)\n\n                if y_intercept_left == p:\n                    return 2\n                elif 0 < y_intercept_left < p:\n                    # hit left\n                    x_0, y_0, d_x, d_y = 0, y_intercept_left, -d_x, d_y\n                elif y_intercept_left > p:\n                    # hit top\n                    x_0, y_0, d_x, d_y = line_x(p, x_0, y_0, d_x, d_y), p, d_x, -d_y\n                else:\n                    # y_intercept_left < 0\n                    # hit bottom\n                    x_0, y_0, d_x, d_y = line_x(0, x_0, y_0, d_x, d_y), 0, d_x, -d_y", "class Solution:\n    def mirrorReflection(self, p: int, q: int) -> int:\n        targets = [(p, 0), (p, p), (0, p)]\n        from fractions import Fraction\n        x = y = 0\n        rx, ry = p, q\n        while (x, y) not in targets:\n            t = float('inf')\n            for v in [Fraction(-x, rx), Fraction(-y, ry), Fraction(p - x, rx), Fraction(p - y, ry)]:\n                if v > 0:\n                    t = min(t, v)\n                    \n            x, y = x + rx * t, y + ry * t\n            \n            if x == p or x == 0:\n                rx = -rx\n            if y == p or y == 0:\n                ry = -ry\n                \n        return targets.index((x, y))\n", "class Solution:\n    def mirrorReflection(self, p: int, q: int) -> int:\n        from fractions import Fraction as F\n        x = y = 0\n        rx, ry = p, q\n        targets = [(p, 0), (p, p), (0, p)]\n        while (x, y) not in targets:\n            t = float('inf')\n            for v in [F(-x, rx), F(-y, ry), F(p-x, rx), F(p-y, ry)]:\n                if v > 0:\n                    t = min(t, v)\n            \n            x += rx * t\n            y += ry * t\n            \n            if x == p or x == 0:\n                rx *= -1\n            if y == p or y == 0:\n                ry *= -1\n        \n        return 1 if x == y == p else 0 if x == p else 2\n", "class Solution(object):\n    def mirrorReflection(self, p, q):\n        from fractions import Fraction as F\n\n        x = y = 0\n        rx, ry = p, q\n        targets = [(p, 0), (p, p), (0, p)]\n\n        while (x, y) not in targets:\n            #Want smallest t so that some x + rx, y + ry is 0 or p\n            #x + rxt = 0, then t = -x/rx etc.\n            t = float('inf')\n            for v in [F(-x,rx), F(-y,ry), F(p-x,rx), F(p-y,ry)]:\n                if v > 0: t = min(t, v)\n\n            x += rx * t\n            y += ry * t\n\n            #update rx, ry\n            if x == p or x == 0: # bounced from east/west wall, so reflect on y axis\n                rx *= -1\n            if y == p or y == 0:\n                ry *= -1\n\n        return 1 if x==y==p else 0 if x==p else 2", "class Solution:\n    def mirrorReflection(self, p: int, q: int) -> int:\n        m = 1 \n        n = 1 \n        while m * p != n * q:\n            n += 1 \n            m = n * q // p \n        ## m and n cannot be both even \n        if n % 2 == 0:\n            return 2 \n        if n % 2 == 1:\n            if m % 2 == 1:\n                return 1 \n            else:\n                return 0 \n        \n", "class Solution:\n    def gcd(self, a: int, b: int) -> int:\n        if b == 0:\n            return a\n        return self.gcd(b, a % b)\n    def mirrorReflection(self, p: int, q: int) -> int:\n        if q == 0:\n            return 0\n        div = gcd(p, q)\n        h, v = p // div, q // div  # h(orizontal) and (v)ertical transits\n        if not h % 2:\n            return 2\n        if v % 2:\n            return 1\n        return 0", "\n    \nclass Solution:\n    def mirrorReflection(self, p: int, q: int) -> int:\n        from fractions import gcd\n        g=gcd(p,q)\n        p=(p/g)%2\n        q=(q/g)%2\n        \n        if p and q:\n            return 1\n        elif p:\n            return 0\n        else:\n            return 2", "class Solution:\n    def mirrorReflection(self, p: int, q: int) -> int:\n        #if p > q: p = q + p%q\n        start = [0, 'left', 'up']\n        if q == p: return 1\n        if q == 0: return 0\n        num = 0\n        while True:\n            num = num + 1\n            print(start)\n            tmp = []\n            if start[2] == 'up':\n                if start[0] + q <= p:\n                    if start[1] == 'left':\n                        tmp = [start[0] + q, 'right', 'up']\n                        if start[0] + q == p: return 1\n                    else:\n                        tmp = [start[0] + q, 'left', 'up']\n                        if start[0] + q == p: return 2\n                else:\n                    if start[1] == 'left':\n                        tmp = [2*p - start[0] - q, 'right', 'down']\n                    else:\n                        tmp = [2*p - start[0] - q, 'left', 'down']\n            else:\n                if start[0] - q >= 0:\n                    if start[1] == 'left':\n                        tmp = [start[0] - q, 'right', 'down']\n                        if start[0] - q == 0: return 0\n                    else:\n                        tmp = [start[0] - q, 'left', 'down']\n                else:\n                    if start[1] == 'left':\n                        tmp = [q - start[0], 'right', 'up']\n                        if start[0] - q == 0: return 0\n                    else:\n                        tmp = [q - start[0], 'left', 'up']\n            start = tmp\n            #if num == 5:\n                #break\n        \n", "class Solution:\n    def mirrorReflection(self, p: int, q: int) -> int:\n        from fractions import gcd\n        g = gcd(p, q)\n        p, q = (p / g) % 2, (q / g) % 2\n        return 1 if p and q else 0 if p else 2", "class Solution:\n    def mirrorReflection(self, p: int, q: int) -> int:\n        def determine_reflect_point(x1,y1,x2,y2):\n            slope=(y2-y1)/(x2-x1)\n            ref_slope=-slope\n            #line y=y2+ref_slope*(x-x2)\n            if abs(x2-p)<10**(-2):\n                val1=[0,y2+ref_slope*(-p)]\n                val2=[(0-y2)/ref_slope+p,0]\n                val3=[(p-y2)/ref_slope+p,p]\n            if abs(x2)<10**(-2):\n                val1=[p,y2+ref_slope*(p)]\n                val2=[(0-y2)/ref_slope+0,0]\n                val3=[(p-y2)/ref_slope+0,p]\n            if abs(y2)<10**(-2):\n                val1=[p,ref_slope*(p-x2)]\n                val2=[0,ref_slope*(0-x2)]\n                val3=[(p-0)/ref_slope+x2,p]\n            if abs(y2-p)<10**(-2):\n                val1=[p,p+ref_slope*(p-x2)]\n                val2=[0,p+ref_slope*(0-x2)]\n                val3=[x2,p]\n            \n            if 0<=val1[0]<=p and 0<=val1[1]<=p:\n                return x2,y2,val1[0],val1[1]\n            if 0<=val2[0]<=p and 0<=val2[1]<=p:\n                return x2,y2,val2[0],val2[1]\n            if 0<=val3[0]<=p and 0<=val3[1]<=p:\n                return x2,y2,val3[0],val3[1]\n        \n        p1=[0,0]\n        p2=[p,q]\n        while True:\n            \n            if abs(p2[0]-0)<10**(-2) and abs(p2[1]-p)<10**(-2):\n                return 2\n            if abs(p2[0]-p)<10**(-2) and (p2[1]-0)<10**(-2):\n                return 0\n            if abs(p2[0]-p)<10**(-2) and abs(p2[1]-p)<10**(-2):\n                return 1\n            p1[0],p1[1],p2[0],p2[1]=determine_reflect_point(p1[0],p1[1],p2[0],p2[1])\n        \n", "class Solution:\n    def mirrorReflection(self, p: int, q: int) -> int:\n        n = 1\n        \n        while (n*q % p):\n            n += 1\n            \n        m = n * q // p\n        \n        if n & 1 == 0:\n            return 2\n        elif m & 1 == 0:\n            return 0\n        else:\n            return 1"]
["MOVES = {(0,1), (0,-1), (1,0), (-1,0)}\n\ndef has_exit(maze):\n    posSet = {(x,y) for x in range(len(maze)) for y in range(len(maze[x])) if maze[x][y] == 'k'}\n    if len(posSet) != 1:\n        raise ValueError(\"There shouldn't be more than one kate\")\n    \n    seen = set(posSet)\n    while posSet:\n        x,y = posSet.pop()\n        if any(not (0 <= x+dx < len(maze) and 0 <= y+dy < len(maze[x+dx])) for dx,dy in MOVES):\n            return True\n        neighbors = {(x+dx, y+dy) for dx,dy in MOVES if 0 <= x+dx < len(maze) and 0 <= y+dy < len(maze[x+dx])\n                                                        and maze[x+dx][y+dy] == ' '\n                                                        and (x+dx, y+dy) not in seen}\n        posSet |= neighbors\n        seen   |= neighbors\n    return False", "def has_exit(maze):\n    W = len(maze[0])                                                    # W = width of the maze\n    S = W * len(maze)                                                   # S = total cells in the maze\n    frontier, unseen = set(), set()                                     # Declaring sets that we'll use for BFS\n    for position, content in enumerate(\"\".join(maze)):                  # Use 1D representation for unique address of each cell\n        (frontier.add, unseen.add, id)[\"k #\".index(content)](position)  # Populate our sets: put Kate into frontier, passages into unseen\n    assert len(frontier) == 1                                           # Check for one and only one Kate\n    while frontier:                                                     # Do we still have any options to move further?\n        position = frontier.pop()                                       # Take out one of the options\n        if min(position, S - position) < W or -~position % W < 2:       # Is it on the edge?\n            return True                                                 # If so, we found an exit! Hurray!\n        for way in (position - W,                                       # Look up\n                    position + W,                                       # Look down\n                    position - 1,                                       # Look left\n                    position + 1):                                      # Look right\n            if way in unseen:                                           # If there is no wall, there is a way\n                frontier.add (way)                                      # Let's add this to our options\n                unseen.remove(way)                                      # We've seen it already\n    return False                                                        # We are out of options. So saaaad :(", "def has_exit(m):\n    maze = [[x for x in row] for row in m]\n    if not check_edge(maze):\n        return False\n    if not check_kate(maze):\n        raise Exception(\"There should no be multiple Kates\")\n    \n    kate = find_kate(maze)\n    return find_way(maze, kate, kate)\n\n\ndef find_way(maze, position, previous_position, trace = []):\n    if is_exit(maze, position):\n        return True\n        \n    possible_ways = find_possible_ways(maze, position, previous_position)\n    \n    for possible_way in possible_ways:\n        if possible_way not in trace:\n            new_maze = move_kate(maze, possible_way, position)\n            if find_way(new_maze, possible_way, position, trace + [possible_way]):\n                return True\n        \n    return False\n\n\ndef find_possible_ways(maze, position, previous_position):\n    r, c = position\n    possible_ways = []\n    for pr, pc in [(r+1, c), (r, c+1), (r-1, c), (r, c-1)]:\n        if pr >= 0 and pr < len(maze) and pc >= 0 and pc < len(maze[0]):\n            if maze[pr][pc] == ' ' and (pr, pc) != previous_position:\n                possible_ways += [(pr, pc)]\n    return possible_ways   \n\n\ndef find_kate(maze):\n    for r in range(len(maze)):\n        for c in range(len(maze[0])):\n            if maze[r][c] == 'k':\n                return (r, c)\n\n\ndef move_kate(maze, new_position, previous_position):\n    nr, nc = new_position\n    pr, pc = previous_position\n    new_m = maze[:pr] + [maze[pr][:pc] + [' '] + maze[pr][pc+1:]] + maze[pr+1:]\n    return new_m[:nr] + [new_m[nr][:nc] + ['k'] + new_m[nr][nc+1:]] + new_m[nr+1:]\n\n\ndef check_edge(maze):\n    edges = maze[0]+maze[-1]+tr(maze)[0]+tr(maze)[-1]\n    if ' ' in edges or 'k' in edges:\n        return True\n    return False\n\n\ndef check_kate(maze):\n    count = 0\n    for r in range(len(maze)):\n        for c in range(len(maze[0])):\n            if maze[r][c] == 'k':\n                count += 1\n    return count == 1\n\n\ndef is_exit(maze, position):\n    width, length = len(maze)-1, len(maze[0])-1\n    if width in position or length in position or 0 in position:\n        return True\n    return False\n\n\ndef tr(mtx):\n    return [list(x) for x in zip(*mtx)]\n", "def has_exit(maze):\n    vector, w = list(\"\".join(maze)), len(maze[0])                # \"vector\" is 1D representation of the maze; \"w\" is the width of a maze row\n    assert vector.count(\"k\") == 1                                # checking if there is one and only one Kate in the maze\n    while \"k\" in vector:                                         # cycle that pushes Kate clones into previously unvisited adjacent cells\n        for p, cell in enumerate(vector):                        # sweeping the maze...\n            if cell == \"k\":                                      # ...for Kate clones\n                if min(p, len(vector) - p) < w or -~p % w < 2:   # Kate clone at edge?\n                    return True                                  # exit found!\n                for direction in (-w, 1, w, -1):                 # otherwise look at adjacent cells\n                    if  vector[p + direction] == \" \":            # to see if clone can pass through them\n                        vector[p + direction]  = \"k\"             # clone Kate where there is a passage\n                vector[p] = \"+\"                                  # mark cell as visited\n    return False                                                 # There is no exit :(\n", "move = lambda (r, c), maze: [(rr, cc) for rr, cc in [(r,c-1),(r,c+1),(r-1,c),(r+1,c)] if maze[rr][cc] != '#']\ndone = lambda where, maze: any(r * c == 0 or r == len(maze) - 1 or c == len(maze[0]) - 1 for r, c in where)\n\ndef has_exit(maze):  \n    where, seen = set([(r, c) for r in range(len(maze)) for c in range(len(maze[0])) if maze[r][c] == 'k']), set()\n    if len(where) != 1: raise ValueError('Wrong number of Kates')\n    \n    while where and not done(where, maze):\n        seen |= where\n        where = set([p for  a in [move(p, maze) for p in where] for p in a]) - seen\n    \n    return done(where, maze)", "#Approach: A breadth first search from the maze starting position; at each step see if\n# we have solved the maze (which is defined as walking out of the boundary of the maze)\nfrom copy import deepcopy\nimport queue\n\n\nclass MazeSymbols(object):\n    START_TILE = 'k'\n    WALL_TILE  = '#'\n    WALKABLE_TILE = ' '\n#---end class\n\nclass MazeStatus(object):\n    FOUND_EXIT      = 1\n    NO_EXIT_EXISTS  = 2\n    CONTINUE_SEARCH = 3\n    MAZE_VALID = 4\n    MAZE_ERROR_NO_START = 5\n    MAZE_ERROR_DUPLICATE_START = 6\n#---end class\n\n\n#Maze solver must deal with non-valid mazes, which constitute: No Start Position provided, \n# or multiple start positions found\nclass MazeSolver(object):\n\n\n    def __init__(self, mazeBoard):\n        self.mazeBoard = deepcopy(mazeBoard)\n        self.numRows   = len( self.mazeBoard    )\n        self.numCols   = len( self.mazeBoard[0] )\n        validStatus, startRow, startCol = self.__validateMaze__(self.mazeBoard)\n\n        if validStatus == MazeStatus.MAZE_VALID:\n            self.validMaze = True\n        else:\n            self.validMaze = False\n\n        self.startRow = startRow\n        self.startCol = startCol\n    #---end constructor\n\n\n\n    def isValidMaze(self):\n        return self.validMaze\n    #---end function\n\n\n    def attemptSolve(self):\n        nR = self.numRows\n        nC = self.numCols\n\n        hasVisited = [ [ False for _ in range(nC) ] for _ in range(nR) ]\n\n        mazeWalkResult =  self.__walkMaze__( self.mazeBoard, hasVisited, \n                                             nR, nC, self.startRow, self.startCol)\n        return mazeWalkResult\n    #---end function\n\n\n    def __validateMaze__(self, mazeBoard):\n\n        startPos = self.__findStartPosition__(mazeBoard)\n        if not startPos:\n            return MazeStatus.MAZE_ERROR_NO_START, -1, -1\n        elif len(startPos)>=2:\n            return MazeStatus.MAZE_ERROR_DUPLICATE_START, -1, -1\n        else:\n            startRow = startPos[0][0]\n            startCol = startPos[0][1]\n            return MazeStatus.MAZE_VALID, startRow, startCol\n    #---end function\n\n    #Find every possible start position in the maze\n    def __findStartPosition__(self, mazeBoard):\n        startPos = []\n        for i in range(self.numRows):\n            for j in range(self.numCols):\n                if self.mazeBoard[i][j] == MazeSymbols.START_TILE:\n                    startPos.append( [i, j])\n        return startPos   #Board does not have a start position\n    #---end function\n\n\n    #part of the logic to find all connected shapes\n    def __inImage__(self, i,j, nR, nC):\n        if 0<=i and i<nR  and 0<=j and j<nC:\n            return True\n        else:\n            return False\n    #-----end function\n\n\n    #part of the logic to find all connected shapes\n    #  A desired cell is one that is a ship symbol and has not been visited yet\n    def __isDesiredCell__(self, img, hasVisited, i, j):\n        if img[i][j] == MazeSymbols.WALKABLE_TILE   and   not hasVisited[i][j]:\n            return True\n        else:\n            return False\n    #---end function\n\n\n    #part of the logic to find all connected shapes\n    def __markCellAsVisited__(self, hasVisited, i, j):\n        hasVisited[i][j] = True\n    #end function\n\n\n    def __foundExit__(self, curR, curC, nR, nC):\n        upStep    = curR - 1\n        downStep  = curR + 1\n        leftStep  = curC - 1\n        rightStep = curC + 1\n\n        if not self.__inImage__(upStep, curC, nR, nC):\n            return True\n        elif not self.__inImage__(downStep, curC, nR, nC):\n            return True\n        elif not self.__inImage__(curR, leftStep, nR, nC):\n            return True\n        elif not self.__inImage__(curR, rightStep, nR, nC):\n            return True\n        else:\n            return False\n    #---end function\n\n\n    #Note: This function is never called at the start of the maze\n    def __foundDuplicateStartPos__( self, img, curR, curC):\n        if img[curR][curC] == MazeSymbols.START_TILE:\n            return True\n        else:\n            return False\n    #---end function\n\n\n    #Check if we have found a duplicae start point, or we can exit the maze\n    def __checkMazeStatus__(self, img, curR, curC, nR, nC):\n        if self.__foundExit__(curR, curC, nR, nC):\n            return MazeStatus.FOUND_EXIT\n        elif self.__foundDuplicateStartPos__( img, curR, curC):\n            return MazeStatus.MAZE_ERROR_DUPLICATE_START\n        else:\n            return MazeStatus.CONTINUE_SEARCH\n    #---end function\n        \n\n    #We search only on the four cardinal directions for the Maze\n    #X is up and down, y is left and right\n    def __walkMaze__(self, img, hasVisited, nR, nC, iRoot, jRoot):\n        #dx and dy specify the directions we are going to search dx=0 dy=1 means \n        #search north (one cell above), dx=1 dy=-1 is one to right and one down\n        di = [0,  0, 1, -1]\n        dj = [1, -1, 0,  0]\n        numSearchDirs = len(di)     #I do not like literal values\n\n        #x,y are lists that are going to hold the nodes conneced to the provided root (i,j) \n        iConnected, jConnected = [], []\n        q = queue.Queue()\n\n        #Begining the start of or breadth first search, starting at the provided root.\n        # Note that the root is always the starting location, and therefore should not\n        # be cheked for duplicate start position (but should be checked if we can exit)\n        q.put((iRoot, jRoot))\n        self.__markCellAsVisited__(hasVisited, iRoot, jRoot)\n        if self.__foundExit__(iRoot, jRoot, nR, nC):\n            return MazeStatus.FOUND_EXIT\n\n\n        #Now we search for all connections along the allowed (four) directions\n        while q.empty() == False:\n\n            u, v = q.get()\n            iConnected.append(u)\n            jConnected.append(v)\n            \n            #from the current position (u,v), search in the four cardinal directions\n            for s in range(numSearchDirs):\n                iNew = u + di[s]\n                jNew = v + dj[s]\n\n                #if we're in the image and found a desired cell, add it to the queue\n                if self.__inImage__(iNew, jNew, nR, nC)    and   \\\n                   self.__isDesiredCell__(img, hasVisited, iNew, jNew):\n                    self.__markCellAsVisited__(hasVisited, iNew, jNew)\n                    q.put((iNew, jNew))\n                    currentStatus  =  self.__checkMazeStatus__(img, iNew, jNew, nR, nC)\n                    if currentStatus != MazeStatus.CONTINUE_SEARCH:\n                        return currentStatus\n\n        #Should we get to this point, there does not exist a way to an exit of the maze \n        # from the starting location (path to exit: list(zip(xConnected, yConnected)))\n        return MazeStatus.NO_EXIT_EXISTS\n    #---end function\n#---end class\n\n\n#True: Maze solvable\n#False: Maze has no exit\n#Error Thrown: Either no start provided, or more than one start position found\ndef has_exit(maze):\n    \n    m = MazeSolver(maze)\n    if not m.isValidMaze():\n        raise ValueError('Maze Not Valid')\n    else:\n        resultSolve = m.attemptSolve()\n\n        if resultSolve == MazeStatus.FOUND_EXIT:\n            return True\n        elif resultSolve == MazeStatus.NO_EXIT_EXISTS:\n            return False\n#---end function\n\n", "def has_exit(maze):\n    start = [[i, maze[i].find('k')] for i in range(len(maze)) if maze[i].find('k') != -1]\n    if len(start) != 1: raise Exception(\"There should no be multiple Kates\")\n    if backtracking(maze, start[0][0], start[0][1], set()):\n        return True\n    return False\n\n\ndef backtracking(maze, y, x, explored):\n    if maze[y][x] == '#':\n        explored.add((y, x))\n        return False\n    if (y, x) in explored:\n        return False\n    if x in {0, len(maze[0])-1} or y in {0, len(maze)-1}:\n        return True\n    explored.add((y, x))\n    found = backtracking(maze, y-1, x, explored) or\\\n            backtracking(maze, y, x+1, explored) or\\\n            backtracking(maze, y+1, x, explored) or\\\n            backtracking(maze, y, x-1, explored)\n    return found", "def has_exit(board):\n    def make(i, j, visited=None):\n        if not visited : visited = []\n        if [i, j] in visited or not (0 <= i < len(board) and 0 <= j < len(board[0])) or board[i][j] == \"#\" : return False\n        visited.append([i, j])\n        if i == 0 or j == 0 or i == len(board) - 1 or j == len(board[0]) - 1 : return True\n        return any([make(i + 1, j, visited),\n                    make(i - 1, j, visited),\n                    make(i, j + 1, visited),\n                    make(i, j - 1, visited)])\n    li = [[i, k] for i, j in enumerate(board) for k, l in enumerate(j) if l == 'k']\n    if len(li)>1 : raise \n    return make(li[0][0],li[0][1])", "def has_exit(maze):\n    def rec(i, j):\n        if not i in range(len(maze)): return True\n        if not j in range(len(maze[i])): return True\n        if maze[i][j] == '#': return False\n        maze[i][j] = '#'\n        return any(rec(i+k, j+l) for k in (-1, 0, 1) for l in (-1, 0, 1) if bool(k) != bool(l))\n\n    pos = None\n    for i,line in enumerate(maze):\n        for j,c in enumerate(line):\n            if c == 'k':\n                if pos:\n                    raise Exception(\"There should not be multiple Kates\")\n                else:\n                    pos = (i, j)\n    if not pos:\n        raise Exception(\"There should be a Kate\")\n    maze = list(map(list, maze))\n    return rec(*pos)", "def has_exit(maze):\n    N, M = len(maze)+2, len(maze[0])+2\n    maze = ['b'*M] + ['b'+row+'b' for row in maze] + ['b'*M]\n    q = [(i,j) for i,row in enumerate(maze) for j,c in enumerate(row) if c == 'k']\n    if len(q) != 1: raise Exception('Wrong number of Kates')\n    v = set(q)\n    while q:\n        i,j = q.pop()\n        nbs = [(i+a,j+b,maze[i+a][j+b]) for a in range(-1,2) for b in range(-1,2) if bool(a) != bool(b)]\n        for ni,nj,nv in nbs:\n            if nv == 'b': return True\n            if nv == '#' or (ni,nj) in v: continue\n            q.append((ni,nj)) or v.add((ni,nj))\n    return False"]
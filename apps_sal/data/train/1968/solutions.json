["class Solution:\n    def removeSubfolders(self, folder):\n    \n        folders = folder\n    \n        folders.sort()\n        output = []\n        parent = ' '\n    \n        for folder in folders:\n            if not folder.startswith(parent):\n                output.append(folder)\n                parent = folder + '/'\n    \n        return output", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        ans = []\n        for i, path in enumerate(sorted(folder)):\n            if i == 0 or not path.startswith(ans[-1] + \\\"/\\\"):\n                ans.append(path)\n        return ans", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        return self.first_implementation(folder)\n    \n    def first_implementation(self, folder: List[str]) -> List[str]:\n        \\\"\\\"\\\"\n        The directories are not guaranteed to be in sorted order. Sort the input in place with heapsort O(n log n) \n        If they are then this problem goes into O(n) Time\n        Benefit of sorting time goes from O(n^2) to O(n log n).\n        \n        Iterate over the sorted array finding common roots. As long as the next item's root is in the previous \n        remove it.\n        \\\"\\\"\\\"\n        if not folder:\n            return []\n        from heapq import heapify, heappop\n        heapify(folder)\n        # initialize the output though it could be done in true O(1) space with peaking at\n        # the previous element in the heap but that would require a pop push\n        result = [heappop(folder)]\n        \n        while folder:\n            cur = heappop(folder)\n            if not cur.startswith(result[-1] + '/'):\n                result.append(cur)\n        \n        return result\n        \n        ", "class Trie:\n    def __init__(self):\n        self.next={}\n        self.end_here=False\n    \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        \n        def collect(curnode, res, curpath):\n            if curnode.end_here:\n                res.append('/'.join(curpath))\n                return\n            \n            for folder in curnode.next:\n                curpath.append(folder)\n                collect(curnode.next[folder], res, curpath)\n                curpath.pop()\n        \n        root=Trie()\n        for f in folder:\n            cur=root\n            for seg in f.split('/'):\n                if seg not in cur.next:\n                    cur.next[seg]=Trie()\n                cur=cur.next[seg]\n            cur.end_here=True\n            \n        res=[]\n        \n        collect(root, res, [])\n        return res", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEnd = True  \n    \n    def find(self):\n        def dfs(direc, node):\n            if node.isEnd:\n                answer.append('/' + '/'.join(direc))\n                return\n            for char in node.children:\n                dfs(direc + [char], node.children[char])\n        \n        answer = []\n        dfs([], self.root)\n        return answer\n\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = Trie()\n        for f in folder:\n            \n            f = f.split('/')[1:]\n            print(f)\n            trie.insert(f)\n        return trie.find()", "class Trie:\n    def __init__(self, *words):\n        self._end = '_end'\n        self.root = {}\n        self.insert(*words)\n\n    def insert(self, *words):\n        _end = self._end\n        root = self.root\n\n        for word in words:\n            current_dict = root\n            for letter in word:\n                current_dict = current_dict.setdefault(letter, {})\n            current_dict[_end] = _end\n        return root\n\n    def has(self, word):\n        trie = self.root\n        _end = self._end\n\n        current_dict = trie\n        for letter in word:\n            if letter not in current_dict:\n                return False\n            current_dict = current_dict[letter]\n        return _end in current_dict\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        if folder: folder.sort()\n\n        r = []\n        trie = Trie()\n        for f in folder:\n            names = [x for x in f.split('/') if x.strip()]\n            to_insert = True\n            for i in range(1, len(names)+1):\n                subfolder = '/'.join(names[:i])\n                subfolder = '/'+subfolder if subfolder else subfolder\n                if trie.has(subfolder):\n                    to_insert = False\n                    break\n                \n            if to_insert:\n                r.append(f)\n                trie.insert(f)\n        return r\n", "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = {}\n        self.finished = False\n        \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        root = Node(\\\"\\\")\n        for path in folder:\n            paths = path.split(\\\"/\\\")\n            cur = root\n            for each in paths:\n                if each == \\\"\\\":\n                    continue\n                if each in cur.children:\n                    cur = cur.children[each]\n                else:\n                    new_node = Node(each)\n                    cur.children[each] = new_node\n                    cur = new_node\n                    \n            cur.finished = True\n                    \n        # get all paths from the root to ...\n        folders = []\n        def collect(root, path):\n            path.append(\\\"/\\\"+root.val)\n            if root.finished:\n                folders.append(list(path))\n                path.pop()\n                return\n            for _, child in root.children.items():\n                collect(child, path)\n            path.pop()\n            \n        for _, child in root.children.items():\n            collect(child, [])\n        return [\\\"\\\".join(each) for each in folders]\n                \n            \n                ", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        # 1. iterate through the folders in the list\n        # 2. split the folder by '/'\n        # 3. check if names[:-1] exists in a dict\n        # 4. if it exists, skip (drop) the folder\n        # 5. if not, add names[:-1] to the dict and add the folder to the output list\n        \n        d = {}\n        for f in folder:\n            names = ''.join(f.split('/'))\n            if len(names) > 0:\n                d[names] = f\n        \n        output = []\n        for f in folder:\n            names = ''.join(f.split('/')[:-1])\n            if not [True for i in range(len(names)) if names[:i+1] in d]:\n                output.append(f)\n                \n        return output\n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n\n        def get_key(f):\n            \n            for i in range(len(f) - 1, -1 , -1):\n                if(f[i] == \\\"/\\\"):\n                    return i\n            raise Exception\n        \n        folder = sorted(folder, key=lambda x : len(x))\n        top_level_folders = {}\n        \n        for f in folder:\n            \n            key = get_key(f)\n            parent = f[0:key]\n            check = False\n            while(parent):\n                \n                if(parent in top_level_folders):\n                    check = True\n                key = get_key(parent)\n                parent = f[0:key]\n            \n            if(not check):\n                top_level_folders[f] = True\n            \n            \n            \n        ret = []\n        for key in top_level_folders:\n            ret.append(key)\n        return ret", "class Solution:\n    def init(self, folder):\n        self.tries = {}\n        for f_ in folder:\n            f_list = list(filter(None, (f_.strip()+'/$').split(\\\"/\\\")))\n            node = self.tries\n            for folder in f_list:\n                if folder not in node:\n                    node[folder] = {}\n                node = node[folder]\n\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        result = []\n        if folder == None or len(folder) == 0:\n            return result\n        \n        self.init(folder)\n        for f_ in folder:\n            path = []\n            node = self.tries\n            f_list = list(filter(None, f_.strip().split(\\\"/\\\")))\n            for folder in f_list:\n                if '$' in node:\n                    break\n                path.append(folder)\n                node = node[folder]\n\n            if \\\"/\\\"+\\\"/\\\".join(path) not in result:\n                result.append(\\\"/\\\"+\\\"/\\\".join(path))\n            \n        return result\n                \n\n\n\n        \n        ", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = {}\n        trie[\\\"/\\\"] = False   # whether it's a folder\n        \n        for f in folder:\n            paths = f.split(\\\"/\\\")\n            current = trie\n            n = len(paths)\n            for i in range(1,n):\n                p = paths[i]\n                if p not in current:\n                    current[p] = {}\n                current = current[p]\n                if i==n-1:  current[\\\"/\\\"] = True\n                else:\n                    if \\\"/\\\" not in current:  current[\\\"/\\\"] = False\n                \n                \n        print(trie)\n        \n        self.ans = []\n        def findPath(path, result):\n            if path[\\\"/\\\"]:\n                self.ans.append(result)\n                return\n            for k, v in path.items():\n                if k == \\\"/\\\":    continue\n                findPath(v, result+[k])\n            \n        result = []\n        findPath(trie, result)\n        return [\\\"/\\\" + \\\"/\\\".join(a) for a in self.ans]\n            ", "class Solution:\n    def init(self, folder):\n        self.tries = {}\n        for f_ in folder:\n            f_list = list(filter(None, f_.strip().split(\\\"/\\\")))\n            node = self.tries\n            for folder in f_list:\n                if folder not in node:\n                    node[folder] = {}\n                node = node[folder]\n            node['$'] = {'$'}\n\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        result = []\n        if folder == None or len(folder) == 0:\n            return result\n        \n        self.init(folder)\n        for f_ in folder:\n            path = []\n            node = self.tries\n            f_list = list(filter(None, f_.strip().split(\\\"/\\\")))\n            for folder in f_list:\n                if '$' in node:\n                    break\n                path.append(folder)\n                node = node[folder]\n\n            if \\\"/\\\"+\\\"/\\\".join(path) not in result:\n                result.append(\\\"/\\\"+\\\"/\\\".join(path))\n            \n        return result\n                \n\n\n\n        \n        ", "class Trie:\n    \n    def __init__(self):\n        self.root = {}\n        \n    def insert(self, word):\n        cur = self.root\n        for ch in word:\n            if ch not in cur:\n                cur[ch] = {}\n            cur = cur[ch]\n        cur['END'] = {}\n        \n    def search(self):\n        \n        def dfs(node, tmp, res):\n            if 'END' in node:\n                res.append(''.join(tmp))\n            else:\n                for ch in node:\n                    tmp.append(ch)\n                    dfs(node[ch], tmp, res)\n                    tmp.pop()\n            \n        res, tmp = [], []\n        dfs(self.root, tmp, res)\n        return res\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        t = Trie()\n        for f in folder:\n            t.insert(f + '/')\n        return [f[:-1] for f in t.search()]\n        \n        \n        # init\n        n = len(folder)\n        \n        # sort the folder\n        folder = [f + '/' for f in folder]\n        folder.sort()\n        \n        parent = 0\n        for child in range(1, n):\n            if folder[child].startswith(folder[parent]):\n                folder[child] = None\n            else:\n                parent = child\n        \n        return [f[:-1] for f in folder if f is not None]\n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort()\n        res = []\n        for x in folder:\n            cur = x.split('/')\n            if not res or res[-1] != cur[:len(res[-1])]:\n                res.append(cur)\n        \n        return [ \\\"/\\\".join(x) for x in res ]\n            \n        ", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        d = {}\n        ret = []\n        folder.sort()\n        for f in folder:\n            fl = f.split(\\\"/\\\")\n            for i in range(1, len(fl)):\n                tup = tuple(fl[1:i+1])\n                tup_h = tuple(tup)\n                if tup_h in d:\n                    #print(\\\"this is a subfolder: \\\", end=\\\" \\\")\n                    #print(tup_h)\n                    \n                    break\n                elif i == len(fl)-1:\n                    #print(\\\"this is new: \\\", end=\\\" \\\")\n                    #print(tup_h)\n                    d[tup_h] = f\n                    ret.append(f)\n                \n            \n           # d[f_t] = 0\n        #print(d)\n        return ret", "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.children = {}\n        self.finished = False\n        \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        root = Node(\\\"\\\")\n        for path in folder:\n            paths = path.split(\\\"/\\\")\n            cur = root\n            for each in paths:\n                if each == \\\"\\\":\n                    continue\n                if each in cur.children:\n                    cur = cur.children[each]\n                else:\n                    new_node = Node(each)\n                    cur.children[each] = new_node\n                    cur = new_node\n                    \n            cur.finished = True\n                    \n        # get all paths from the root to ...\n        folders = []\n        def collect(root, path):\n            if root.finished:\n                folders.append(path+\\\"/\\\"+root.val)\n                return\n            for _, child in root.children.items():\n                collect(child, path+\\\"/\\\"+root.val)\n            \n        for _, child in root.children.items():\n            collect(child, \\\"\\\")\n        return folders\n            \n                ", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort(key = lambda x:len(x))\n        folderDict = {}\n        ans = set(folder)\n        \n        # ans = []\n        for address in folder:\n            aList = (address[1:]).split('/')\n            # print(address, aList)\n            pointer = folderDict\n            for name in aList:\n                if name in pointer:\n                    pointer = pointer[name]\n                    if '$' in pointer:\n                        if address in ans:\n                            # print('remove', address)\n                            ans.remove(address)\n                else:\n                    pointer[name] = {}\n                    pointer = pointer[name]\n            pointer['$'] = ''\n        # print(folderDict)\n        return ans", "class TrieNode:\n    def __init__(self, val):\n        self.val = val\n        self.children = {}\n        self.isWord = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode('$')\n        self.answer = []\n    \n    def insert(self, word):\n        root = self.root\n        for w in word:\n            if w not in root.children:\n                root.children[w] = TrieNode(w)\n            root = root.children[w]\n        root.isWord = True\n    \n    def getCommonPrefix(self, root, prefix):\n        if root.isWord:\n            self.answer.append(prefix)  #If the current node is a folder end, then just get the prefix till here and ignore the further path.\n            return\n        \n        children = root.children\n        for c in children:\n            self.getCommonPrefix(children[c], prefix+\\\"/\\\"+ children[c].val)\n        \n                \nclass Solution(object):\n    def removeSubfolders(self, folders):\n        \\\"\\\"\\\"\n        :type folder: List[str]\n        :rtype: List[str]\n        \\\"\\\"\\\"\n        trie = Trie()\n        \n        for f in folders:\n            path = f.split(\\\"/\\\")\n            path.pop(0)\n            trie.insert(path)\n        \n        trie.getCommonPrefix(trie.root, \\\"\\\")\n        \n        return trie.answer\n            \n        \n        \n        \n        \n        \n        \n        \n        \n        # folder=sorted(folder)\n        # ans=[]\n        # for i in folder:\n        #     flag=1\n        #     for ele in ans:\n        #         if(i.startswith(ele) and i[len(ele)]==\\\"/\\\"):\n        #             flag=0\n        #             break\n        #     if(flag==1):\n        #         ans.append(i)\n        #     # print(ans)\n        # return ans", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        class Node:\n            def __init__(self):\n                self.is_path = False\n                self.subs = {}\n            \n            def add_path(self, p, i=0):\n                if i == len(p): return\n                n = p[i]\n                if n not in self.subs:\n                    self.subs[n] = Node()\n                self.subs[n].is_path |= (len(p) - i == 1)\n                self.subs[n].add_path(p, i+1)\n                \n        \n        t = Node()\n        for f in folder:\n            p = f.split('/')[1:]\n            t.add_path(p)\n        s = []\n        p = []\n        def dfs_visit(r, name=''):\n            if r.is_path is True:\n                s.append('/'.join(p)+'/'+name)\n                return\n            p.append(name)\n            for sub_name, sub in r.subs.items():\n                dfs_visit(sub, sub_name)\n            p.pop()\n        dfs_visit(t)\n        return s", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEnd = True  \n    \n    def find(self):\n        def dfs(direc, node):\n            if node.isEnd:\n                answer.append('/' + '/'.join(direc))\n                return\n            for char in node.children:\n                dfs(direc + [char], node.children[char])\n        \n        answer = []\n        dfs([], self.root)\n        return answer\n\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = Trie()\n        for f in folder:\n            f = f.split('/')[1:]\n            trie.insert(f)\n        return trie.find()", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, path):\n        node = self.root\n        \n        for ch in path:\n            if ch not in node.children:\n                node.children[ch] = TrieNode()\n            \n            node = node.children[ch]\n        \n        node.end = '/'+'/'.join(path)\n    \n    def find(self):        \n        def dfs(aggregate, node):\n            if node.end:\n                result.append(node.end)\n                return\n            \n            for ch in node.children:\n                dfs(aggregate+[ch], node.children[ch])\n        \n        result = []\n        dfs([], self.root)\n        return result\n    \n    \n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        if not folder:\n            return []\n        \n        trie = Trie()\n        for path in folder:\n            splitPaths = path.split('/')[1:]\n            trie.insert(splitPaths)\n        \n        returnList = trie.find()\n        \n        return returnList\n", "class Node:\n    def __init__(self, name):\n        self.name = name\n        self.next = dict()\n        self.flag = False\n        \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        head = dict()\n        for f in folder:\n            sub = f.split(\\\"/\\\")\n            for i in range(1,len(sub)): # first element is empty string, skip\n                            \n                if i == 1: # first node\n                    node = head.setdefault(sub[i], Node(sub[i]))\n                else:\n                    node = node.next.setdefault(sub[i], Node(sub[i]))\n                    \n                if i == len(sub)-1:\n                    node.flag = True\n\n        ret = list()\n        # for k in head:\n        #     # dfs\n        #     stack = [(head[k], list())]\n        #     while stack:\n        #         node, chain = stack.pop()\n        #         chain.append(node.name)\n        #         if node.flag:\n        #             ret.append(\\\"/\\\"+\\\"/\\\".join(chain))\n        #         else:\n        #             for k, next_node in node.next.items():\n        #                 stack.append((next_node, list(chain)))\n        \n        \n        def backtrack(node):\n            if node.flag:\n                return [[node.name]]\n            \n            ret = list()\n            for k,v in node.next.items():\n                l = backtrack(v)\n                for i in range(len(l)):\n                    l[i].append(node.name)\n                ret.extend(l)\n            return ret\n                    \n                \n        for k, v in head.items():\n            # dfs\n            for l in backtrack(v):\n                ret.append(\\\"/\\\" + \\\"/\\\".join(l[::-1]))\n\n        return ret\n    \n    \n            \n                    \n                \n                \n                \n                \n        ", "class Node:\n    def __init__(self, name):\n        self.name = name\n        self.next = dict()\n        self.flag = False\n        \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        head = dict()\n        for f in folder:\n            sub = f.split(\\\"/\\\")\n            for i in range(1,len(sub)): # first element is empty string, skip\n                            \n                if i == 1: # first node\n                    node = head.setdefault(sub[i], Node(sub[i]))\n                else:\n                    node = node.next.setdefault(sub[i], Node(sub[i]))\n                    \n                if i == len(sub)-1:\n                    node.flag = True\n\n        ret = list()\n        # for k in head:\n        #     # dfs\n        #     stack = [(head[k], list())]\n        #     while stack:\n        #         node, chain = stack.pop()\n        #         chain.append(node.name)\n        #         if node.flag:\n        #             ret.append(\\\"/\\\"+\\\"/\\\".join(chain))\n        #         else:\n        #             for k, next_node in node.next.items():\n        #                 stack.append((next_node, list(chain)))\n        \n        \n        def backtrack(node):\n            if node.flag:\n                return [[node.name]]\n            \n            ans = list()\n            for k,v in node.next.items():\n                l = backtrack(v)\n                for i in range(len(l)):\n                    l[i].append(node.name)\n                ans.extend(l)\n            return ans\n                    \n                \n        for k, v in head.items():\n            # dfs\n            for l in backtrack(v):\n                ret.append(\\\"/\\\" + \\\"/\\\".join(l[::-1]))\n\n        return ret\n    \n    \n            \n                    \n                \n                \n                \n                \n        ", "class Node:\n    def __init__(self, name):\n        self.name = name\n        self.next = dict()\n        self.flag = False\n        \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        head = dict()\n        for f in folder:\n            sub = f.split(\\\"/\\\")\n            for i in range(1,len(sub)): # first element is empty string, skip\n                            \n                if i == 1: # first node\n                    node = head.setdefault(sub[i], Node(sub[i]))\n                else:\n                    node = node.next.setdefault(sub[i], Node(sub[i]))\n                    \n                if i == len(sub)-1:\n                    node.flag = True\n\n        ret = list()\n        # for k in head:\n        #     # dfs\n        #     stack = [(head[k], list())]\n        #     while stack:\n        #         node, chain = stack.pop()\n        #         chain.append(node.name)\n        #         if node.flag:\n        #             ret.append(\\\"/\\\"+\\\"/\\\".join(chain))\n        #         else:\n        #             for k, next_node in node.next.items():\n        #                 stack.append((next_node, list(chain)))\n        \n        \n        def backtrack(node):\n            if node.flag:\n                \n                return [[node.name]]\n            \n            ret = list()\n            for k,v in node.next.items():\n                l = backtrack(v)\n                for i in range(len(l)):\n                    l[i].append(node.name)\n                ret.extend(l)\n            return ret\n                    \n                \n        ret = list()\n        for k, v in head.items():\n            # dfs\n\n            for l in backtrack(v):\n                ret.append(\\\"/\\\" + \\\"/\\\".join(l[::-1]))\n\n        return ret\n    \n    \n            \n                    \n                \n                \n                \n                \n        ", "class Solution:\n    \n    def is_subfolder(self, parent, current):\n        if parent == \\\"\\\":\n            return False\n        \n        splitted = current.split(parent)\n        \n        if len(splitted) == 1:\n            return False\n        \n        if splitted[0] == \\\"\\\":\n            if splitted[1] == \\\"\\\":\n                return True\n            elif len(splitted[1]) > 0:\n                if splitted[1][0] == \\\"/\\\":\n                    return True\n        return False\n        \n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort()\n        parent = folder[0]\n        \n        output = []\n        output.append(parent)\n        \n        index  = 1\n        \n        while(index < len(folder)):\n            current = folder[index]\n            \n            if not self.is_subfolder(parent, current):\n                output.append(current)\n                parent = current\n            \n            index += 1\n        return output", "class Node:\n    def __init__(self, name):\n        self.name = name\n        self.next = dict()\n        self.flag = False\n        \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        head = dict()\n        for f in folder:\n            sub = f.split(\\\"/\\\")\n            for i in range(1,len(sub)): # first element is empty string, skip\n                            \n                if i == 1: # first node\n                    node = head.setdefault(sub[i], Node(sub[i]))\n                else:\n                    node = node.next.setdefault(sub[i], Node(sub[i]))\n                    \n                if i == len(sub)-1:\n                    node.flag = True\n\n        ret = list()\n        for k in head:\n            # dfs\n            stack = [(head[k], list())]\n            while stack:\n                node, chain = stack.pop()\n                chain.append(node.name)\n                if node.flag:\n                    ret.append(\\\"/\\\"+\\\"/\\\".join(chain))\n                else:\n                    for k, next_node in node.next.items():\n                        stack.append((next_node, list(chain)))\n\n        return ret\n            \n                    \n                \n                \n                \n                \n        ", "class Node:\n    def __init__(self, name):\n        self.name = name\n        self.next = dict()\n        self.flag = False\n        \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        head = dict()\n        for f in folder:\n            sub = f.split(\\\"/\\\")\n\n            for i in range(1,len(sub)):\n\n                # first node\n                if i == 1:\n                    node = head.setdefault(sub[i], Node(sub[i]))\n                # not first node\n                else:\n                    print\n                    node = node.next.setdefault(sub[i], Node(sub[i]))\n                    # print(node.next)\n                    \n                if i == len(sub)-1:\n                    node.flag = True\n                # if 1 < 1 < len(sub)-1:\n                #     node = next_node\n\n\n        print(head) \n        ret = list()\n        for k in head:\n            # dfs\n            stack = [(head[k], list())]\n            while stack:\n                node, chain = stack.pop()\n                chain.append(node.name)\n                if node.flag:\n                    ret.append(\\\"/\\\"+\\\"/\\\".join(chain))\n                else:\n                    for k, next_node in node.next.items():\n                        stack.append((next_node, list(chain)))\n\n        return ret\n            \n                    \n                \n                \n                \n                \n        ", "class Node:\n    def __init__(self, name):\n        self.name = name\n        self.next = dict()\n        self.flag = False\n        \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        head = dict()\n        for f in folder:\n            sub = f.split(\\\"/\\\")\n            for i in range(1,len(sub)): # first element is empty string, skip\n                            \n                if i == 1: # first node\n                    node = head.setdefault(sub[i], Node(sub[i]))\n                else:\n                    node = node.next.setdefault(sub[i], Node(sub[i]))\n                    \n                if i == len(sub)-1:\n                    node.flag = True\n\n        ret = list()\n        # for k in head:\n        #     # dfs\n        #     stack = [(head[k], list())]\n        #     while stack:\n        #         node, chain = stack.pop()\n        #         chain.append(node.name)\n        #         if node.flag:\n        #             ret.append(\\\"/\\\"+\\\"/\\\".join(chain))\n        #         else:\n        #             for k, next_node in node.next.items():\n        #                 stack.append((next_node, list(chain)))\n        \n        \n        def backtrack(node):\n            if node.flag:\n                return [[node.name]]\n            \n            ret = list()\n            for k,v in node.next.items():\n                l = backtrack(v)\n                for i in range(len(l)):\n                    l[i].append(node.name)\n                ret.extend(l)\n            return ret\n                    \n                \n        ret = list()\n        for k, v in head.items():\n            # dfs\n            for l in backtrack(v):\n                ret.append(\\\"/\\\" + \\\"/\\\".join(l[::-1]))\n\n        return ret\n    \n    \n            \n                    \n                \n                \n                \n                \n        ", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n        \n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEnd = True\n        \n    def find(self):\n        def dfs(path, node):\n            if node.isEnd:\n                ans.append('/' + '/'.join(path))\n                return \n            for c in node.children:\n                dfs(path + [c], node.children[c])\n                \n        ans = []\n        dfs([], self.root)\n        return ans\n\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = Trie()\n        for f in folder:\n            f = f.split('/')[1:]\n            trie.insert(f)\n        return trie.find()", "class Node():\n    def __init__(self):\n        self.next = {}\n        self.folder = False\n\nclass Trie():\n    def __init__(self):\n        self.root = Node()\n    \n    def update(self, folder):\n        \n        start = 1\n        node = self.root\n        while node and start < len(folder):\n            i = start\n            while i<len(folder) and folder[i]!= '/':\n                i += 1\n            curr_fold = folder[start:i]\n            \n            if curr_fold not in node.__next__:\n                node.next[curr_fold] = Node()\n            \n            node = node.next[curr_fold]\n            start = i+1\n        node.folder = True\n        \n    \n    def find_all(self):\n        output = []\n        \n        def helper(node, path):\n            if node.folder:\n                output.append(path)\n            else:\n                for next_node in node.__next__:\n                    helper(node.next[next_node], path+'/'+next_node)\n        \n        helper(self.root, '')\n        return output\n    \n        \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        \n        folder_trie = Trie()\n        for fold in folder:\n            folder_trie.update(fold)\n            \n        return folder_trie.find_all()\n", "class TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.isEnd = False\n\nclass Solution:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def add(self, path):\n        node = self.root\n        for p in path:\n            node = node.children[p]\n        node.isEnd = True\n        \n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        for f in folder:\n            f = f.split(\\\"/\\\")[1:]\n            self.add(f)\n        \n        ans = []\n        self.dfs(self.root, [], ans)\n        return ans\n    \n    def dfs(self, node, path, ans):\n        if node.isEnd:\n            ans.append(\\\"/\\\" + \\\"/\\\".join(path))\n            return\n        \n        for c in node.children:\n            self.dfs(node.children[c], path + [c], ans)\n        \n        ", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort()\n        \n        res = [folder.pop(0)]\n        n = len(folder)\n        \n        for i in range(n):\n            pattern = f'^{res[-1]}/'\n            result = re.match(pattern, folder[i])\n            if not result: \n                res += [folder[i]]\n            \n        return res\n        \n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort()\n        \n        n = len(folder)\n        prev = folder[0]\n        \n        i = 1\n        while i < n:\n            curr = folder[i]\n            \n            if curr.startswith(prev + '/'):\n                folder.remove(curr)\n                curr = prev\n                i-= 1\n                n-= 1\n                            \n            prev = curr\n            i+= 1\n        \n        return folder", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort()\n        #print(folder)\n        l = len(folder) \n        i=0\n        while(i<l-1):\n            p = folder[i]\n            j = i+1\n            l = len(folder)           \n            while(j<l):\n                if folder[j].startswith(p):\n                    if len(folder[j])>len(p) and folder[j][len(p)]=='/':\n                        folder.remove(folder[j])\n                        l = len(folder)\n                    else:\n                        j+=1\n                else:\n                    break\n                \n            i+=1\n        return folder\n            \n        \n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        s = set()\n        folder.sort(key=len)\n        for i in folder:\n            f = 0\n            x = i.split('/')\n            temp = \\\"\\\"\n            for j in x:\n                if j==\\\"\\\":\n                    continue\n                temp = temp + '/'+j\n                if temp in s:\n                    f = 1\n                    break\n            if f==0:\n                s.add(i)\n        return list(s)", "# O(M*N)\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\n\nclass Solution:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def _add(self, path):\n        node = self.root\n        for string in path.split('/'):\n            if not string:\n                continue\n            if string not in node.children:\n                node.children[string] = TrieNode()\n            node = node.children[string]\n        node.isEnd = True\n        return\n\n    def _isSubFolder(self, path):\n        node = self.root\n        for string in path.split('/'):\n            if not string:\n                continue\n            if node.isEnd:\n                return True\n            node = node.children[string]\n        return False\n\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        res = []\n        for path in folder:\n            self._add(path)\n        for path in folder:\n            if not self._isSubFolder(path):\n                res.append(path)\n        return res", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        sort = sorted(folder, key = len)\n        \n        visited = []\n        \n        for f in sort:\n            found = False\n            for prefix in visited:\n                if f.startswith(prefix + \\\"/\\\"):\n                    found = True\n                    break\n            if not found:\n                visited.append(f)\n        return visited", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort()\n        folder_set = set(folder)\n        \n        n = len(folder)\n        prev = folder[0]\n        \n        i = 1\n        while i < n:\n            curr = folder[i]\n            \n            len_prev, len_curr = len(prev), len(curr)\n            if len_prev < len_curr:\n                if curr[:len_prev] in folder_set:\n                    if curr[len_prev] == '/':\n                        folder.remove(curr)\n                        curr = prev\n                        i-= 1\n                        n-= 1\n                            \n            prev = curr\n            i+= 1\n        \n        return folder", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort()\n        folder_set = set(folder)\n        \n        n = len(folder)\n        prev = folder[0]\n        \n        i = 1\n        while i < n:\n            curr = folder[i]\n            \n            if curr.startswith(prev + '/'):\n                folder.remove(curr)\n                curr = prev\n                i-= 1\n                n-= 1\n                            \n            prev = curr\n            i+= 1\n        \n        return folder", "class Solution:\n    def removeSubfolders(self, folders: List[str]) -> List[str]:\n        seen = set()\n        # folders.sort(key = lambda x: len(x.split('/')))\n        folders.sort(key = lambda x: len(x))\n        # print(folders)\n        for folder in folders.copy():\n            # print(folder)\n            # folder_split = folder.split('/')[1:]\n            for i in range(2, len(folder)):\n                if folder[i] == '/' and folder[:i] in seen: \n                    folders.remove(folder)\n                    break\n            else: seen.add(folder)\n            # print(seen)\n                    \n        return folders", "class Solution:\n    def removeSubfolders(self, folders: List[str]) -> List[str]:\n        seen = set()\n        # folders.sort(key = lambda x: len(x.split('/')))\n        folders.sort(key = lambda x: len(x))\n        # print(folders)\n        for folder in folders.copy():\n            # print(folder)\n            folder_split = folder.split('/')[1:]\n            for i in range(len(folder_split)):\n                if tuple(folder_split[:i+1]) in seen: \n                    folders.remove(folder)\n                    break\n            else: seen.add(tuple(folder_split))\n            # print(seen)\n                    \n        return folders", "class Trie:\n    def __init__(self):\n        self.root = {\\\"*\\\": \\\"*\\\"}\n\n    def add(self, word):\n        current = self.root\n        for letter in word:\n            if letter not in current:\n                current[letter] = {}\n            current = current[letter]\n        current[\\\"*\\\"] = \\\"*\\\"\n\n    def has(self, word):\n        current = self.root\n        for letter in word:\n            if letter not in current:\n                return False\n            current = current[letter]\n\n        return \\\"*\\\" in current\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:        \n        trie = Trie()\n        for fol in folder:\n            trie.add(fol)\n        \n        response = set()\n        for fol in folder:\n            key = fol[:fol.rindex(\\\"/\\\")]\n            while key:\n                if trie.has(key):\n                    break\n                key = key[:key.rindex(\\\"/\\\")]\n            \n            if not key:\n                response.add(fol)\n                \n            # if not key:\n            #     response.add(fol)\n            # if not trie.has(key):\n            #     response.add(fol)\n                \n        return response", "class Trie:\n    def __init__(self):\n        self.root = {\\\"*\\\": \\\"*\\\"}\n\n    def add(self, word):\n        current = self.root\n        for letter in word:\n            if letter not in current:\n                current[letter] = {}\n            current = current[letter]\n        current[\\\"*\\\"] = \\\"*\\\"\n\n    def has(self, word):\n        current = self.root\n        for letter in word:\n            if letter not in current:\n                return False\n            current = current[letter]\n\n        return \\\"*\\\" in current\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:        \n        trie = Trie()\n        for fol in folder:\n            trie.add(fol)\n        \n        response = set()\n        for fol in folder:\n            key = fol[:fol.rindex(\\\"/\\\")]\n            while key:\n                if trie.has(key):\n                    break\n                key = key[:key.rindex(\\\"/\\\")]\n            \n            if not key:\n                response.add(fol)\n                \n        del trie\n        return response", "class Trie:\n    def __init__(self):\n        self.sub = collections.defaultdict(Trie)\n        self.index = -1\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        self.root = Trie()\n        \n        for i in range(len(folder)):\n            cur = self.root\n            for c in folder[i]:\n                cur = cur.sub[c]\n            cur.index = i\n        \n        return self.bfs(self.root, folder)\n    \n    \n    def bfs(self, trie: Trie, folder: List[str]) -> List[str]:\n        q, ans = [trie], []\n        for t in q:\n            if t.index >= 0:\n                ans.append(folder[t.index])\n            for c in t.sub.keys():\n                if '/' != c or t.index < 0:\n                    q.append(t.sub.get(c))\n        return ans", "class Trie:\n    def __init__(self):\n        self.sub = collections.defaultdict(Trie)\n        self.index = -1\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        self.root = Trie()\n        for i in range(len(folder)):\n            cur = self.root\n            for c in folder[i]:\n                cur = cur.sub[c]\n            cur.index = i\n        return self.bfs(self.root, folder)\n    def bfs(self, trie: Trie, folder: List[str]) -> List[str]:\n        q, ans = [trie], []\n        for t in q:\n            if t.index >= 0:\n                ans.append(folder[t.index])\n            for c in t.sub.keys():\n                if '/' != c or t.index < 0:\n                    q.append(t.sub.get(c))\n        return ans", "class Trie:\n    def __init__(self):\n        self.sub = collections.defaultdict(Trie)\n        self.index = -1\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        self.root = Trie()\n        for i in range(len(folder)):\n            cur = self.root\n            for c in folder[i]:\n                cur = cur.sub[c]\n            cur.index = i\n        return self.bfs(self.root, folder)\n    def bfs(self, trie: Trie, folder: List[str]) -> List[str]:\n        q, ans = [trie], []\n        for t in q:\n            if t.index >= 0:\n                ans.append(folder[t.index])\n            for c in list(t.sub.keys()):\n                if '/' != c or t.index < 0:\n                    q.append(t.sub.get(c))\n        return ans\n        # folder.sort()\n        # ans = []\n        # for f in folder:\n        #     if not ans or not f.startswith(ans[-1] + '/'):\n        #         ans.append(f)\n        # return ans\n        \n\n        \n        # folder.sort()\n        # seen = set()\n        # for path in folder:\n        #     if not any(path[i] == '/' and path[:i] in seen for i in range(2, len(path))):\n        #         seen.add(path)\n        # return seen\n    \n                \n#Trie\n#         trie = {}\n#         for path in folder:\n#             curr = trie\n#             for f in path.split('/'):\n#                 if f in curr:\n#                     curr = curr[f]\n#                 else:\n#                     curr[f] = {}\n#                     curr = curr[f]\n#             curr[None] = None\n        \n#         res = []\n#         for path in folder:\n#             curr = trie\n#             issub = False\n#             for f in path.split('/'):\n#                 if None in curr: \n#                     issub = True\n#                 else:\n#                     curr = curr[f]\n#             if not issub:\n#                 res.append(path)\n                \n#         return res\n            \n            \n            \n            \n        \n        \n        \n                \n                \n            \n            \n            \n", "class Solution1:\n    #1.Sort the folders;\n    #2. For each folder check if the followings are child folders; if yes, ignore; otherwise, count it in\n    \\\"\\\"\\\"\n    I think the time complexity for method 2 is actually O(n * m * logn).\n    Because the sort is based on merge sort for Object and time complexity of merge sort is O(n * logn). That means n * logn times comparing happened.\n    For this question, it just makes the comparing time be O(m). Thus it won't increase the number of \\\"layers\\\" of merge sort to log(n * m).\n\n    Time: O(n * m * log(n)), space: O(1)(excluding space cost of sorting part), where n = folder.length, m = average size of the strings in folder.\n\n    \\\"\\\"\\\"\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        ans = []\n        folder.sort()\n        for f in folder:\n            if not ans or not f.startswith(ans[-1] + '/'): #need '/' to ensure a parent.\n                ans.append(f)\n        return ans\n    \n    \nclass Trie:\n    def __init__(self):\n        self.sub = collections.defaultdict(Trie)\n        self.index = -1\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        self.root = Trie()\n        for i in range(len(folder)):\n            cur = self.root\n            for c in folder[i]:\n                cur = cur.sub[c]\n            cur.index = i\n        return self.bfs(self.root, folder)\n    def bfs(self, trie: Trie, folder: List[str]) -> List[str]:\n        q, ans = [trie], []\n        for t in q:\n            if t.index >= 0:\n                ans.append(folder[t.index])\n            for c in t.sub.keys():\n                if '/' != c or t.index < 0:\n                    q.append(t.sub.get(c))\n        return ans", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder_subs = []\n        folder.sort(key=len)\n        for f in folder:\n            flag = False\n            for j in folder_subs:\n                if f.startswith(j + '/'):\n                    flag = True\n                    break\n            if not flag:\n                folder_subs.append(f)\n                    \n        return folder_subs", "class Trie:\n    def __init__(self):\n        self.sub = collections.defaultdict(Trie)\n        self.index = -1\n    \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        root = Trie()\n        for i in range(len(folder)):\n            curr = root\n            for c in folder[i]:\n                curr = curr.sub[c]\n            curr.index = i\n        q, res = [root], []\n        for t in q:\n            if t.index >= 0:\n                res.append(folder[t.index])\n            for c in t.sub.keys():\n                if c != '/' or t.index < 0:\n                    q.append(t.sub.get(c))\n        return res", "class Solution:\n    def removeSubfolders(self, folders: List[str]) -> List[str]:\n        dirs = set()\n        folders = sorted(list(filter(None,folder.split('/'))) for folder in folders)\n        \n        print(folders)\n        \n        for folder_fp in folders:\n            curr_name = \\\"\\\"\n            for folder in folder_fp:\n                curr_name += f\\\"/{folder}\\\"\n                if curr_name in dirs:\n                    break\n            else:\n                dirs.add(curr_name)\n            #print(dirs)\n        return dirs", "class Trie:\n    def __init__(self):\n        self.children = collections.defaultdict(Trie)\n        self.index = -1\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        self.root = Trie()\n        \n        for i, f in enumerate(folder):\n            curr = self.root\n            for ch in f:\n                curr = curr.children[ch]\n            curr.index = i\n        # print(self.root)\n        return self.bfs(self.root, folder)\n        \n    def bfs(self, trie, folder):\n        q = [trie]\n        res = []\n        \n        for node in q:\n            if node.index >= 0:\n                res.append(folder[node.index])\n                for c in node.children:\n                    if c != '/':\n                        q.append(node.children[c])\n            else:\n                for c in node.children:\n                    # if c != '/':\n                    q.append(node.children[c])\n        return res\n# class Trie:\n#     def __init__(self):\n#         self.sub = collections.defaultdict(Trie)\n#         self.index = -1\n# class Solution:\n#     def removeSubfolders(self, folder: List[str]) -> List[str]:\n#         self.root = Trie()\n#         for i in range(len(folder)):\n#             curr = self.root\n#             for ch in folder[i]:\n#                 curr = curr.sub[ch]\n#             curr.index = i\n#         return self.bfs(self.root, folder)\n    \n#     def bfs(self, node, folder):\n#         q, ans = [node], []\n#         for t in q:\n#             if t.index >= 0:\n#                 ans.append(folder[t.index])\n#             # else:\n#             for c in t.sub:\n#                 if c != '/' or t.index < 0:\n#                     q.append(t.sub.get(c))\n#         return ans\n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder_subs = []\n        folder_k = sorted(folder, key=len)\n        for f in folder_k:\n            flag = False\n            for j in folder_subs:\n                if f.startswith(j + '/'):\n                    flag = True\n                    break\n            if not flag:\n                folder_subs.append(f)\n                    \n        return folder_subs", "class Trie:\n    def __init__(self):\n        self.sub = collections.defaultdict(Trie)\n        self.index = -1\n    \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        root = Trie()\n        for i in range(len(folder)):\n            curr = root\n            for c in folder[i]:\n                curr = curr.sub[c]\n            curr.index = i\n        q, res = [root], []\n        for t in q:\n            if t.index >= 0:\n                res.append(folder[t.index])\n            for c in t.sub:\n                if c != '/' or t.index < 0:\n                    q.append(t.sub.get(c))\n        return res", "class Solution:\n    def removeSubfolders(self, folders: List[str]) -> List[str]:\n        \n        folders.sort()\n        first = folders[0]\n        res_set = set()\n        res_set.add(first)\n        for i in range(1, len(folders)):\n            folder = folders[i]\n            if folder.startswith(first) and folder.count('/') > first.count('/'):\n                pass\n            else:\n                res_set.add(folder)\n                res_set.add(first)\n                first = folder\n        \n        res = list(res_set)\n        res.sort()\n        return res", "class Trie:\n    def __init__(self):\n        self.children = collections.defaultdict(Trie)\n        self.index = -1\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        self.root = Trie()\n        \n        for i, f in enumerate(folder):\n            curr = self.root\n            for ch in f:\n                curr = curr.children[ch]\n            curr.index = i\n        # print(self.root)\n        return self.bfs(self.root, folder)\n        \n    def bfs(self, trie, folder):\n        q = [trie]\n        res = []\n        \n        for node in q:\n            if node.index >= 0:\n                res.append(folder[node.index])\n            # else:\n            for c in node.children:\n                if c != '/' or node.index == -1:\n                    q.append(node.children.get(c))\n        return res\n# class Trie:\n#     def __init__(self):\n#         self.sub = collections.defaultdict(Trie)\n#         self.index = -1\n# class Solution:\n#     def removeSubfolders(self, folder: List[str]) -> List[str]:\n#         self.root = Trie()\n#         for i in range(len(folder)):\n#             curr = self.root\n#             for ch in folder[i]:\n#                 curr = curr.sub[ch]\n#             curr.index = i\n#         return self.bfs(self.root, folder)\n    \n#     def bfs(self, node, folder):\n#         q, ans = [node], []\n#         for t in q:\n#             if t.index >= 0:\n#                 ans.append(folder[t.index])\n#             # else:\n#             for c in t.sub:\n#                 if c != '/' or t.index < 0:\n#                     q.append(t.sub.get(c))\n#         return ans\n", "class Solution1:\n    #1.Sort the folders;\n    #2. For each folder check if the followings are child folders; if yes, ignore; otherwise, count it in\n    \\\"\\\"\\\"\n    I think the time complexity for method 2 is actually O(n * m * logn).\n    Because the sort is based on merge sort for Object and time complexity of merge sort is O(n * logn). That means n * logn times comparing happened.\n    For this question, it just makes the comparing time be O(m). Thus it won't increase the number of \\\"layers\\\" of merge sort to log(n * m).\n\n    Time: O(n * m * log(n)), space: O(1)(excluding space cost of sorting part), where n = folder.length, m = average size of the strings in folder.\n\n    \\\"\\\"\\\"\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        ans = []\n        folder.sort()\n        for f in folder:\n            if not ans or not f.startswith(ans[-1] + '/'): #need '/' to ensure a parent.\n                ans.append(f)\n        return ans\n    \n    \nclass Trie:\n    def __init__(self):\n        self.sub = collections.defaultdict(Trie)\n        self.index = -1\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        self.root = Trie()\n        for i in range(len(folder)):\n            cur = self.root\n            for c in folder[i]:\n                cur = cur.sub[c]\n            cur.index = i\n        return self.bfs(self.root, folder)\n    def bfs(self, trie: Trie, folder: List[str]) -> List[str]:\n        q, ans = [trie], []\n        for t in q:\n            if t.index >= 0:\n                ans.append(folder[t.index])\n            for c in t.sub.keys():\n                if '/' != c or t.index < 0:\n                    q.append(t.sub.get(c))\n        return ans\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\nclass Trie3:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEnd = True  \n    \n    def find(self):\n        def dfs(direc, node):\n            if node.isEnd:\n                answer.append('/' + '/'.join(direc))\n                return\n            for char in node.children:\n                dfs(direc + [char], node.children[char])\n        \n        answer = []\n        dfs([], self.root)\n        return answer\n\n\nclass Solution3:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = Trie()\n        for f in folder:\n            f = f.split('/')[1:]\n            trie.insert(f)\n        return trie.find()", "# class Trie:\n#     def __init__(self):\n#         self.children = collections.defaultdict(Trie)\n#         self.index = -1\n# class Solution:\n#     def removeSubfolders(self, folder: List[str]) -> List[str]:\n#         self.root = Trie()\n        \n#         for i, f in enumerate(folder):\n#             curr = self.root\n#             for ch in f:\n#                 curr = curr.children[ch]\n#             curr.index = i\n#         # print(self.root)\n#         return self.bfs(self.root, folder)\n        \n#     def bfs(self, trie, folder):\n#         q = [trie]\n#         res = []\n        \n#         for node in q:\n#             if node.index >= 0:\n#                 res.append(folder[node.index])\n#             else:\n#                 for c in node.children:\n#                     q.append(c)\n#         return res\nclass Trie:\n    def __init__(self):\n        self.sub = collections.defaultdict(Trie)\n        self.index = -1\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        self.root = Trie()\n        for i in range(len(folder)):\n            curr = self.root\n            for ch in folder[i]:\n                curr = curr.sub[ch]\n            curr.index = i\n        return self.bfs(self.root, folder)\n    \n    def bfs(self, node, folder):\n        q, ans = [node], []\n        for t in q:\n            if t.index >= 0:\n                ans.append(folder[t.index])\n            # else:\n            for c in t.sub.keys():\n                if c != '/' or t.index < 0:\n                    q.append(t.sub.get(c))\n        return ans", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        # \n        class TrieNode:\n            def __init__(self):\n                self.children = defaultdict(TrieNode)\n                self.index = -1\n        res = []\n        root = TrieNode()\n        for i in range(len(folder)):\n            trie = root\n            for c in folder[i]:\n                trie = trie.children[c]\n            trie.index = i\n        res = []\n        \n        # bfs\n        q = [root]\n        while q:\n            node = q.pop(0)\n            if node.index != -1:\n                res.append(folder[node.index])\n            # \u6587\u4ef6\u540d\u53ef\u80fd\u5305\u542b\u591a\u4e2a\u5b57\u7b26\n            # [\\\"/a/b/c\\\",\\\"/a/b/ca\\\",\\\"/a/b/d\\\"]\n            for c in node.children.keys():\n                if node.index < 0 or c!='/':\n                    q.append(node.children[c])\n                \n        return res", "class Trie:\n    def __init__(self):\n        self.root = {\\\"*\\\": \\\"*\\\"}\n\n    def add(self, word):\n        current = self.root\n        for letter in word:\n            if letter not in current:\n                current[letter] = {}\n            current = current[letter]\n        current[\\\"*\\\"] = \\\"*\\\"\n\n    def has(self, word):\n        current = self.root\n        for letter in word:\n            if letter not in current:\n                return False\n            current = current[letter]\n\n        return \\\"*\\\" in current\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:        \n        # folder = sorted(folder1, key=len) \n        trie = Trie()\n        for fol in folder:\n            trie.add(fol)\n        \n        response = list()\n        response_obj = {}\n        # for fol in reversed(folder):\n        for fol in folder:\n            key = fol[:fol.rindex(\\\"/\\\")]\n            if key in response_obj:\n                continue\n            else:\n                while key:\n                    if key in response_obj:\n                        break    \n                    elif trie.has(key):\n                        break\n                    key = key[:key.rindex(\\\"/\\\")]\n            \n            if not key:\n                response.append(fol)\n                response_obj[fol] = \\\"\\\"\n                \n        del trie\n        return response", "class Solution:\n    class TrieNode:\n        def __init__(self):\n            self.lookup = {}\n            self.word = False\n    \n    class Trie:\n        def __init__(self):\n            self.root = Solution.TrieNode()\n            \n        def addPath(self,word):\n            currNode = self.root\n            for char in word:\n                if char not in currNode.lookup:\n                    currNode.lookup[char] = Solution.TrieNode()\n                currNode = currNode.lookup[char]\n            currNode.word = True\n            \n        def shortPath(self,word):\n            currNode = self.root\n            for index, char in enumerate(word):\n                if currNode.word and char == '/':\n                    return word[:index]\n                currNode = currNode.lookup[char]\n            \n            return word\n    \n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = Solution.Trie()\n        result = set()\n        for path in folder:\n            trie.addPath(path)\n            \n        for path in folder:\n            result.add(trie.shortPath(path))\n            \n        return list(result)\n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        class Trie:\n            def __init__(self):\n                self.child = {}\n                self.is_word = False\n            def add(self,word):\n                curr = self\n                for w in word:\n                    if w not in curr.child:\n                        curr.child[w] = Trie()\n                    curr = curr.child[w]\n                curr.is_word = True\n            def get_val(self,word):\n                curr = self\n                ans = \\\"\\\"\n                for w in word:\n                    if w in curr.child:\n                        ans += w\n                        curr = curr.child[w]\n                        if curr.is_word and \\\"/\\\" in curr.child:\n                            return ans\n                return ans\n        def remove_dir(folders):\n            trie = Trie()\n            ans = set()\n            for f in folders:\n                trie.add(f)\n            for f in folders:\n                ans.add(trie.get_val(f))\n            return list(ans)\n        return remove_dir(folder)", "class Trie:\n    def __init__(self):\n        self.root = {\\\"*\\\": \\\"*\\\"}\n\n    def add(self, word):\n        current = self.root\n        for letter in word:\n            if letter not in current:\n                current[letter] = {}\n            current = current[letter]\n        current[\\\"*\\\"] = \\\"*\\\"\n\n    def has(self, word):\n        current = self.root\n        for letter in word:\n            if letter not in current:\n                return False\n            current = current[letter]\n\n        return \\\"*\\\" in current\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = Trie()\n        for fol in folder:\n            trie.add(fol)\n        \n        response = list()\n        response_obj = {}\n        for fol in folder:\n            key = fol[:fol.rindex(\\\"/\\\")]\n            while key:\n                if key in response_obj:\n                    break    \n                elif trie.has(key):\n                    break\n                key = key[:key.rindex(\\\"/\\\")]\n            \n            if not key:\n                response.append(fol)\n                response_obj[fol] = \\\"\\\"\n\n        return response", "from collections import deque\n\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def insert(self, word):\n        p = self.root\n        for c in word:\n            if c not in p.children:\n                p.children[c] = TrieNode()\n            p = p.children[c]\n            \n        p.is_word = True\n        return p\n\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        if folder is None or not folder:\n            return []\n        \n        trie = Trie()\n        \n        for f in folder:\n            trie.insert(f)\n            \n        ret = []\n        \n        queue = deque([(trie.root, '')])\n        \n        while queue:\n            p, acc = queue.popleft()\n            \n            if p.is_word:\n                ret.append(acc)\n                \n            for letter in p.children:\n                if p.is_word and letter == '/':\n                    continue\n                queue.append((p.children[letter], acc + letter))\n                \n        return ret", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        \n        folder.sort(key = lambda x: len(x))\n        res = []\n        # while folder:\n        #     e = folder.pop()\n        #     for p in folder:\n        #         if e.startswith(p) and e[len(p)] == '/':\n        #                 e = ''   \n        #                 break\n        #     if e: res.append(e)\n        # return res\n    \n        trie = defaultdict(dict)\n        for t in folder:\n            m = trie\n            parent = False\n            for c in t.split('/'):\n                \n                if c in m: m = m[c]\n                else: \n                    m[c] = {}\n                    m = m[c]\n                if '$' in m: \n                    parent = True\n                    break\n            if not parent:\n                m[\\\"$\\\"] = '$'\n                res.append(t)\n        return res\n            ", "class Trie:\n    def __init__(self):\n        self.root = {\\\"*\\\": \\\"*\\\"}\n\n    def add(self, word):\n        current = self.root\n        for letter in word:\n            if letter not in current:\n                current[letter] = {}\n            current = current[letter]\n        current[\\\"*\\\"] = \\\"*\\\"\n\n    def has(self, word):\n        current = self.root\n        for letter in word:\n            if letter not in current:\n                return False\n            current = current[letter]\n\n        return \\\"*\\\" in current\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:        \n        # folder = sorted(folder1, key=len) \n        trie = Trie()\n        for fol in folder:\n            trie.add(fol)\n        \n        response = list()\n        response_obj = {}\n        # for fol in reversed(folder):\n        for fol in folder:\n            key = fol[:fol.rindex(\\\"/\\\")]\n            if key in response_obj:\n                continue\n            else:\n                while key:\n                    if key in response_obj:\n                        break    \n                    if trie.has(key):\n                        break\n                    key = key[:key.rindex(\\\"/\\\")]\n            \n            if not key:\n                response.append(fol)\n                response_obj[fol] = \\\"\\\"\n                \n        del trie\n        return response", "class Trie:\n    def __init__(self):\n        self.root = {\\\"*\\\": \\\"*\\\"}\n\n    def add(self, word):\n        current = self.root\n        for letter in word:\n            if letter not in current:\n                current[letter] = {}\n            current = current[letter]\n        current[\\\"*\\\"] = \\\"*\\\"\n\n    def has(self, word):\n        current = self.root\n        for letter in word:\n            if letter not in current:\n                return False\n            current = current[letter]\n\n        return \\\"*\\\" in current\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:        \n        # folder = sorted(folder1, key=len) \n        trie = Trie()\n        for fol in folder:\n            trie.add(fol)\n        \n        response = list()\n        # for fol in reversed(folder):\n        for fol in folder:\n            key = fol[:fol.rindex(\\\"/\\\")]\n            while key:\n                if trie.has(key):\n                    break\n                key = key[:key.rindex(\\\"/\\\")]\n            \n            if not key:\n                response.append(fol)\n                \n        del trie\n        return response", "class Trie:\n    def __init__(self):\n        self.root = {\\\"*\\\": \\\"*\\\"}\n\n    def add(self, word):\n        current = self.root\n        for letter in word:\n            if letter not in current:\n                current[letter] = {}\n            current = current[letter]\n        current[\\\"*\\\"] = \\\"*\\\"\n\n    def has(self, word):\n        current = self.root\n        for letter in word:\n            if letter not in current:\n                return False\n            current = current[letter]\n\n        return \\\"*\\\" in current\n\nclass Solution:\n    def removeSubfolders(self, folder1: List[str]) -> List[str]:        \n        folder = sorted(folder1, key=len) \n        trie = Trie()\n        for fol in folder:\n            trie.add(fol)\n        \n        response = set()\n        # for fol in reversed(folder):\n        for fol in folder:\n            key = fol[:fol.rindex(\\\"/\\\")]\n            while key:\n                if trie.has(key):\n                    break\n                key = key[:key.rindex(\\\"/\\\")]\n            \n            if not key:\n                response.add(fol)\n                \n        del trie\n        return response", "class Solution:\n    # 432 ms, 36.84%\n    # def removeSubfolders(self, folder: List[str]) -> List[str]:\n    #     folder.sort()\n    #     l  = [folder[0]]\n    #     p = folder[0]\n    #     for f in folder[1:]:\n    #         if not f.startswith(p + '/'):\n    #             l.append(f)\n    #             p = f\n    #     return l\n    \n    \n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        def insert(f):\n            t = r\n            for c in f:\n                if c not in t.ch:\n                    t.ch[c] = TrieNode()\n                t = t.ch[c]\n            t.ch['/'] = TrieNode()\n            t = t.ch['/']\n            t.d = True\n        def search(f):\n            t = r\n            for c in f:\n                t = t.ch[c]\n                if t.d:\n                    return False\n            return True\n        r = TrieNode()\n        for f in folder:\n            insert(f)\n        l = []\n        for f in folder:\n            if search(f):\n                l.append(f)\n        return l\n    \nclass TrieNode:\n    def __init__(self):\n        self.ch = {}\n        self.d = False", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort()\n        # ans = [ folder[0]]\n        # prev = folder[0] + '/'\n        # for f in folder[1:]:\n        #     if not f.startswith(prev):\n        #         ans.append(f)\n        #         prev = f+'/'\n        # return ans\n        \n        #using set\n        ans = []\n        seen = set(folder)\n        for i in folder:\n            path = i\n            while path:\n                path = path[:path.rfind('/')]\n                if path in seen:\n                    break\n            else:\n                ans.append(i)\n        return (ans)", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        seen = set()\n        folder.sort(key=len)\n        \n        for fd in folder:\n            for i in range(2, len(fd)):\n                if fd[i] == \\\"/\\\":\n                    if fd[:i] in seen:\n                        break\n            else:\n                seen.add(fd)\n                \n        return list(seen)\n                \n                        \n                        \n                    \n                \n        ", "def is_parent(f1, f2):\n            f1 = f1.split('/')\n            f2 = f2.split('/')\n            if len(f1) > len(f2): \n                return False\n            for a, b in zip(f1, f2):\n                if a!=b:\n                    return False\n            return True\n    \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder = sorted(folder)\n        ans = []\n        \n            \n        for f in folder:\n            if not ans or not is_parent(ans[-1], f):\n                ans.append(f)                \n        return ans\n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort()\n        ans = [ folder[0]]\n        prev = folder[0] + '/'\n        for f in folder[1:]:\n            if not f.startswith(prev):\n                ans.append(f)\n                prev = f+'/'\n        return ans", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort(key = lambda f:len(f))\n        \n        seen = set()\n        \n        for f in folder:\n            for i in range(2, len(f)):\n                if f[i] == '/' and f[: i] in seen:\n                    break\n            else:\n                seen.add(f)\n                    \n        return list(seen)", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        if not folder:\n            return None \n        folder.sort(key = lambda x: len(x))\n        seen = set()\n        for fold in folder:\n            for i in range(2, len(fold)):\n                if fold[i] == '/' and fold[:i] in seen:\n                    break \n            else:\n                seen.add(fold)\n        return list(seen)", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder = sorted(folder,key = lambda e: len(e))\n        res = set()\n        for f in folder:\n            flag = True\n            for i in range(2, len(f)):\n                if f[i] == '/' and f[:i] in res:\n                    flag = False\n                    break\n            if flag:\n                res.add(f)\n        return list(res)\n", "class TrieNode:\n    def __init__(self):\n        self.d = {}\n        self.w = False\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder = sorted(folder)\n        root = TrieNode()\n        res = []\n        for file in folder:\n            p = root\n            end = False\n            for w in file.split('/'):\n                if p.w:\n                    end = True\n                    break\n                if w not in p.d:\n                    p.d[w] = TrieNode()\n                p = p.d[w]\n            if end:\n                continue\n            p.w = True\n            res.append(file)\n        return res\n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        '''\n        Build trie from the folders, whenever a folder ends, just drop all of its children (subfolders) in the trie.\n        '''\n        trie = {}\n        for f in folder:\n            path = f.split('/')[1:]\n            cur = trie\n            for idx, p in enumerate(path):\n                if idx == len(path) - 1:\n                    # this is the ending folder\n                    cur[p] = '#'\n                else:\n                    if p in cur:\n                        if cur[p] != '#':\n                            cur = cur[p]\n                        else:\n                            # we see an ending folder, stop adding subfolders to it\n                            break\n                    else:\n                        cur[p] = {}\n                        cur = cur[p]\n        \n        # do a DFS of the trie to get the answers\n        ans = []\n        def dfs(cur_dir, path):\n            if cur_dir == '#':\n                ans.append('/' + '/'.join(path))\n                return\n            for k in cur_dir:\n                dfs(cur_dir[k], path + [k])\n            return\n        dfs(trie, [])\n        return ans\n            \n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        '''\n        Build trie from the folders, whenever a folder ends, just drop all of its children (subfolders) in the trie.\n        Time O(N) to build the trie and do DFS\n        Space O(N) for the trie\n        '''\n        trie = {}\n        for f in folder:\n            path = f.split('/')[1:]\n            cur = trie\n            for idx, p in enumerate(path):\n                if idx == len(path) - 1:\n                    # this is the ending folder\n                    cur[p] = '#'\n                else:\n                    if p in cur:\n                        if cur[p] != '#':\n                            cur = cur[p]\n                        else:\n                            # we see an ending folder, stop adding subfolders to it\n                            break\n                    else:\n                        cur[p] = {}\n                        cur = cur[p]\n        \n        # do a DFS of the trie to get the answers\n        ans = []\n        def dfs(cur_dir, path):\n            if cur_dir == '#':\n                ans.append(path)\n                return\n            for k in cur_dir:\n                dfs(cur_dir[k], path + '/' + k)\n            return\n        dfs(trie, '')\n        return ans\n            \n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        '''\n        Build trie from the folders, whenever a folder ends, just drop all of its children (subfolders) in the trie.\n        Time O(N) to build the trie and do DFS\n        Space O(N) for the trie\n        '''\n        trie = {}\n        for f in folder:\n            path = f.split('/')[1:]\n            cur = trie\n            for idx, p in enumerate(path):\n                if idx < len(path) - 1:\n                    if p in cur:\n                        if cur[p] != '#':\n                            cur = cur[p]\n                        else:\n                            # we see an ending folder, stop adding subfolders to it\n                            break\n                    else:\n                        cur[p] = {}\n                        cur = cur[p]\n                else:\n                    # this is the ending folder\n                    cur[p] = '#'\n                    \n        \n        # do a DFS of the trie to get the answers\n        ans = []\n        def dfs(cur_dir, path):\n            if cur_dir == '#':\n                ans.append(path)\n                return\n            for k in cur_dir:\n                dfs(cur_dir[k], path + '/' + k)\n            return\n        dfs(trie, '')\n        return ans\n            \n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        '''\n        Build trie from the folders, whenever a folder ends, just drop all of its children (subfolders) in the trie.\n        Time O(N) to build the trie and do DFS\n        Space O(N) for the trie\n        '''\n        trie = {}\n        for f in folder:\n            path = f.split('/')[1:]\n            cur = trie\n            for idx, p in enumerate(path):\n                if idx == len(path) - 1:\n                    # this is the ending folder\n                    cur[p] = '#'\n                else:\n                    if p in cur:\n                        if cur[p] != '#':\n                            cur = cur[p]\n                        else:\n                            # we see an ending folder, stop adding subfolders to it\n                            break\n                    else:\n                        cur[p] = {}\n                        cur = cur[p]\n        \n        # do a DFS of the trie to get the answers\n        ans = []\n        def dfs(cur_dir, path):\n            if cur_dir == '#':\n                ans.append('/' + '/'.join(path))\n                return\n            for k in cur_dir:\n                dfs(cur_dir[k], path + [k])\n            return\n        dfs(trie, [])\n        return ans\n            \n", "class Solution:\n    def removeSubfolders(self, folders: List[str]) -> List[str]:\n        folders.sort()\n        output = []\n        parent = ' '\n        for folder in folders:\n            if not folder.startswith(parent):\n                output.append(folder)\n                parent = folder+'/'\n        return output", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        s_f = sorted(folder)\n        root = {}\n        result = []\n        for i in range(len(s_f)):\n            path = s_f[i]\n            p_arr = path.split(\\\"/\\\")[1:]\n            cur = root\n            for j in range(len(p_arr)):\n                if -1 in cur:\n                    break\n                #abc\n                if p_arr[j] not in cur:\n                    cur[p_arr[j]] = {}\n                cur = cur[p_arr[j]]\n                if j == len(p_arr) - 1:\n                    cur[-1] = i\n                    result.append(path)\n        return result\n            \n            ", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        self.trie = {}\n        \n        for path in folder:\n            node = self.trie\n            for c in path.split('/'):\n                if c not in node:\n                    node[c] = {}\n                node = node[c]\n            node['*'] = True\n            \n        res = []\n        node = self.trie\n        stack = [(node, [])]\n        while len(stack):\n            node, prefix = stack.pop()\n            if '*' in node and node['*']:\n                res.append('/'.join(prefix))\n            else:\n                for k, v in list(node.items()):\n                    stack.append((v, prefix+[k]))\n                    \n        return res\n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        res = []\n        folder.sort(key = lambda x: len(x))\n        seen = set()\n        for f in folder:\n            if not any(f[i] == '/' and f[:i] in seen for i in range(2, len(f))):\n                seen.add(f)\n        return list(seen)\n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort()\n        seen = set()\n        for path in folder:\n            if not any(path[i] == '/' and path[:i] in seen for i in range(2, len(path))):\n                seen.add(path)\n        return seen\n    \n                \n# Trie\n#         trie = {}\n#         for path in folder:\n#             curr = trie\n#             for f in path.split('/'):\n#                 if f in curr:\n#                     curr = curr[f]\n#                 else:\n#                     curr[f] = {}\n#                     curr = curr[f]\n#             curr[None] = None\n        \n#         res = []\n#         for path in folder:\n#             curr = trie\n#             issub = False\n#             for f in path.split('/'):\n#                 if None in curr: \n#                     issub = True\n#                 else:\n#                     curr = curr[f]\n#             if not issub:\n#                 res.append(path)\n                \n#         return res\n            \n            \n            \n            \n        \n        \n        \n                \n                \n            \n            \n            \n", "from collections import defaultdict\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        Trie = lambda: defaultdict(Trie)\n        trie = Trie()\n\n        for f in folder:\n            t = trie\n            for c in f[1:].split('/'):\n                t = t[c]\n            t[None] = None\n\n        res = []\n\n        def dfs(t, path=[]):\n            if None in t:\n                res.append('/' + '/'.join(path))\n                return\n\n            for c, nt in list(t.items()):\n                path.append(c)\n                dfs(nt, path)\n                path.pop()\n\n        dfs(trie)\n\n        return res\n\n", "class TreeNode:\n    \n    def __init__(self, val):\n        self.val = val\n        self.folders = {}\n        self.exist = False\n        \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        \n        self.tree = TreeNode('.')\n        for this_folder in folder:\n            path = this_folder.split('/')[1:]\n            pointer = self.tree\n            for name in path:\n                if pointer.exist:\n                    break\n                if name not in pointer.folders:\n                    pointer.folders[name] = TreeNode(name)\n                pointer = pointer.folders[name]\n            pointer.exist = True\n        \n        ret = []\n        \n        # print(self.tree)\n        # print(self.tree.folders)\n        # print(self.tree.folders['a'].folders)\n        # print(self.tree.folders['a'].exist)\n        \n        def buildPath(curr, path):\n            if curr is None:\n                return\n            if curr.exist:\n                ret.append(path)\n                return\n            for sub_name, sub in curr.folders.items():\n                buildPath(sub, path + '/' + sub_name)\n        \n        buildPath(self.tree, '')\n        return ret", "class TreeNode:\n    def __init__(self):\n        self.val = '/'\n        self.children = {}\n        self.isleaf = False\n        \n    def insert(self, val):\n        if not val:\n            self.isleaf = True\n            return\n        if val[0] in self.children:\n            self.children[val[0]].insert(val[1:])\n            return\n        newnode = TreeNode()\n        newnode.val = val[0]\n        self.children[val[0]] = newnode\n        newnode.insert(val[1:])\n    \n    def isparent(self, val):\n        if val and val[0] in self.children:\n            return self.children[val[0]].isleaf or self.children[val[0]].isparent(val[1:])\n        return False\n    \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder = sorted(folder)\n        ans = []\n        \n        fs = TreeNode()\n        for f in folder:\n            has_parent = fs.isparent(f.split('/'))\n            if not has_parent:\n                ans.append(f)\n                fs.insert(f.split('/'))\n        return ans\n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        if not folder:\n            return []\n        \n        trie = {}\n        for folderPath in folder:\n            paths = folderPath.split(\\\"/\\\")\n            \n            node  = trie\n            parent = None\n            parentExists = False\n            for path in paths[:-1]:\n                if \\\"$\\\" in node:\n                    parentExists = True\n                    break\n                \n                if path not in node:\n                    node[path] = {}\n                \n                parent = node\n                node = node[path]\n            \n            if parentExists or \\\"$\\\" in node: continue\n            \n            #print(node, paths[-1])\n            node[paths[-1]] = {\\\"$\\\": {}}\n        \n        #print(trie)\n        self.res = []\n        self.dfs(trie, [])\n        return self.res\n    \n    def dfs(self, node, pathList):\n        for key in node:\n            if key == \\\"$\\\":\n                self.res.append(\\\"/\\\".join(pathList))\n            else:\n                pathList.append(key)\n                self.dfs(node[key], pathList)\n                pathList.pop()\n        \n            \n    \n            \n                \n            \n        \n        ", "class TrieNode:\n    def __init__(self, val):\n        self.val = val\n        self.next = {}\n        self.path = None\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = TrieNode(\\\"\\\")\n        \n        for path in folder:\n            node = trie\n            names = path.split(\\\"/\\\")[1:]\n            \n            for name in names:\n                if node.path:\n                    break\n                if name not in node.next:\n                    node.next[name] = TrieNode(name)\n                node = node.next[name]\n            else:\n                node.path = path\n            \n        res = []\n        \n        self.dfs(trie, res)\n                \n        return res\n    \n    def dfs(self, node, res):\n        if node.path:\n            res.append(node.path)\n            return\n        \n        for child in node.next:\n            self.dfs(node.next[child], res)\n                    \n# time: O(n*m)\n# space: O(n*m)", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        \n        \n        folders_set = set(folder)\n        res = []\n        # print(folders, \\\"/a\\\" in folders)\n        \n        \n        for folder_and_subfolder in folder:\n            \n            folders = folder_and_subfolder.split('/')[1:]\n            print(folders)\n            \n            i = 0 \n            subfolder = \\\"/\\\"\n            flag = False\n            while i < len(folders):\n                \n                subfolder = subfolder + str(folders[i]) \n                # print((subfolder), str(subfolder) in folders_set)\n                if subfolder in folders_set:\n                    flag = True\n                    res.append(subfolder)\n                    break\n                subfolder += \\\"/\\\"\n                \n                i+=1\n            if not flag:\n                res.append(subfolder)\n                \n            \n        return list(set(res))\n                \n            \n            ", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        # time O(mn+nlogn); space O(m)\n        res = []\n        for f in sorted(folder):\n            if not res or not f.startswith(res[-1] + '/'):\n                res.append(f)\n        return res", "class TreeNode:\n    def __init__(self, val='/'):\n        self.val = val\n        self.children = {}\n        self.isleaf = False\n        \n    def insert(self, val):\n        if not val:\n            self.isleaf = True\n            return\n        if val[0] in self.children:\n            self.children[val[0]].insert(val[1:])\n            return\n        newnode = TreeNode(val=val[0])\n        self.children[val[0]] = newnode\n        newnode.insert(val[1:])\n    \n    def isparent(self, val):\n        if val and val[0] in self.children:\n            return self.children[val[0]].isleaf or self.children[val[0]].isparent(val[1:])\n        return False\n    \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder = sorted(folder)\n        ans = []\n        fs = TreeNode()\n        for f in folder:\n            f_splitted = f.split('/')\n            has_parent = fs.isparent(f_splitted)\n            if not has_parent:\n                ans.append(f)\n                fs.insert(f_splitted)\n        return ans\n", "class TreeNode:\n    def __init__(self):\n        self.val = '/'\n        self.children = []\n        self.isleaf = False\n        \n    def insert(self, val):\n        if not val:\n            self.isleaf = True\n            return\n        for child in self.children:\n            if child.val == val[0]:\n                child.insert(val[1:])\n                return\n        newnode = TreeNode()\n        newnode.val = val[0]\n        self.children.append(newnode)\n        newnode.insert(val[1:])\n    \n    def isparent(self, val):\n        for child in self.children:\n            if child.val == val[0] :\n                if child.isleaf:\n                    return True\n                return child.isparent(val[1:])\n        return False\n                    \ndef is_parent(f1, f2):\n            f1 = f1.split('/')\n            f2 = f2.split('/')\n            if len(f1) > len(f2): \n                return False\n            return all([ a==b for a, b in zip(f1, f2)])\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder = sorted(folder)\n        ans = []\n        \n        fs = TreeNode()\n        for f in folder:\n            has_parent = fs.isparent(f.split('/'))\n            if not has_parent:\n                ans.append(f)\n                fs.insert(f.split('/'))\n        return ans\n", "class Node:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n    \n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        if folder is None or not folder:\n            return []\n        \n        root = self._create_tree(folder)\n        \n        ret = []\n        self._helper(root, [], ret)\n        return ret\n        \n    def _helper(self, p, acc, ret):\n        if p.is_word:\n            ret.append('/' + '/'.join(acc))\n            return\n        \n        for c in p.children:\n            acc.append(c)\n            \n            self._helper(p.children[c], acc, ret)\n            \n            acc.pop()\n        \n        \n    def _create_tree(self, folder):\n        root = Node()\n        \n        for f in folder:\n            t = f.split('/')\n            p = root\n            \n            for i in range(1, len(t)):\n                if p.is_word:\n                    break\n                    \n                name = t[i]\n                if name not in p.children:\n                    p.children[name] = Node()\n                p = p.children[name]\n            p.is_word = True\n            p.children = {}\n        \n        return root", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = {}\n        tokens = {path: path.split('/') for path in folder}\n        for path in folder:\n            curr = trie\n            for token in tokens[path]:\n                if '#' in curr:\n                    break\n                if token not in curr:\n                    curr[token] = {}\n                curr = curr[token]\n            curr['#'] = True\n \n        paths = set(folder)\n        for path in folder:\n            curr = trie\n            for token in tokens[path]:\n                if '#' in curr:\n                    paths.remove(path)\n                    break\n                curr = curr[token]    \n        return list(paths) \n                \n", "class Trie():\n    def __init__(self):\n        self.children = {}\n        \n    def put(self, s):\n        s = s.split(\\\"/\\\")\n        check = self.children\n        for c in s[1:]:\n            if c not in check:\n                check[c] = {}\n            check = check[c]\n        check[-1] = True\n    \n    def find(self, s):\n        s = s.split(\\\"/\\\")\n        check = self.children\n        for c in s[1:]:\n            if c not in check:\n                return False\n            check = check[c]\n        return -1 in check\n            \n    \n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        ret = []\n        def dfs(children, build):\n            if -1 in children:\n                ret.append(\\\"/\\\"+\\\"/\\\".join(build))\n                return\n            for c in children:\n                dfs(children[c], build+[c])\n                \n        trie = Trie()\n        \n        for f in folder:\n            #print(f)\n            trie.put(f)\n        #print(trie.children)\n        check = trie.children\n        stack = []\n        dfs(check, [])\n        return ret\n                \n        \\\"\\\"\\\"\n        d = {}\n        ret = []\n        folder.sort()\n        for f in folder:\n            fl = f.split(\\\"/\\\")\n            for i in range(1, len(fl)):\n                tup_h = tuple(fl[1:i+1])\n                if tup_h in d:\n                    break\n                elif i == len(fl)-1:\n                    d[tup_h] = f\n                    ret.append(f)\n        return ret\n        \\\"\\\"\\\"", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = {}\n        for path in folder:\n            curr = trie\n            for f in path.split('/'):\n                if f in curr:\n                    curr = curr[f]\n                else:\n                    curr[f] = {}\n                    curr = curr[f]\n            curr[None] = None\n        \n        res = []\n        for path in folder:\n            curr = trie\n            issub = False\n            for f in path.split('/'):\n                if None in curr: \n                    issub = True\n                else:\n                    curr = curr[f]\n            if not issub:\n                res.append(path)\n                \n        return res\n            \n            \n            \n            \n        \n        \n        \n                \n                \n            \n            \n            \n", "# trie (dictionary tree)\n# time complexity: O(NM), N = len(folder), M = len(folder[0])\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        # 1st step\n        # build the dictionary tree\n        trie = dict()\n        trie[''] = [0,dict()]\n        for f in folder:\n            curr = trie\n            prev = None\n            for c in f.split('/'):\n                if c not in curr:\n                    curr[c] = [0,dict()]\n                #print(f'c=|{c}|')\n                prev = curr\n                curr = curr[c][1]\n            prev[c][0] = 1\n        \n        \n        # 2nd step\n        # traverse the dictionary tree in pre order, find the highest node with 1 of each subtree\n        clean = []\n        stack = [([''],trie[''])] # path, node\n        while stack:\n            p,(isPath,d) = stack.pop()\n            if isPath == 0:\n                for c in d:\n                    stack.append((p+[c], d[c]))\n            else:\n                clean.append('/'.join(p))\n        return clean\n            \n", "from pprint import pprint as pp\nclass Solution:\n    def removeSubfolders2(self, folder: List[str]) -> List[str]:\n        folder.sort(key=len)\n        st = set()\n        for f in folder:\n            for i in range(len(f)):\n                if f[i] == \\\"/\\\" and i > 0:\n                    if f[:i] in st:\n                        break\n            else:\n                st.add(f)\n        return list(st)\n    \n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = {}\n        def insert(t, word):\n            for w in word:\n                if w not in t:\n                    t[w] = {}\n                t = t[w]\n            t['#'] = word\n        for f in folder:\n            word = f.split('/')[1:]\n            insert(trie, word)\n        def dfs(t):\n            if '#' in t:\n                return ['/' + '/'.join(t['#'])]\n            res = []\n            for w in t:\n                res += dfs(t[w])\n            return res\n        return dfs(trie)", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = {}\n        for path in folder:\n            tokens = path.split('/')\n            curr = trie\n            for token in tokens:\n                if token not in curr:\n                    curr[token] = {}\n                curr = curr[token]\n            curr['#'] = True\n        \n        paths = set(folder)\n        for path in folder:\n            tokens = path.split('/')\n            curr = trie\n            for token in tokens:\n                if '#' in curr:\n                    paths.remove(path)\n                    break\n                curr = curr[token]    \n        return list(paths) \n                \n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        if not folder:\n            return []\n        folder.sort()\n        result = [folder[0]]\n        for f in folder:\n            if f != result[-1] and not f.startswith(result[-1] + \\\"/\\\"):\n                result.append(f)\n        return result\n                \n            \n            \n        ", "class Node:\n    def __init__(self, v):\n        self.v = v\n        self.children = {}\n    \n    def __repr__(self):\n        return f'Node({self.v} {self.children.keys()})'\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = Node('')\n        for f in folder:\n            self.add_to_trie(trie, f)\n        \n        return ['/' + '/'.join(i) for i in self.dfs(trie)]\n    \n    def dfs(self, cur):\n        if not cur.children:\n            return [[]]\n        res = []\n        for child, child_node in cur.children.items():\n            for sub_res in self.dfs(child_node):\n                res.append([child] + sub_res)\n        return res\n        \n    def add_to_trie(self, trie, f):\n        if not f:\n            return\n\n        sub_folders = f.split('/')[1:]\n        if sub_folders[0] in trie.children:\n            cur = trie\n            for i, sub_folder in enumerate(sub_folders):\n                if sub_folder not in cur.children and not cur.children:\n                    return\n                elif sub_folder not in cur.children:\n                    self.add_subs_to_trie(cur, i, sub_folders)\n                    return\n                else:\n                    cur = cur.children[sub_folder]\n            if cur.children:\n                cur.children = {}\n        else:\n            self.add_subs_to_trie(trie, 0, sub_folders)\n        \n    def add_subs_to_trie(self, trie, ix, sub_folders):\n        cur = trie\n        for i in range(ix, len(sub_folders)):\n            sub_folder = sub_folders[i]\n            cur.children[sub_folder] = Node(sub_folder)\n            cur = cur.children[sub_folder]", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        \n        if len(folder) == 1:\n            return folder\n        \n        #def is_subfolder(folder1, folder2):\n        #    s_f1 = folder1.split('/')\n        #    s_f2 = folder2.split('/')\n        #    \n        #    if len(s_f1) < len(s_f2):\n        #        i = 0\n        #        while i < len(s_f1):\n        #            if s_f1[i] == s_f2[i]:\n        #                i += 1\n        #            else:\n        #                return False\n        #        return True\n                    \n        \n        \n        folder.sort()\n        #for i,j in enumerate(folder):\n        i = 0\n        while i < len(folder) - 1:\n                #\n                #if is_subfolder(folder[i], folder[i+1]):\n                #if len(folder[i+1]) > len(folder[i]):\n            #if folder[i+1].startswith('{}/'.format(folder[i])):\n            if folder[i+1].startswith(folder[i]+'/'):\n            #if '{}/'.format(folder[i]) == folder[i+1][:(len(folder[i])+1)]:\n                folder.pop(i+1)\n            else:\n                i+=1\n            \n        return folder    \n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        tmp = '*'\n        res = []\n        for elem in sorted(folder):\n            if not elem.startswith(tmp):\n                tmp = elem + '/'\n                res.append(elem)\n        return res\n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        \n        if len(folder) == 1:\n            return folder\n        \n        #def is_subfolder(folder1, folder2):\n        #    s_f1 = folder1.split('/')\n        #    s_f2 = folder2.split('/')\n        #    \n        #    if len(s_f1) < len(s_f2):\n        #        i = 0\n        #        while i < len(s_f1):\n        #            if s_f1[i] == s_f2[i]:\n        #                i += 1\n        #            else:\n        #                return False\n        #        return True\n                    \n        \n        \n        folder.sort()\n        #for i,j in enumerate(folder):\n        i = 0\n        while i < len(folder) - 1:\n                #\n                #if is_subfolder(folder[i], folder[i+1]):\n                #if len(folder[i+1]) > len(folder[i]):\n            if folder[i+1].startswith('{}/'.format(folder[i])):\n            #if '{}/'.format(folder[i]) == folder[i+1][:(len(folder[i])+1)]:\n                folder.pop(i+1)\n            else:\n                i+=1\n            \n        return folder    \n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        res = set()\n        folder.sort(key = len)\n        for fold in folder:\n            flag = 0\n            for i in range(2, len(fold)):\n                if fold[i] == '/':\n                    if fold[:i] in res:\n                        flag = 1\n                        break\n            if flag == 0: res.add(fold)\n        return list(res)", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        \n        if len(folder) == 1:\n            return folder\n        \n        #def is_subfolder(folder1, folder2):\n        #    s_f1 = folder1.split('/')\n        #    s_f2 = folder2.split('/')\n        #    \n        #    if len(s_f1) < len(s_f2):\n        #        i = 0\n        #        while i < len(s_f1):\n        #            if s_f1[i] == s_f2[i]:\n        #                i += 1\n        #            else:\n        #                return False\n        #        return True\n                    \n        \n        \n        folder.sort()\n        #for i,j in enumerate(folder):\n        i = 0\n        while i < len(folder) - 1:\n                #\n                #if is_subfolder(folder[i], folder[i+1]):\n                #if len(folder[i+1]) > len(folder[i]):\n                #if folder[i+1].startswith('{}/'.format(folder[i])):\n            if '{}/'.format(folder[i]) == folder[i+1][:(len(folder[i])+1)]:\n                folder.pop(i+1)\n            else:\n                i+=1\n            \n        return folder    \n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n      dicts = {}\n      res = []\n      folder.sort(key = lambda x: len(x))\n      for fo in folder:\n        candidates = []\n        for i in range(len(fo)):\n          if fo[i] == '/':\n            candidates.append(i)\n        candidates = candidates[1:]\n        candidates.append(len(fo))\n        add = True\n        for can in candidates:\n          if fo[:can] in dicts:\n            add = False\n            break\n        if add: \n          res.append(fo)\n          dicts[fo] = 1\n      return res", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEnd = True  \n    \n    def get_smallest(self):\n        def dfs(path, node):\n            if node.isEnd:\n                answer.append('/' + '/'.join(path))\n                return\n            for char in node.children:\n                dfs(path + [char], node.children[char])\n        \n        answer = []\n        dfs([], self.root)\n        return answer\n\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = Trie()\n        for f in folder:\n            f = f.split('/')[1:]\n            trie.insert(f)\n        \n        return trie.get_smallest()", "class Trie:\n    def __init__(self):\n        self.chi = collections.defaultdict(Trie)\n        self.ise = False\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        root = Trie()\n        sta = []\n        for x in sorted(folder):\n            node = root\n            tmp = x[1:].split('/')\n            for y in tmp:\n                node = node.chi[y]\n                if node.ise:\n                    break\n            else:\n                node.ise = True\n                sta.append(x)\n        return sta", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        res = []\n        for f in sorted(folder):\n            if not res or not f.startswith(res[-1] + '/'):\n                res.append(f)\n        return res\n        # res = []\n        # folder.sort(key = lambda x: len(x))\n        # seen = set()\n        # for f in folder:\n        #     if not any(f[i] == '/' and f[:i] in seen for i in range(2, len(f))):\n        #         seen.add(f)\n        # return list(seen)\n", "class Trie:\n    def __init__(self):\n        self.child = {}\n        self.isLast = False\n        \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        if not folder: return []\n        root = Trie()\n        \n        # add\n        for sf in folder:\n            lists = sf[1:].split('/')\n            if lists: self.add(root, lists) # ['a'], ['a','b'], ['c','d'], ['c','d','e'], ['c','f']\n        \n        # retrieve\n        res=[]\n        self.dfs(root, [], res)\n        return res\n        \n    def dfs(self, root, temp, res):\n        cur = root\n        if cur.isLast: \n            res+='/'+'/'.join(temp),\n            return \n        for ch in cur.child:\n            self.dfs(cur.child[ch], temp+[ch], res)\n            \n            \n            \n        \n    def add(self, root, lists):        \n            \n        cur = root\n        for elem in lists:            \n            if elem not in cur.child: cur.child[elem]=Trie()\n            cur = cur.child[elem]\n        cur.isLast = True\n        \n", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n        \nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, pathes):\n        node = self.root\n        for p in pathes:\n            if p not in node.children:\n                node.children[p] = TrieNode()\n            node = node.children[p]\n        node.is_end = True\n        \n    def find(self):\n        ans = []\n        def dfs(pathes, node):\n            if node.is_end:\n                ans.append('/' + '/'.join(pathes))\n                return \n            for p in node.children:\n                dfs(pathes + [p], node.children[p])\n        dfs([], self.root)\n        return ans\n            \n            \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = Trie()\n        for f in folder:\n            trie.insert(f.split('/')[1:])\n        return trie.find()\n            \n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort()\n        res = []\n        pfix = set()\n        removed = set()\n        \n        for f in folder:\n            valid = f.split('/')\n            for i in range(0, len(valid)):\n                target = '/'.join(valid[0: i + 1])\n                if target in pfix:\n                    removed.add(f)\n            pfix.add(f)\n        \n        return set(folder) - set(removed)\n", "class Directory:\n    \n    def __init__(self, name=\\\"\\\"):\n        self.name = name\n        self.subDirectories = {}\n        self.flg=False\n\nclass Solution:\n    \n    def __init__(self):\n        self.root = Directory()\n        \n    def generate(self, directory):\n        if directory.flg:\n            return [[directory.name]]\n        res = []\n        for k in directory.subDirectories.keys():\n            res += self.generate(directory.subDirectories[k])\n        for r in res:\n            r.append(directory.name)\n        return res\n        \n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        for f in folder:\n            directories = re.split('/', f)[1:]\n            cur = self.root\n            for i, d in enumerate(directories):\n                if cur.flg:\n                    break\n                if d not in cur.subDirectories.keys():\n                    cur.subDirectories[d] = Directory(d)\n                cur = cur.subDirectories[d]\n                if i == len(directories) - 1:\n                    cur.flg = True\n        \n        ans = self.generate(self.root)\n        return ['/'.join(a[::-1]) for a in ans]\n        ", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        curr_node = self.root\n        \n        for ch in word:\n            if ch not in curr_node.children:\n                curr_node.children[ch] = TrieNode()\n            curr_node = curr_node.children[ch]\n        curr_node.isEnd = True\n    \n    def find(self):\n        def dfs(node, file, result):\n            if node.isEnd:\n                result.append(\\\"/\\\" + \\\"/\\\".join(file))\n                return\n            \n            for ch in node.children:\n                dfs(node.children[ch], file + [ch], result)\n        result = []\n        dfs(self.root, [], result)\n        return result\n    \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = Trie()\n        \n        for file in folder:\n            file = file.split(\\\"/\\\")[1:]\n            trie.insert(file)\n        return trie.find()\n        ", "# Time & space: O(n * m), where n = folder.length, m = average size of the strings in folder.\nclass TrieNode:\n    def __init__(self):\n        self.children = dict() \n        self.path = None \n        \nclass Solution:\n    def __init__(self):\n        self.root = TrieNode() \n        \n    def removeSubfolders(self, folder: List[str]) -> List[str]:        \n        for directory in folder:\n            curr = self.root\n            for f in directory.split('/')[1:]:\n                if f not in curr.children:\n                    curr.children[f] = TrieNode()\n                curr = curr.children[f]    \n            curr.path = directory    \n        \n        def trie_search(node, res): #dfs\n            if node.path:\n                res.append(node.path)\n                return res\n            for nbr in node.children:  \n                res = trie_search(node.children[nbr], res)\n            return res    \n        \n        return trie_search(self.root, [])\n\n# # Sort the folders;\n# # For each folder check if the followings are child folders; if yes, ignore; otherwise, count it in.\n# # Time: O(n * m * log(n)), space: O(1)(excluding space cost of sorting part), where n = folder.length, m = average size of the strings in folder.\n# class Solution:\n#     def removeSubfolders(self, folder: List[str]) -> List[str]:\n#             ans = []\n#             for f in sorted(folder):\n#                 if not ans or not f.startswith(ans[-1] + '/'):\\t#  need '/' to ensure a parent.\n#                     ans.append(f)\n#             return ans\n", "import collections\nclass Trienode:\n    def __init__(self):\n        self.child = collections.defaultdict(Trienode)\n        self.isword = False\nclass trie:\n    def __init__(self):\n        self.res = Trienode()\n    def insert(self,word):\n        cur = self.res\n        for i in word:\n            cur = cur.child[i]\n        cur.isword =True\n    def find(self):\n        self.stack =[]\n        def dfs(node,tmp):\n            for item in node.child.keys():\n                if node.child[item].isword:\n                    self.stack.extend([tmp+\\\"/\\\"+item])\n                else:\n                    dfs(node.child[item],tmp+\\\"/\\\"+item)\n        dfs(self.res,\\\"\\\")\n        return self.stack \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        newres = trie()\n        for item in folder:\n            item = item.split(\\\"/\\\")[1:]\n            newres.insert(item)\n        \n        return [item for item in newres.find()]", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        t = Trie()\n        \n        for i in folder:\n            t.insert(i.split(\\\"/\\\")[1:])\n            \n        return t.getFolders()\n        \nclass TrieNode:\n    def __init__(self, val=None):\n        self.val = val\n        self.children = {}\n        self.isEnd = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, s):\n        curr = self.root\n        for c in s:\n            if c not in curr.children:\n                curr.children[c] = TrieNode(c)\n            curr = curr.children[c]\n        curr.isEnd = True\n\n    def getFolders(self):\n        result = []\n        \n        def helper(node, path):\n            if node.isEnd:\n                result.append(path[:-1])\n            else:\n                for i in node.children:\n                    helper(node.children[i],path + node.children[i].val + \\\"/\\\")\n\n        helper(self.root, \\\"/\\\")\n        \n        return result", "class Node:\n    def __init__(self):\n        self.child = collections.defaultdict(Node)\n        self.is_last = False\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n    def insert(self, word):\n        node = self.root\n        for c in word:\n            node = node.child[c]\n        node.is_last = True\n    def find(self):\n        ret = []\n        \n        def dfs(node, tmp):\n            if node.is_last:\n                ret.append(\\\"/\\\".join(tmp))\n                return\n            for char, nxt_node in node.child.items():\n                dfs(nxt_node, tmp+[char])\n        dfs(self.root, [])\n        return ret\n        \n    \n    \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort()\n        t = Trie()\n        for f in folder:\n            t.insert(f.split(\\\"/\\\"))\n        return t.find()", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        x = sorted(folder)\n        res = [x[0]]\n        for i in range(1, len(x)):\n            if x[i].startswith(res[-1]) and (x[i][len(res[-1])] == '/'):\n                continue\n            res.append(x[i])\n        return res\n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        n = len(folder)\n        folder = sorted(folder)\n        first = folder[0]\n        ans = set()\n        # print((first.split('/')))\n        ans.add(folder[0])\n        for i in range(1,n):\n            flag = True\n            second = folder[i]\n            # print(first,second)\n            first1 = first.split('/')\n            second1 = second.split('/')\n            for j in range(len(first1)):\n                if first1[j] != second1[j]:\n                    ans.add(second)\n                    first = second\n                    flag = False\n                    break\n            \n            # if flag:\n            #     ans.add(first)\n            \n#         if not flag:\n#             ans.add(folder[n-1])\n        \n        return list(ans)\n                \n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort(key=len)\n        res = []\n        seen = set()\n        for path in folder:\n            tmp = []\n            for d in path.split('/')[1:]:\n                tmp.append(d)\n                if '/'.join(tmp) in seen: break\n            else:\n                seen.add('/'.join(tmp))\n                res.append(path)\n        return res", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = {}\n        tokens = {path: path.split('/') for path in folder}\n        for path in folder:\n            curr = trie\n            for token in tokens[path]:\n                if token not in curr:\n                    curr[token] = {}\n                curr = curr[token]\n            curr['#'] = True\n \n        paths = set(folder)\n        for path in folder:\n            curr = trie\n            for token in tokens[path]:\n                if '#' in curr:\n                    paths.remove(path)\n                    break\n                curr = curr[token]    \n        return list(paths) \n                \n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        if len(folder) == 1:\n            return folder\n        \n        trie = {}\n        for p in folder:\n            node = trie\n            p = p.split('/')\n            for e in p:\n                node = node.setdefault(e, {}) \n            node[\\\"#\\\"] = \\\"#\\\" #end\n        \n        restults = []\n        self.dfs(trie, [], restults )\n        return restults\n            \n        \n    def dfs(self, trie, res, results):\n        \n        if '#' in trie:\n            results.append('/'.join(res)) \n            return\n               \n        for e in trie:\n            self.dfs(trie[e], res + [e], results)\n            \n            \n        \n        \n            \n            \n            \n        \n        \n            \n            \n        ", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        s = sorted(folder)\n        fs = []\n        while s:\n            fs.append(s[0])\n            s.pop(0)\n            while s and self.is_subfolder(fs[-1], s[0]):\n                s.pop(0)\n        return fs\n    def is_subfolder(self, x,y):\n        x = x.split('/')\n        y = y.split('/')\n        if len(x) >= len(y):\n            return False\n        for i, c in enumerate(x):\n            if c != y[i]:\n                return False\n        return True", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        if len(folder) == 1:\n            return folder\n        \n        trie = {}\n        \n        for p in folder:\n            node = trie\n            p = p.split('/')\n            for e in p:\n                node = node.setdefault(e, {}) \n            node[\\\"#\\\"] = \\\"#\\\" #end\n        \n        restults = []\n        self.dfs(trie, [], restults )\n        return restults\n            \n        \n    def dfs(self, trie, res, results):\n        \n        if '#' in trie:\n            results.append('/'.join(res)) \n            return\n            \n            \n        for e in trie:\n            res.append(e) \n            self.dfs(trie[e], res, results)\n            res.pop()\n            \n        \n        \n            \n            \n            \n        \n        \n            \n            \n        ", "import collections\nclass TrieNode:\n    def __init__(self):\n        self.child = collections.defaultdict(TrieNode)\n        self.isword = False\n        \nclass trie:\n    def __init__(self):\n        self.res = TrieNode()\n    def insert(self,word):\n        cur = self.res\n        for i in word:\n            #rint(i)\n            cur = cur.child[i]\n        cur.isword=True\n        \n    def find(self):\n        def dfs(node,stack,tmp):\n            print(node.child.keys())\n            if node.isword:\n                stack.append(tmp)\n                return \n            for item in node.child.keys():\n                print(item)\n                dfs(node.child[item],stack,tmp+\\\"/\\\"+item)\n        stack =[]\n        cur = self.res\n        dfs(cur,stack,\\\"\\\")\n        return stack\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        res=trie()\n        for item in folder:\n            #print(item.split(\\\"/\\\")[1:])\n            res.insert(item.split(\\\"/\\\")[1:])\n        return res.find()", "# class Solution:\n#    def removeSubfolders(self, folder: List[str]) -> List[str]:\n#         # Brute Force => TLE\n#         # Time: O(n^2)\n#         # Space: O(1)\n#         def isSublist(shorter_path: List[str], longer_path: List[str]) -> bool:\n#             if len(shorter_path) > len(longer_path):\n#                 return False\n#             for i in range(len(shorter_path)):\n#                 if shorter_path[i] != longer_path[i]:\n#                     return False\n#             return True\n#         res = []\n#         n = len(folder)\n#         for i in range(n):\n#             is_subfolder = False\n#             longer_path = folder[i].split('/')\n#             for j in range(n):\n#                 if j != i:\n#                     shorter_path = folder[j].split('/')\n#                     if isSublist(shorter_path, longer_path):\n#                         is_subfolder = True\n#                         break\n#             if not is_subfolder:\n#                 res.append(folder[i])\n#         return res\n#         # Sort alphabetically + Stack\n#         # Time: O(nlogn)\n#         # Space: O(1)\n#         folder.sort()\n#         stack = [folder[0]]\n#         n = len(folder)\n#         i = 1\n#         while i < n:\n#             shorter_path = stack[-1].split('/')\n#             longer_path = folder[i].split('/')\n#             if not isSublist(shorter_path, longer_path):\n#                 stack.append(folder[i])\n#             i += 1\n#         return stack\n\n# Trie\n# Time: O(n)\n# Space: O(n)\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.isLeaf = False\n        \nclass Trie:\n    def __init__(self):\n        self.root = Node()\n        \n    def insert(self, path: List[str]) -> None:\n        node = self.root\n        for directory in path:\n            if directory not in node.children:\n                node.children[directory] = Node()\n            node = node.children[directory]\n        node.isLeaf = True\n        \n    def search(self, path: List[str]) -> bool:\n        node = self.root\n        for directory in path:\n            if directory not in node.children:\n                return False\n            node = node.children[directory]\n        return node.isLeaf\n    \n    def startWith(self, path: List[str]) -> bool:\n        node = self.root\n        for directory in path:\n            if directory not in node.children:\n                return False\n            node = node.children[directory]\n        return True\n    \n    def isSubfolder(self, path: List[str]) -> bool:\n        node = self.root\n        for directory in path:\n            if node.isLeaf:\n                return True\n            node = node.children[directory]\n        return False\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = Trie()\n        for path in folder:\n            directories = path.split('/')\n            trie.insert(directories)\n\n        res = []\n        for path in folder:\n            directories = path.split('/')\n            if not trie.isSubfolder(directories):\n                res.append(path)\n        return res\n\n\n\n\n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        result = []\n        for f in sorted(folder):\n            if not result or not f.startswith(result[-1] + '/'):\n                result.append(f)\n        return result\n                \n            \n            \n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort()\n        result = []\n        splitted = list(map(lambda path: path.split('/')[1:], folder))\n        numPath = len(folder)\n        i = 0\n        while i < numPath:\n            result.append(folder[i])\n            current = splitted[i]\n            while i < numPath:\n                remove = True\n                for k in range(min(len(splitted[i]), len(current))):\n                    if splitted[i][k] != current[k]:\n                        remove = False\n                        break\n                if remove:\n                    i += 1\n                else:\n                    break\n        return result", "class TrieNode:\n    def __init__(self, name):\n        self.children = {}\n        self.isEnd = False\n        self.name = name\n        \n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode(\\\"\\\")\n        \n    def insert(self, word):\n        it = self.root\n        for w in word:\n            if w not in it.children:\n                it.children[w] = TrieNode(w)\n                \n            it = it.children[w]\n        it.isEnd = True\n    \n    def normalize(self):\n        self._normalize(self.root)\n    \n    def _normalize(self, node):\n        if not node:\n            return\n        \n        for char, childNode in node.children.items():\n        \n            hasSubFolders, child = self._normalize(childNode)\n            if hasSubFolders and node.isEnd:\n                node.children[child] = None\n\n        return (node.isEnd, node.name)\n        \n    def getWords(self):\n        lastWord = []\n        result = []\n        self._getWords(self.root, lastWord, result)\n        return result\n        \n    def _getWords(self, node, lastWord, result):\n        if not node:\n            return\n        \n        if node.isEnd:\n            result.append(\\\"/\\\".join(lastWord + [node.name]))\n            return\n        lastWord.append(node.name)\n        for char, nodeChild in node.children.items():\n            self._getWords(nodeChild, lastWord, result)\n        lastWord.pop()\n        \n\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = Trie()\n        for folder in folder:\n            trie.insert(folder.split(\\\"/\\\")[1:])\n            \n        trie.normalize()\n        \n        return trie.getWords()\n        ", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        \n        trie = {}\n        for f in folder:\n            fo = f.split('/')\n            curr = trie\n            for letter in fo:\n                if letter not in curr:\n                    curr[letter] = {}\n                curr = curr[letter]\n            curr['#'] = f\n        \n        def dfs(curr):\n            if '#' in curr:\n                res.append(curr['#'])\n                return\n            for key in curr:\n                dfs(curr[key])\n        \n        res = []\n        dfs(trie)\n        return res", "class Node:\n    def __init__(self, name):\n        self.name = name\n        self.subdir = {}\n        self.terminal = False\n        \n    def link(self, name, node):\n        self.subdir[name] = node\n\nclass Solution:\n    def dfs(self, node, dirstr, found):\n        #print(dirstr, found)\n        rtn = []\n        if node.terminal and not found:\n            rtn = [dirstr]\n        for x in node.subdir.keys():\n            rtn = rtn + self.dfs(node.subdir[x], dirstr+'/'+x, (found|node.terminal))\n        return rtn\n    \n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        root = Node('')\n        for d in folder:\n            seq = d.split('/')[1:]\n            p = root\n            for f in seq:\n                if f not in p.subdir:\n                    q = Node(f)\n                    p.subdir[f] = q\n                p = p.subdir[f]\n            p.terminal = True\n        return self.dfs(root, '', False)", "class TrieNode:\n    def __init__(self):\n        self.children = collections.defaultdict(TrieNode)\n        self.is_word = ''\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    def insert(self, word):\n        curr = self.root\n        for ch in word:\n            curr = curr.children[ch]\n        curr.is_word = '/' + '/'.join(word)\n    \n    # def (self, node):\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = Trie()\n        for path in folder:\n            trie.insert(path.split('/')[1:])\n        \n        res = []\n        \n        def bfs(node):\n            if node.is_word:\n                res.append(node.is_word)\n                return\n            for child in list(node.children.values()):\n                bfs(child)\n        bfs(trie.root)\n        return res\n                \n            \n", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        dit = set()\n        arr = []\n        folder.sort()\n        for i in range(0, len(folder)):\n            p = \\\"\\\"\n            for a in range(0, len(folder[i])):\n                p += folder[i][a]\n                if a+1 < len(folder[i]):\n                    if folder[i][a+1] == '/':\n                        if p in dit:\n                            break\n                    elif folder[i][a+1] == None:\n                        if p not in dit:\n                            dit.add(p)\n                            arr.append(p)\n                else:\n                    if p not in dit:\n                        dit.add(p)\n                        arr.append(p)\n        return arr", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        def check(f):\n            return all(map(lambda x: len(x) > 0, f.split('/')[1:]))\n        def parent(f):\n            parents = set()\n            tmp = f.split('/')\n            for i in range(1, len(tmp)-1):\n                parents.add('/'.join(tmp[:i+1]))\n            return parents\n        folder.sort()\n        seen = set()\n        res = []\n        for f in folder:\n            if check(f):\n                flag = False\n                ps = parent(f)\n                # print(f, ps)\n                for p in ps:\n                    if p in seen:\n                        flag = True\n                        break\n                if not flag:\n                    res.append(f)\n                seen.add(f)\n        return res", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        \n        folder.sort(key = lambda x: len(x))\n        res = []\n        # while folder:\n        #     e = folder.pop()\n        #     for p in folder:\n        #         if e.startswith(p) and e[len(p)] == '/':\n        #                 e = ''   \n        #                 break\n        #     if e: res.append(e)\n        # return res\n    \n        # trie = {}\n        # for t in folder:\n        #     m = trie\n        #     parent = False\n        #     for c in t.split('/'):\n        #         m[c] = m.get(c, {})\n        #         m = m[c]\n        #         if '$' in m: \n        #             parent = True\n        #             break\n        #     if not parent:\n        #         m[\\\"$\\\"] = '$'\n        #         res.append(t)\n        # return res\n         \n#             use stack and sort with lexinton\n        files = sorted(folder)\n        stack  = [files[0]]\n        for i in range(1, len(files)):\n            if not files[i].startswith(stack[-1] + '/'):  stack.append(files[i])\n        return stack\n", "class TrieTree:\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n        self.endWord = None\n    \nclass Solution:\n    ##\u8fd9\u4e2a\u6587\u4ef6\u5939\u53ef\u80fd\u4e0d\u662f\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\u7684\uff01\uff01\n    def __init__(self):\n        self.root = TrieTree()\n        \n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        for word in folder:\n            wordList = word.split(\\\"/\\\")\n            curr = self.root\n            for letter in wordList:\n                if letter not in curr.children:\n                    curr.children[letter] = TrieTree()\n                curr = curr.children[letter]\n            curr.isEnd = True\n            curr.endWord = word\n            \n        def dfs(root, path, result):\n            if not root:\n                return \n            \n            if root.isEnd:\n                result.append(root.endWord)\n                return\n            \n            for i in root.children.keys():\n                dfs(root.children[i], path + i, result)\n            \n        \n        \n        result = []\n        dfs(self.root, \\\"\\\", result)\n        return result\n    \n    ", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort(key = lambda x: len(x))\n\n        hashmap = set()\n\n        for f in folder:\n            seen = False\n            for i in range(2, len(f)):\n                if f[i] == \\\"/\\\" and f[:i] in hashmap:\n                    seen = True\n                    break\n            \n            if not seen: hashmap.add(f)\n\n        return hashmap\n        ", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        root = {}\n        for f in folder:\n            f = f.split(\\\"/\\\")[1:]\n            self.insert(root, f)\n        return self.dfs([], root, [])\n        \n    def insert(self, root, f):\n        for e in f:\n            if e not in root:\n                root[e] = {}\n            root = root[e]\n        root['#'] = '#'\n    \n    def dfs(self, tmp, root, fn):\n        if '#' in root:\n            fn.append('/' + '/'.join(tmp))\n            return fn\n        for k in root:\n            #if k != '#':\n            self.dfs(tmp+[k], root[k], fn)\n        return fn\n            \n        ", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = {}\n        for f in folder:\n            p = trie\n            \n            for c in f:\n                if c not in p:\n                    p[c] = {}\n                p = p[c]\n            if '/' not in p:\n                p['/'] = {}\n            p = p['/']\n            p['$'] = f\n        \n        #print(trie)\n        ans = []\n        for f in folder:\n            p = trie\n            full = f+'/'\n            for c in full:\n                if '$' in p:\n                    break\n                p = p[c]\n            else:\n                ans.append(f)\n        return ans", "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n        \n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.isEnd = True  \n    \n    def find(self):\n        def dfs(direc, node):\n            if node.isEnd:\n                answer.append('/' + '/'.join(direc))\n                return\n            for char in node.children:\n                dfs(direc + [char], node.children[char])\n        \n        answer = []\n        dfs([], self.root)\n        return answer\n\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = Trie()\n        for f in folder:\n            f = f.split('/')[1:]\n            #print(f)\n            trie.insert(f)\n        return trie.find()\n", "class Node:\n    def __init__(self, name):\n        self.name = name\n        self.next = dict()\n        self.flag = False\n        \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        head = dict()\n        for f in folder:\n            sub = f.split(\\\"/\\\")\n\n            for i in range(1,len(sub)):\n                if i == 1:\n                    if sub[i] not in head:\n                        head[sub[i]] = Node(sub[i])\n                    node =  head[sub[i]]\n                    if i == len(sub)-1:\n                        node.flag = True\n                elif i == len(sub) -1:\n                    if sub[i] not in node.next:\n                        node.next[sub[i]] = Node(sub[i])\n                    node.next[sub[i]].flag = True\n                else:\n                    if sub[i] not in node.next:\n                        node.next[sub[i]] = Node(sub[i])\n                    node = node.next[sub[i]]\n                    \n            \n        ret = list()\n        # print(head)\n        for k in head:\n            # dfs\n            stack = [(head[k], list())]\n            while stack:\n                node, chain = stack.pop()\n                chain.append(node.name)\n                if node.flag:\n                    ret.append(\\\"/\\\"+\\\"/\\\".join(chain))\n                else:\n                    for k, next_node in node.next.items():\n                        stack.append((next_node, list(chain)))\n                        \n            \n            \n            \n            \n            \n        return ret\n            \n                    \n                \n                \n                \n                \n        ", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        trie = {}\n        for f in folder:\n            p = trie\n            full = f+'/'\n            for c in full:\n                if c not in p:\n                    p[c] = {}\n                p = p[c]\n            p['$'] = full\n        \n        #print(trie)\n        ans = []\n        for f in folder:\n            p = trie\n            full = f+'/'\n            for c in full:\n                if '$' in p:\n                    break\n                p = p[c]\n            else:\n                ans.append(f)\n        return ans", "class Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        dic = set(folder)\n        for x in folder:\n            for i in range(len(x)):\n                if i != 0 and x[i] == '/':\n                    if x[:i] in dic:\n                        dic.remove(x)\n                        break \n        return list(dic)", "class Node:\n    def __init__(self, name):\n        self.name = name\n        self.next = dict()\n        self.flag = False\n        \nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        head = dict()\n        for f in folder:\n            sub = f.split(\\\"/\\\")\n            \n            for i in range(1,len(sub)):\n                # first node\n                if i == 1:\n                    node = head.setdefault(sub[i],  Node(sub[i]))\n\n                    if i == len(sub)-1:\n                        node.flag = True\n                elif i == len(sub) -1:\n                    if sub[i] not in node.next:\n                        node.next[sub[i]] = Node(sub[i])\n                    node.next[sub[i]].flag = True\n                else:\n                    if sub[i] not in node.next:\n                        node.next[sub[i]] = Node(sub[i])\n                    node = node.next[sub[i]]\n                    \n        ret = list()\n        for k in head:\n            # dfs\n            stack = [(head[k], list())]\n            while stack:\n                node, chain = stack.pop()\n                chain.append(node.name)\n                if node.flag:\n                    ret.append(\\\"/\\\"+\\\"/\\\".join(chain))\n                else:\n                    for k, next_node in node.next.items():\n                        stack.append((next_node, list(chain)))\n\n        return ret\n            \n                    \n                \n                \n                \n                \n        "]
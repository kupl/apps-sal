["class Solution:\n     def maximumSwap(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         s = str(num)\n         nums = [int(_) for _ in s]\n         dp = [-1]*len(nums)\n         for i in range(len(nums)-1,-1,-1):\n             if i==len(nums)-1:\n                 dp[i] = i\n             else:\n                 dp[i] = i if nums[i]>nums[dp[i+1]] else dp[i+1]\n         \n         for i in range(len(nums)):\n             if nums[i] != nums[dp[i]]:\n                 nums[i],nums[dp[i]] = nums[dp[i]],nums[i]\n                 break\n         res = 0\n         for num in nums:\n             res = res*10 + num\n         return res\n                 \n             \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n         \n", "class Solution:\n     def maximumSwap(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         digits = \"\"\n         while(int(num)):\n             digits += str(int(num%10))\n             num/=10\n             \n         #print(digits)\n         digits = digits[::-1]\n         lens = len(digits)\n         mark = 0\n         mark1 = 0\n         flag = 0\n         for i in range(lens):\n             maxs = ord(digits[i])\n             for j in range(i+1, lens,1):\n                 if ord(digits[j]) >= maxs:\n                     maxs = ord(digits[j])\n                     mark = j\n             if maxs != ord(digits[i]):\n                 mark1 = i\n                 flag = 1\n                 break;\n         #print(digits)\n         digit = list(digits)\n         #print(digit)\n         if flag == 1:\n             tem = digit[mark1]\n             digit[mark1] = digit[mark]\n             digit[mark] = tem\n         #print(digit)\n         #digits = digits[::-1]\n         res = 0\n         #print(digit)\n         for i in range(lens):\n             res *= 10\n             res += ord(digit[i]) - ord('0')\n             #print(res)\n         return res", "class Solution:\n     def maximumSwap(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         s = str(num)\n         self.res = s\n \n         def swap(i, j):\n             a, b = self.res[i], self.res[j]\n             self.res = self.res[:i] + b + self.res[i + 1:]\n             self.res = self.res[:j] + a + self.res[j + 1:]\n \n         d = {}\n \n         for i, c in enumerate(s):\n             if c in d:\n                 d[c].append(i)\n             else:\n                 d[c] = [i]\n \n         c = 0\n         for i in range(10)[::-1]:\n             i = str(i)\n             if i in d:\n                 arr = d[i]\n                 done = False\n \n                 for e in arr:\n                     if e != c:\n                         swap(c, arr[-1])\n                         done = True\n                         break\n                     c += 1\n \n                 if done:\n                     break\n \n         return int(self.res)", "class Solution:\n     def maximumSwap(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         import itertools\n         \n         # Convert num into a list of chars\n         A = [c for c in str(num)]\n         \n         # Compute suffix max for A\n         suff_max = list(itertools.accumulate(A[::-1], max))[::-1]\n         \n         # Compute char -> largest index in A\n         last = {x : i for i, x in enumerate(A)}\n         \n         # Find the first mismatch in A and suff_max\n         try:\n             i, x, y = next((i, x, y) for i, (x, y) in enumerate(zip(A, suff_max)) if x != y)\n         except StopIteration:\n             return num\n         \n         # Swap the A[i] with the farthest appearance of y in A\n         A[i], A[last[y]] = A[last[y]], A[i]\n         \n         return int(''.join(A))", "class Solution:\n     def maximumSwap(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         import itertools\n         \n         # Convert num into a list of chars\n         A = [c for c in str(num)]\n         \n         # Compute suffix max for A\n         suff_max = list(itertools.accumulate(A[::-1], max))[::-1]\n         \n         # Compute char -> largest index in A\n         last = {x : i for i, x in enumerate(A)}\n \n         # Swap the first occurrence of A[i] < suff_max[i]\n         for i, x in enumerate(A):\n             if x < suff_max[i]:\n                 A[i], A[last[suff_max[i]]] = A[last[suff_max[i]]], A[i]\n                 break\n \n         return int(''.join(A))", "class Solution:\n     def maximumSwap(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         A = list(str(num))\n         ans = A[:]\n         for i in range(len(A)):\n             for j in range(i+1, len(A)):\n                 A[i], A[j] = A[j], A[i]\n                 if A > ans: ans = A[:]\n                 A[i], A[j] = A[j], A[i]\n \n         return int(\"\".join(ans))\n", "class Solution:\n     def maximumSwap(self, num):\n         arr = str(num)\n         n = len(arr)\n         posmax = [0] * n\n         posmax[-1] = n-1\n         pow10 = [0] * n\n         pow10[-1] = 1        \n         for i in range(n-2, -1, -1):\n             if arr[i] > arr[posmax[i+1]]:\n                 posmax[i] = i\n             else:\n                 posmax[i] = posmax[i+1]\n             pow10[i] = pow10[i+1] * 10\n         for i in range(n):\n             if arr[i] == '9':\n                 continue\n             j = posmax[i]\n             if arr[j] > arr[i]:\n                 x = int(arr[i])\n                 y = int(arr[j])\n                 return num + pow10[i]*(-x + y) + pow10[j]*(-y + x)\n         return num\n     \n", "class Solution:\n     def maximumSwap(self, num):\n         arr = [int(c) for c in str(num)]\n         n = len(arr)\n         posmax = [0] * n\n         posmax[-1] = n-1\n         for i in range(n-2, -1, -1):\n             if arr[i] > arr[posmax[i+1]]:\n                 posmax[i] = i\n             else:\n                 posmax[i] = posmax[i+1]\n         for i in range(n):\n             if arr[i] == 9:\n                 continue\n             j = posmax[i]\n             if arr[j] > arr[i]:\n                 arr[i], arr[j] = arr[j], arr[i]\n                 return int(''.join(map(str, arr)))\n         return num\n     \n", "class Solution:\n     def maximumSwap(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         array = list(map(lambda x: int(x), str(num)))\n         stack = []\n         l = float('inf')\n         r = None\n         for i, d in enumerate(array):\n             while stack and array[stack[-1]] < d:\n                 l = min(l, stack.pop())\n             stack.append(i)\n             if l < float('inf'):\n                 if not r or array[r] <= d:\n                     r = i\n         if l == float('inf'):\n             return num\n         else:\n             basel = 10 ** (len(array) - 1 - l)\n             baser = 10 ** (len(array) - 1 - r)\n             return num + basel*(array[r]-array[l]) + baser*(array[l]-array[r])", "class Solution:\n     def swap(self, i, c):\n         for ii in range(len(self.res))[::-1]:\n             if self.res[ii] == c:\n                 a, b = self.res[i], self.res[ii]\n                 self.res = self.res[:i] + b + self.res[i + 1:]\n                 self.res = self.res[:ii] + a + self.res[ii + 1:]\n                 break\n                     \n     def maximumSwap(self, num):\n         \"\"\"\n         :type num: int\n         :rtype: int\n         \"\"\"\n         s = str(num)\n         l = sorted(list(s), reverse=True)\n         self.res = s\n \n         for i, char in enumerate(s):\n             if char != l[i]:\n                 self.swap(i, l[i])\n                 break\n \n         return int(self.res)"]
["#!/usr/bin/env python\n\nfrom math import sqrt\n\ndef process(S):\n P = [0,0,'S']\n for i in S:\n  if i == 'L':\n   if P[-1] == 'N': P[-1] = 'W'\n   elif P[-1] == 'S': P[-1] = 'E'\n   elif P[-1] == 'E': P[-1] = 'N'\n   elif P[-1] == 'W': P[-1] = 'S'\n  elif i == 'R':\n   if P[-1] == 'N': P[-1] = 'E'\n   elif P[-1] == 'S': P[-1] = 'W'\n   elif P[-1] == 'E': P[-1] = 'S'\n   elif P[-1] == 'W': P[-1] = 'N'\n  else:\n   i = int(i)\n   if P[-1] == 'N': P[1] -= i\n   elif P[-1] == 'S': P[1] += i\n   elif P[-1] == 'E': P[0] += i\n   elif P[-1] == 'W': P[0] -= i\n  #print i, P\n DIST = sqrt(P[0]**2+P[1]**2)\n\n if P[0] == 0 and P[1] == 0: DIR = ''\n elif P[0] == 0 and P[1] < 0: DIR = 'S'\n elif P[0] == 0 and P[1] > 0: DIR = 'N'\n elif P[0] < 0 and P[1] == 0: DIR = 'E'\n elif P[0] < 0 and P[1] < 0: DIR = 'SE'\n elif P[0] < 0 and P[1] > 0: DIR = 'NE'\n elif P[0] > 0 and P[1] == 0: DIR = 'W'\n elif P[0] > 0 and P[1] < 0: DIR = 'SW'\n elif P[0] > 0 and P[1] > 0: DIR = 'NW'\n\n DIST = int(DIST*10.)/10. # TOLD NO APPROXIMATION\n\n return '%.1f%s' % (DIST, DIR)\n\ndef main():\n T = int(input())\n for t in range(T):\n  S = input().split()\n  print(process(S))\n\nmain()\n\n", "import sys,math\n\nt = int(sys.stdin.readline())\nds = [(0,1),(1,0),(0,-1),(-1,0)]\nfor _ in range(t):\n x, y, d = 0, 0, 0\n path = sys.stdin.readline().split()\n for ins in path:\n  if ins == 'L':\n   d = (d-1)&3\n  elif ins == 'R':\n   d = (d+1)&3\n  else:\n   x,y = x+ds[d][0]*int(ins), y+ds[d][1]*int(ins)\n dist = math.sqrt(float(x**2 + y**2))\n if y > 0:\n  if x > 0:\n   dir = 'NE'\n  elif x < 0:\n   dir = 'NW'\n  else:\n   dir = 'N'\n elif y < 0:\n  if x > 0:\n   dir = 'SE'\n  elif x < 0:\n   dir = 'SW'\n  else:\n   dir = 'S'\n else:\n  if x > 0:\n   dir = 'E'\n  elif x < 0:\n   dir = 'W'\n  else:\n   dir = ''\n print('%.1f%s' % (math.floor(dist*10)/10.0,dir))\n", "#Program question at: http://www.codechef.com/COZL2012/problems/RBX12R01\nimport math,sys\ndir_ = 'UDLR'\nleft = 'LRDU'\nright = 'RLUD'\n\nt = int(input())\nwhile t>0:\n t -= 1\n x=0; y=0;\n dr = ''; cur='U';\n s = input().split()\n l = len(s)\n for i in range(l):\n  if i % 2 == 1:\n   dr = s[i]\n   if dr == 'L': cur = left[dir_.find(cur)]\n   else: cur = right[dir_.find(cur)]\n  else:\n   steps = int(s[i])\n   if cur == 'U': y += steps\n   elif cur == 'D': y -= steps\n   elif cur == 'L': x -= steps\n   elif cur == 'R': x += steps\n\n dist = str(math.sqrt(x*x + y*y))\n i = dist.find('.')\n sys.stdout.write(dist[0:i+2])\n if x==0:\n  sys.stdout.write( ('N' if y>0 else 'S') + '\\n')\n elif y==0:\n  sys.stdout.write( ('E' if x>0 else 'W') + '\\n')\n elif x>0:\n  sys.stdout.write( ('NE' if y>0 else 'SE') + '\\n')\n elif x<0:\n   sys.stdout.write( ('NW' if y>0 else 'SW') + '\\n')\n\n", "#Program question at: http://www.codechef.com/COZL2012/problems/RBX12R01\nimport math,sys\ndir_ = 'UDLR'\nleft = 'LRDU'\nright = 'RLUD'\n\nt = int(input())\nwhile t>0:\n t -= 1\n x=0; y=0;\n dr = ''; cur='U';\n s = input().split()\n l = len(s)\n for i in range(l):\n  if i % 2 == 1:\n   dr = s[i]\n   if dr == 'L': cur = left[dir_.find(cur)]\n   else: cur = right[dir_.find(cur)]\n  else:\n   steps = int(s[i])\n   if cur == 'U': y += steps\n   elif cur == 'D': y -= steps\n   elif cur == 'L': x -= steps\n   elif cur == 'R': x += steps\n\n dist = str(math.sqrt(x*x + y*y))\n i = dist.find('.')\n sys.stdout.write(dist[0:i+2])\n if x==0:\n  sys.stdout.write( ('N' if y>0 else 'S') + '\\n')\n elif y==0:\n  sys.stdout.write( ('E' if x>0 else 'W') + '\\n')\n elif x>0:\n  sys.stdout.write( ('NE' if y>0 else 'SE') + '\\n')\n elif x<0:\n   sys.stdout.write( ('NW' if y>0 else 'SW') + '\\n')\n\n", "\ndef my_sqrt(v):\n v*=100\n lo=0\n hi=v\n while lo+1<hi:\n  mi = (lo + hi) >> 1\n  if mi*mi<=v:\n   lo=mi\n  else:\n   hi=mi\n return lo\n\ndef solve():\n dir=0\n dx=[0,-1,0,1]\n dy=[1,0,-1,0]\n x,y=0,0\n line=input()\n ss=line.split()\n n=len(ss)\n i=0\n while(i<n):\n  if(ss[i]=='L'):\n   dir=(dir+1)%4\n  elif ss[i]=='R':\n   dir=(dir+3)%4\n  else:\n   x+=dx[dir]*int(ss[i])\n   y+=dy[dir]*int(ss[i])\n  i=i+1\n if x==0 and y==0:\n  print('0.0')\n  return\n v = my_sqrt(x*x+y*y)\n ds=''\n if(y>0):\n  ds+='N'\n elif y<0:\n  ds+='S'\n if(x>0):\n  ds+='E'\n elif x<0:\n  ds+='W'\n print('%d.%d%s' % (v/10, v%10,ds))\n\nT=int(input())\nwhile(T>0):\n T=T-1\n solve()", "#input must be invalid because no runtime error after handling invalid input\n\ndef parse(movestr):\n moves = []\n acc = \"\"\n for char in movestr:\n  char = char.upper()\n  if char == \"R\" or char == \"L\":\n   if acc != \"\":\n    moves.append(int(acc))\n   acc = \"\"\n   moves.append(char)\n  elif char.isdigit():\n   acc += char\n  elif len(acc) > 0:\n   moves.append(int(acc))\n   acc = \"\"\n   \n if len(acc) > 0:\n  moves.append(int(acc))\n return moves\n\n\ndef make_move(x,y,direc,dist):\n if direc == 0:\n  #north\n  y += dist\n elif direc == 1:\n  #west\n  x -= dist\n elif direc == 2:\n  #south\n  y -= dist\n elif direc == 3:\n  #east\n  x += dist\n return x,y\n\n\ndef calc(moves):\n x,y = 0,0\n direc = 0\n for move in moves:\n  if move == \"L\":\n   direc = (direc+1)%4\n  elif move == \"R\":\n   direc = (direc-1)%4\n  else:\n   x,y = make_move(x,y,direc,move)\n return x,y\n\n\ndef string(dist):\n d = str(dist)\n k = d.find(\".\")\n return d[:k+2]\n\ncases = int(input())\nfor case in range(cases):\n movestr = input().replace(\" \",\"\")\n moves = parse(movestr)\n x,y = calc(moves)\n dist = (x**2 + y**2)**0.5\n \n if x == 0:\n  if y == 0:\n   direc = \"\"\n  elif y < 0:\n   direc = \"S\"\n  else:\n   direc = \"N\"\n elif x < 0:\n  if y == 0:\n   direc = \"W\"\n  elif y < 0:\n   direc = \"SW\"\n  else:\n   direc = \"NW\"\n else:\n  if y == 0:\n   direc = \"E\"\n  elif y < 0:\n   direc = \"SE\"\n  else:\n   direc = \"NE\"\n print(\"%s%s\" %(string(dist),direc))"]
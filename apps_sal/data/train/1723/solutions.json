["class Segment:  # Instead of an abstract class, make it the implementation for all three subclasses\n    def __init__(self, *coords):\n        self.control_points = coords  # IMHO a getter/setter is overkill here\n\n    def control_points_at(self, t):  # Helper function\n        p = self.control_points\n        result = []\n        while p:\n            result.extend(p[:2])\n            p = [v + (p[i+2] - v) * t for i, v in enumerate(p[:-2])]\n        return result\n\n    def point_at(self, t):\n        return tuple(self.control_points_at(t)[-2:])\n\n    def sub_segment(self, t):\n        return self.__class__(*self.control_points_at(t))\n\nclass Line(Segment): pass\nclass Quad(Segment): pass\nclass Cubic(Segment): pass", "class Segment:\n    def __init__(self, *coords):\n        self._control_points = list(zip(* [iter(coords)] * 2))\n\n    def _flatten(self, points):\n        return tuple(coord for point in points for coord in point)\n    \n    def _interpolate(self, points, t):\n        return [tuple((1 - t) * x + t * y for x, y in zip(p0, p1))\n                for p0, p1 in zip(points, points[1:])]\n    \n    def _reduce(self, points, t):\n        while len(points) > 1:\n            yield points[0]\n            points = self._interpolate(points, t)\n        yield points[0]\n\n    @property\n    def control_points(self):\n        return self._flatten(self._control_points)\n\n    def point_at(self, t):\n        return list(self._reduce(self._control_points, t))[-1]\n\n    def sub_segment(self, t):\n        return self.__class__(*self._flatten(self._reduce(self._control_points, t)))\n\nclass Line(Segment): pass\nclass Quad(Segment): pass\nclass Cubic(Segment): pass", "from abc import ABCMeta, abstractmethod\n\n\nclass Segment(metaclass=ABCMeta):\n    \n    @property\n    @abstractmethod\n    def control_points(self):\n        pass\n\n    @abstractmethod\n    def point_at(self, t):\n        pass\n\n    @abstractmethod\n    def sub_segment(self, t):\n        pass\n\n\nclass Line(Segment):\n\n    def __init__(self, *coords):\n        self._control_points = coords\n\n    @property\n    def control_points(self):\n        return self._control_points\n\n    def point_at(self, t):\n        x, y = self._control_points[::2], self._control_points[1::2]\n        x0, y0, x1, y1 = self._control_points\n        eq = lambda p, t: (1 - t) * p[0] + t * p[1]\n        return eq(x, t), eq(y, t)\n\n    def sub_segment(self, t):\n        p0 = self._control_points[:2]\n        pt = self.point_at(t)\n        return self.__class__(*p0, *pt)\n\n\nclass Quad(Segment): \n    \n    def __init__(self, *coords):\n        self._control_points = coords\n\n    @property\n    def control_points(self):\n        return self._control_points\n\n    def point_at(self, t):\n        x, y = self._control_points[::2], self._control_points[1::2]\n        eq = lambda p, t: (1 - t)**2 * p[0] + 2 * (1 - t) * t * p[1] + t**2 * p[2]\n        return eq(x, t), eq(y, t)\n\n    def sub_segment(self, t):\n        p0 = self._control_points[:2]\n        q0 = Line(*self._control_points[:4]).point_at(t)\n        pt = self.point_at(t)\n        return self.__class__(*p0, *q0, *pt)\n\n\nclass Cubic(Segment):\n\n    def __init__(self, *coords):\n        self._control_points = coords\n\n    @property\n    def control_points(self):\n        return self._control_points\n\n    def point_at(self, t):\n        x, y = self._control_points[::2], self._control_points[1::2]\n        eq = lambda p, t: (1 - t)**3 * p[0] + 3 * (1 - t)**2 * t * p[1] + 3 * (1 - t) * t**2 * p[2] + t**3 * p[3]\n        return eq(x, t), eq(y, t)\n\n    def sub_segment(self, t):\n        p0 = self._control_points[:2]\n        q0 = Line(*self._control_points[:4]).point_at(t)\n        q1 = Line(*self._control_points[2:6]).point_at(t)\n        r0 = Line(*q0, *q1).point_at(t)\n        pt = self.point_at(t)\n        return self.__class__(*p0, *q0, *r0, *pt)", "from math import factorial\n\nclass Coordinate(object):\n    def __init__(self, x, y):\n        self._x = x\n        self._y = y\n\n    @property\n    def x(self):\n        return self._x\n\n    @property\n    def y(self):\n        return self._y\n\n    def __mul__(self, num):\n        return Coordinate(self.x * num, self.y * num)\n\n    __rmul__ = __mul__\n\n    def __sub__(self, other):\n        return Coordinate(self.x - other.x, self.y - other.y)\n\n    __rsub__ = __sub__\n\n    def __add__(self, other):\n        try:\n            return Coordinate(self.x + other.x, self.y + other.y)\n        except AttributeError:\n            return Coordinate(self.x + other, self.y + other)\n\n    __radd__ = __add__\n\n    def __repr__(self):\n        return \"Coordinate(\" + str(self.x) + \", \" + str(self.y) + \")\"\n\n    def __str__(self):\n        return \"C(\" + str(self.x) + \", \" + str(self.y) + \")\"\n\n    def __hash__(self):\n        return hash((self.x, self.y))\n\n\nclass Segment:\n    def __init__(self, *coords):\n        if len(coords) % 2 != 0:\n            raise ValueError(\"Incorrect number of argument values.\")\n        self._control_points = coords\n        self._P = [Coordinate(coords[i], coords[i+1])\n                   for i in range(0, len(coords), 2)]\n        self._bezier_curve = self._get_bezier_curve(self._P)\n\n    @property\n    def control_points(self):\n        return self._control_points\n\n    @staticmethod\n    def _comb(n, k):\n        return factorial(n) // (factorial(k) * factorial(n - k))\n\n    def _get_bezier_curve(self, points):\n        n = len(points) - 1\n        return lambda t: sum(\n            self._comb(n, i) * t ** i * (1 - t) ** (n - i) * points[i]\n            for i in range(n + 1)\n        )\n\n    def point_at(self, t):\n        pt = self._bezier_curve(t)\n        return pt.x, pt.y\n\n    def sub_segment(self, t):\n        sub_points = [*self._control_points[:2]]\n        for i in range(4, len(self._control_points), 2):\n            point = Segment(*self._control_points[:i]).point_at(t)\n            sub_points.extend(point)\n        sub_points.extend(self.point_at(t))\n        return Segment(*sub_points)\n\n\nclass Line(Segment):\n    pass\n\n\nclass Quad(Segment):\n    pass\n\n\nclass Cubic(Segment):\n    pass", "from abc import ABCMeta, abstractmethod\n\n\nclass Segment(metaclass=ABCMeta):\n\n    @property\n    @abstractmethod\n    def control_points(self):\n        pass\n\n    @abstractmethod\n    def point_at(self, t):\n        pass\n\n    @abstractmethod\n    def sub_segment(self, t):\n        pass\n\n\nclass Coordinate(object):\n    def __init__(self, x, y):\n        self._x = x\n        self._y = y\n\n    @property\n    def x(self):\n        return self._x\n\n    @property\n    def y(self):\n        return self._y\n\n    def __mul__(self, num):\n        return Coordinate(self.x * num, self.y * num)\n\n    def __rmul__(self, num):\n        return Coordinate(self.x * num, self.y * num)\n\n    def __sub__(self, other):\n        return Coordinate(self.x - other.x, self.y - other.y)\n\n    def __add__(self, other):\n        return Coordinate(self.x + other.x, self.y + other.y)\n\n    def __repr__(self):\n        return \"Coordinate(\" + str(self.x) + \", \" + str(self.y) + \")\"\n\n    def __str__(self):\n        return \"<\" + str(self.x) + \", \" + str(self.y) + \">\"\n\n    def __hash__(self):\n        return hash((self.x, self.y))\n\n\nclass Line(Segment):\n\n    def __init__(self, *coords):\n        self._control_points = coords\n        self._P0 = Coordinate(coords[0], coords[1])\n        self._P1 = Coordinate(coords[2], coords[3])\n\n    @property\n    def control_points(self):\n        return self._control_points\n\n    def point_at(self, t):\n        pt = (1 - t) * self._P0 + t * self._P1\n        return pt.x, pt.y\n\n    def sub_segment(self, t):\n        return Line(self._P0.x, self._P0.y, *self.point_at(t))\n\n\nclass Quad(Segment):\n\n    def __init__(self, *coords):\n        self._control_points = coords\n        self._P0 = Coordinate(coords[0], coords[1])\n        self._P1 = Coordinate(coords[2], coords[3])\n        self._P2 = Coordinate(coords[4], coords[5])\n\n    @property\n    def control_points(self):\n        return self._control_points\n\n    def point_at(self, t):\n        pt = (1 - t)**2 * self._P0 + 2 * (1 - t) * t * self._P1 + \\\n             t**2 * self._P2\n        return pt.x, pt.y\n\n    def sub_segment(self, t):\n        sub_line = Line(self._P0.x, self._P0.y, self._P1.x, self._P1.y)\n        return Quad(self._P0.x, self._P0.y, *sub_line.point_at(t),\n                    *self.point_at(t))\n\n\nclass Cubic(Segment):\n\n    def __init__(self, *coords):\n        self._control_points = coords\n        self._P0 = Coordinate(coords[0], coords[1])\n        self._P1 = Coordinate(coords[2], coords[3])\n        self._P2 = Coordinate(coords[4], coords[5])\n        self._P3 = Coordinate(coords[6], coords[7])\n\n    @property\n    def control_points(self):\n        return self._control_points\n\n    def point_at(self, t):\n        pt = (1 - t)**3 * self._P0 + 3 * (1 - t)**2 * t * self._P1 + \\\n             3 * (1 - t) * t**2 * self._P2 + t**3 * self._P3\n        return pt.x, pt.y\n\n    def sub_segment(self, t):\n        sub_line = Line(self._P0.x, self._P0.y, self._P1.x, self._P1.y)\n        sub_quad = Quad(self._P0.x, self._P0.y, self._P1.x, self._P1.y, \n                        self._P2.x, self._P2.y)\n        return Cubic(self._P0.x, self._P0.y, *sub_line.point_at(t), \n                     *sub_quad.point_at(t), *self.point_at(t))\n\n", "from abc import ABCMeta, abstractmethod\nclass Segment(metaclass=ABCMeta):\n\n    @property\n    @abstractmethod\n    def control_points(self):\n        pass\n\n    @abstractmethod\n    def point_at(self, t):\n        pass\n\n    @abstractmethod\n    def sub_segment(self, t):\n        pass\n\nclass Line(Segment):\n    \n    def __init__(self, *coords):\n        self._control_points = coords\n\n    @property\n    def control_points(self):\n        return self._control_points\n\n    def point_at(self, t):\n        #P(t) = (1 - t) * P0 + t * P1\n        p_0,p_1,p_2,p_3 = self.control_points[0],self.control_points[1],self.control_points[2],self.control_points[3]\n        x = (1 - t) *  p_0 + t * p_2\n        y = (1 - t) * p_1 + t * p_3\n        return (x,y)\n\n    def sub_segment(self, t):\n        t_point = self.point_at(t)\n        co_ords = (self.control_points[0],self.control_points[1],t_point[0],t_point[1])\n        return Line(*co_ords)\n\nclass Quad(Segment):\n\n    def __init__(self, *coords):\n        self._control_points = coords\n\n    @property\n    def control_points(self):\n        return self._control_points\n\n    def point_at(self, t):\n        #P(t) = (1 - t)**2 * P0 + 2 * (1 - t) * t * P1 + t**2 * P2\n        p_1 = (self.control_points[0],self.control_points[1])\n        p_2 = (self.control_points[2],self.control_points[3]) \n        p_3 = (self.control_points[4],self.control_points[5]) \n        x = (1 - t)**2 * p_1[0] + 2 * (1 -t) * t * p_2[0] + t**2 * p_3[0]\n        y = (1 - t)**2 * p_1[1] + 2 * (1 -t) * t * p_2[1] + t**2 * p_3[1]\n        return (x,y)\n\n    def sub_segment(self, t):\n        #get p2\n        lne = Line(self.control_points[0],self.control_points[1],self.control_points[2],self.control_points[3])\n        t_p1 = lne.point_at(t)\n        t_point = self.point_at(t)\n        co_ords = (self.control_points[0],self.control_points[1],t_p1[0],t_p1[1],t_point[0],t_point[1])\n        return Quad(*co_ords)\n\nclass Cubic(Segment):\n\n    def __init__(self, *coords):\n        self._control_points = coords\n\n    @property\n    def control_points(self):\n        return self._control_points\n\n    def point_at(self, t):\n        #P(t) = (1 - t)**3 * P0 + 3 * (1 - t)**2 * t * P1 + 3 * (1 - t) * t**2 * P2 + t**3 * P3\n        p_1 = (self.control_points[0],self.control_points[1])\n        p_2 = (self.control_points[2],self.control_points[3]) #x\n        p_3 = (self.control_points[4],self.control_points[5])\n        p_4 = (self.control_points[6],self.control_points[7]) #y\n        x = (1 -t)**3 * p_1[0] + 3 *(1 -t)**2 * t * p_2[0] + 3 * (1-t) * t**2 * p_3[0] + t**3 * p_4[0]\n        y = (1 -t)**3 * p_1[1] + 3 *(1 -t)**2 * t * p_2[1] + 3 * (1-t) * t**2 * p_3[1] + t**3 * p_4[1]\n        return (x,y)\n\n    def sub_segment(self, t):\n        t_point = self.point_at(t)\n        lne_1 = Line(self.control_points[0],self.control_points[1],self.control_points[2],self.control_points[3])\n        pnt_1 = lne_1.point_at(t)\n        lne_2 = Line(self.control_points[2],self.control_points[3],self.control_points[4],self.control_points[5])\n        pnt_2 = lne_2.point_at(t)\n        lne_3 = Line(self.control_points[4],self.control_points[5],self.control_points[6],self.control_points[7])\n        pnt_3 = lne_3.point_at(t)\n        #########################################################################################################\n        lne_g1 = Line(*pnt_1,*pnt_2)\n        pnt_g1 = lne_g1.point_at(t)\n        lne_g2 = Line(*pnt_2,*pnt_3)\n        #########################################################################################################\n        co_ords = (self.control_points[0],self.control_points[1],pnt_1[0],pnt_1[1],pnt_g1[0],pnt_g1[1],t_point[0],t_point[1])\n        return Cubic(*co_ords)\n", "from abc import ABCMeta, abstractmethod\nfrom functools import reduce\n\nclass Segment(metaclass=ABCMeta):\n\n    @property\n    @abstractmethod\n    def control_points(self):\n        pass\n\n    @abstractmethod\n    def point_at(self, t):\n        pass\n\n    @abstractmethod\n    def sub_segment(self, t):\n        pass\n    \ndef mul(a, b):\n    return (a[0]*b , a[1]*b)\ndef add(*args):\n    print(args)\n    return (sum([args[i][0] + args[i + 1][0] for i in range(len(args) - 1)]),  sum([args[i][1] + args[i + 1][1] for i in range(len(args) - 1)]))  \nclass Line(Segment):\n\n    def __init__(self, *c):\n        self.c = c\n        self.points = [(c[i], c[i+1]) for i in range(0, len(c) - 1, 2)]\n\n    @property\n    def control_points(self):\n        return self.c\n\n    def point_at(self, t):\n        p = self.points\n        return add(mul(p[0], 1 - t), mul(p[1], t)) \n\n    def sub_segment(self, t):\n        return Line(self.c[0],self.c[1], self.point_at(t)[0], self.point_at(t)[1])\n\n\nclass Quad(Segment):\n\n    def __init__(self, *c):\n        self.c = c\n        self.points = [(c[i], c[i+1]) for i in range(0, len(c) - 1, 2)]\n\n    @property\n    def control_points(self):\n        return self.c\n\n    def point_at(self, t):\n        p = self.points\n        return reduce(add, [mul(p[0], (1 - t)**2), mul(p[1], t*2*(1-t)), mul(p[2], t**2)])\n\n    def sub_segment(self, t):\n        a, b = add(mul(self.points[0], 1-t), mul(self.points[1], t))\n        return Quad(self.c[0], self.c[1], a, b, self.point_at(t)[0], self.point_at(t)[1])\n\nclass Cubic(Segment):\n    def __init__(self, *c):\n        self.c = c\n        self.points = [(c[i], c[i+1]) for i in range(0, len(c) - 1, 2)]\n\n    @property\n    def control_points(self):\n        return self.c\n\n    def point_at(self, t):\n        p = self.points\n        return reduce(add,[mul(p[0], (1 - t)**3), mul(p[1], 3*t*(1-t)**2), mul(p[2], 3*t**2*(1-t)), mul(p[3], t**3)])\n\n    def sub_segment(self, t):\n        p = self.points\n        a, b =  add(mul(p[0], 1 - t), mul(p[1], t)) \n        c, d = reduce(add, [mul(p[0], (1 - t)**2), mul(p[1], t*2*(1-t)), mul(p[2], t**2)])\n        return Cubic(self.c[0], self.c[1], a, b, c, d, self.point_at(t)[0], self.point_at(t)[1])", "from abc import ABCMeta, abstractmethod\n\n\nclass Segment(metaclass=ABCMeta):\n\n    @property\n    @abstractmethod\n    def control_points(self):\n        pass\n\n    @abstractmethod\n    def point_at(self, t):\n        pass\n\n    @abstractmethod\n    def sub_segment(self, t):\n        pass\n\n\nclass Line(Segment):\n\n    def __init__(self, *coords):\n        self._control_points = coords\n\n    @property\n    def control_points(self):\n        return self._control_points\n\n    def point_at(self, t):\n        x0, y0, x1, y1 = self.control_points\n        point = tuple((1 - t) * p0 + t * p1 for p0, p1 in [(x0, x1), (y0, y1)])\n        return point\n\n    def sub_segment(self, t):\n        return Line(*self.control_points[:2], *self.point_at(t))\n\n\nclass Quad(Segment):\n\n    def __init__(self, *coords):\n        self._control_points = coords\n\n    @property\n    def control_points(self):\n        return self._control_points\n\n    def point_at(self, t):\n        x0, y0, x1, y1, x2, y2 = self.control_points\n        point = tuple((1 - t)**2 * p0 + 2 * (1 - t) * t * p1 + t**2 * p2 \n                    for p0, p1, p2 in [(x0, x1, x2), (y0, y1, y2)])\n        return point\n\n    def sub_segment(self, t):\n        x0, y0 = self.control_points[:2]\n        x1, y1 = Line(x0, y0, *self.control_points[2:4]).point_at(t)\n        x2, y2 = self.point_at(t)\n        return Quad(x0, y0, x1, y1, x2, y2)\n\n\nclass Cubic(Segment):\n\n    def __init__(self, *coords):\n        self._control_points = coords\n\n    @property\n    def control_points(self):\n        return self._control_points\n\n    def point_at(self, t):\n        x0, y0, x1, y1, x2, y2, x3, y3 = self.control_points\n        point = tuple((1 - t)**3 * p0 + 3 * (1 - t)**2 * t * p1 + 3 * (1 - t) * t**2 * p2 + t**3 * p3 \n                    for p0, p1, p2, p3 in [(x0, x1, x2, x3), (y0, y1, y2, y3)])\n        return point\n\n    def sub_segment(self, t):\n        x0, y0 = self.control_points[:2]\n        x1, y1 = Line(x0, y0, *self.control_points[2:4]).point_at(t)\n        x2, y2 = Quad(*self.control_points[:6]).point_at(t)\n        x3, y3 = self.point_at(t)\n        return Cubic(x0, y0, x1, y1, x2, y2, x3, y3)\n", "from abc import ABCMeta, abstractmethod\nimport numpy as np\n\nclass Segment(metaclass=ABCMeta):\n\n    @property\n    @abstractmethod\n    def control_points(self):\n        pass\n\n    @abstractmethod\n    def point_at(self, t):\n        pass\n\n    @abstractmethod\n    def sub_segment(self, t):\n        pass\n\n\nclass Line(Segment):\n\n    def __init__(self, *coords):\n        self._control_points = coords\n\n    @property\n    def control_points(self):\n        return self._control_points\n\n    def point_at(self, t):\n        P0 = np.array(self._control_points[0:2])\n        P1 = np.array(self._control_points[2:])\n        return (1 - t) * P0 + t * P1\n\n\n    def sub_segment(self, t):\n        P0 = np.array(self._control_points[0:2])\n        P1 = self.point_at(t)\n\n        return Line(*P0,*P1)\n\n\nclass Quad(Segment):\n\n    def __init__(self, *coords):\n        self._control_points = coords\n\n    @property\n    def control_points(self):\n        return self._control_points\n\n    def point_at(self, t):\n        P0 = np.array(self._control_points[0:2])\n        P1 = np.array(self._control_points[2:4])\n        P2 = np.array(self._control_points[4:])\n        return (1 - t)**2 * P0 + 2 * (1 - t) * t * P1 + t**2 * P2\n\n    def sub_segment(self, t):\n        P0 = np.array(self._control_points[0:2])\n        P1 = np.array(self._control_points[2:4])\n        l1 = Line(*P0,*P1)\n        P1_new = l1.point_at(t)\n        P2 = np.array(self._control_points[4:])\n        P2_new = self.point_at(t)\n\n        return Quad(*P0,*P1_new,*P2_new)\n\n\nclass Cubic(Segment):\n\n    def __init__(self, *coords):\n        self._control_points = coords\n\n    @property\n    def control_points(self):\n        return self._control_points\n\n    def point_at(self, t):\n        P0 = np.array(self._control_points[0:2])\n        P1 = np.array(self._control_points[2:4])\n        P2 = np.array(self._control_points[4:6])\n        P3 = np.array(self._control_points[6:])\n        return (1 - t)**3 * P0 + 3 * (1 - t)**2 * t * P1 + 3 * (1 - t) * t**2 * P2 + t**3 * P3\n\n    def sub_segment(self, t):\n        P0 = np.array(self._control_points[0:2])\n        P1 = np.array(self._control_points[2:4])\n        P2 = np.array(self._control_points[4:6])\n        P3 = np.array(self._control_points[6:])\n        l1 = Line(*P0,*P1)\n        P1_new = l1.point_at(t)\n        l2 = Quad(*P0,*P1,*P2)\n        P2_new = l2.point_at(t)\n        P3_new = self.point_at(t)\n        return Cubic(*P0,*P1_new,*P2_new,*P3_new)\n", "from abc import ABCMeta, abstractmethod\n\n\nclass Segment(metaclass=ABCMeta):\n\n    @property\n    @abstractmethod\n    def control_points(self):\n        pass\n\n    @abstractmethod\n    def point_at(self, t):\n        pass\n\n    @abstractmethod\n    def sub_segment(self, t):\n        pass\n\n\nclass Line(Segment):\n\n    def __init__(self, *coords):\n        self.cp = coords\n        self.P0 = (coords[0], coords[1])\n        self.P1 = (coords[2], coords[3])\n\n    @property\n    def control_points(self):\n        return self.cp\n\n    def point_at(self, t):\n        x = (1-t)*self.P0[0] + t*self.P1[0]\n        y = (1-t)*self.P0[1] + t*self.P1[1]\n        return (x,y)\n\n    def sub_segment(self, t):\n        return Line(*self.P0, *self.point_at(t))\n\n\nclass Quad(Segment):\n\n    def __init__(self, *coords):\n        self.cp = coords\n        self.P = [(coords[0], coords[1]),\n                  (coords[2], coords[3]),\n                  (coords[4], coords[5])]\n\n    @property\n    def control_points(self):\n        return self.cp\n        \n    def get_Q(self, t):\n        return (Line(*self.P[0], *self.P[1]).point_at(t), \n                Line(*self.P[1], *self.P[2]).point_at(t))\n\n    def point_at(self, t):\n        Q = self.get_Q(t)\n        return Line(*Q[0], *Q[1]).point_at(t)\n\n    def sub_segment(self, t):\n        Q = self.get_Q(t)[0]\n        B = self.point_at(t)\n        return Quad(*self.P[0], *Q, *B)\n\n\nclass Cubic(Segment):\n\n    def __init__(self, *coords):\n        self.cp = coords\n        self.P = [(coords[0], coords[1]),\n                  (coords[2], coords[3]),\n                  (coords[4], coords[5]),\n                  (coords[6], coords[7])]\n\n    @property\n    def control_points(self):\n        return self.cp\n        \n    def get_Q(self, t):\n        return (Line(*self.P[0], *self.P[1]).point_at(t),\n                Line(*self.P[1], *self.P[2]).point_at(t),\n                Line(*self.P[2], *self.P[3]).point_at(t))\n\n    def point_at(self, t):\n        Q = self.get_Q(t)\n        return Quad(*(Q[0]), *(Q[1]), *(Q[2])).point_at(t)\n\n    def sub_segment(self, t):\n        Q = self.get_Q(t)\n        R = Line(*Q[0], *Q[1]).point_at(t)\n        B = self.point_at(t)\n        return Cubic(*self.P[0], *Q[0], *R, *B)\n        \n"]
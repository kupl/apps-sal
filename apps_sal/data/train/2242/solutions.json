["import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = (tuple(int(x) for x in row.split()) for row in sys.stdin.readlines())\n\n# x\u5ea7\u6a19\u30921,2,...,N\n# y\u5ea7\u6a19\u3092N+1,N+2,...,N+N\n\ngraph = [set() for _ in range(N+N+1)]\nfor x,y in ball:\n    graph[x].add(y+N)\n    graph[y+N].add(x)\n\nvisited = [False] * (N+N+1)\ncomponents = []\nfor x in range(1,N+N+1):\n    if visited[x]:\n        continue\n    V = set([x])\n    E = []\n    q = [x]\n    visited[x] = True\n    while q:\n        y = q.pop()\n        for z in graph[y]:\n            if y < z:\n                E.append((y,z))\n            if visited[z]:\n                continue\n            V.add(z)\n            visited[z] = True\n            q.append(z)\n    components.append((V,E))\n\ndef make_get_pattern(V):\n    deg1 = [x for x in V if len(graph[x]) == 1]\n    get = {}\n    while deg1:\n        x = deg1.pop()\n        if not graph[x]:\n            continue\n        y = graph[x].pop()\n        se = graph[y]; se.remove(x)\n        if len(se) == 1: deg1.append(y)\n        if x < y:\n            get[(x,y)] = 0\n        else:\n            get[(y,x)] = 1\n    for x in V:\n        if graph[x]:\n            y = graph[x].pop()\n            break\n    # \u6b8b\u308a\u306f\u30b5\u30a4\u30af\u30eb\n    graph[y].remove(x)\n    if x > y: x,y = y,x\n    get[(x,y)] = 2\n    while graph[x]:\n        y = graph[x].pop()\n        graph[y].remove(x)\n        if x < y:\n            get[(x,y)] = 3\n        else:\n            get[(y,x)] = 2\n        x = y\n    return get\n\ndef F(V,E):\n    # V is connected\n    if len(E) != len(V):\n        return 0\n    ret = 0\n    E.sort()\n    get = make_get_pattern(V)\n    den1,den2 = 1,1\n    dp1 = {x:0 for x in V}\n    dp2 = {x:0 for x in V}\n    for x,y in E:\n        if get[(x,y)] == 0:\n            k1 = dp1[x] + 1; k2 = dp2[x] + 1\n        elif get[(x,y)] == 1:\n            k1 = dp1[y] + 1; k2 = dp2[y] + 1\n        elif get[(x,y)] == 2:\n            k1 = dp1[x] + 1; k2 = dp2[y] + 1\n        else:\n            k1 = dp1[y] + 1; k2 = dp2[x] + 1\n        dp1[x] += k1; dp1[y] += k1\n        dp2[x] += k2; dp2[y] += k2\n        den1 *= k1; den2 *= k2\n        den1 %= MOD; den2 %= MOD\n    return sum(pow(x,MOD-2,MOD) for x in (den1,den2))\n\nprob = 1\nfor c in components:\n    prob *= F(*c)\n    prob %= MOD\n\nanswer = prob\nfor n in range(1,N+N+1):\n    answer *= n\n    answer %= MOD\nprint(answer)", "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = [tuple(int(x) for x in input().split()) for _ in range(N+N)]\n\n# x\u5ea7\u6a19\u30921,2,...,N\n# y\u5ea7\u6a19\u3092N+1,N+2,...,N+N\n\ngraph = [set() for _ in range(N+N+1)]\nfor x,y in ball:\n    graph[x].add(y+N)\n    graph[y+N].add(x)\n\nvisited = set()\ncomponents = []\nfor x in range(1,N+N+1):\n    if x in visited:\n        continue\n    V = set([x])\n    q = [x]\n    while q:\n        y = q.pop()\n        for z in graph[y]:\n            if z in V:\n                continue\n            V.add(z)\n            q.append(z)\n    visited |= V\n    components.append(V)\n\ndef make_get_patterns(V):\n    deg1 = [x for x in V if len(graph[x]) == 1]\n    get = {},{}\n    while deg1:\n        x = deg1.pop()\n        if not graph[x]:\n            continue\n        y = graph[x].pop()\n        se = graph[y]; se.remove(x)\n        if len(se) == 1: deg1.append(y)\n        if x < y:\n            get[0][(x,y)] = 0; get[1][(x,y)] = 0\n        else:\n            pass\n            get[0][(y,x)] = 1; get[1][(y,x)] = 1\n    for x in V:\n        if graph[x]:\n            y = graph[x].pop()\n            break\n    # \u6b8b\u308a\u306f\u30b5\u30a4\u30af\u30eb\n    graph[y].remove(x)\n    if x > y: x,y = y,x\n    get[0][(x,y)] = 0; get[1][(x,y)] = 1\n    while True:\n        if not graph[x]:\n            break\n        y = graph[x].pop()\n        graph[y].remove(x)\n        if x < y:\n            get[0][(x,y)] = 1; get[1][(x,y)] = 0\n        else:\n            get[0][(y,x)] = 0; get[1][(y,x)] = 1\n        x = y\n    return get\n\ndef F(V):\n    # V is connected\n    E = sorted((x,y) for x in V if x <= N for y in graph[x])\n    if len(E) != len(V):\n        return 0\n    ret = 0\n    for get in make_get_patterns(V):\n        den = 1\n        dp = {x:0 for x in V}\n        for x,y in E:\n            if get[(x,y)] == 0:\n                k = dp[x] + 1\n            else:\n                k = dp[y] + 1\n            dp[x] += k\n            dp[y] += k\n            den *= k\n            den %= MOD\n        ret += pow(den,MOD-2,MOD)\n    return ret % MOD\n\nprob = 1\nfor c in components:\n    prob *= F(c)\n    prob %= MOD\n\nanswer = prob\nfor n in range(1,N+N+1):\n    answer *= n\n    answer %= MOD\nprint(answer)\n", "import sys\ninput = sys.stdin.readline\n\nMOD = 10**9 + 7\n\nN = int(input())\nball = (tuple(int(x) for x in row.split()) for row in sys.stdin.readlines())\n\n# x\u5ea7\u6a19\u30921,2,...,N\n# y\u5ea7\u6a19\u3092N+1,N+2,...,N+N\n\ngraph = [set() for _ in range(N+N+1)]\nfor x,y in ball:\n    graph[x].add(y+N)\n    graph[y+N].add(x)\n\nvisited = [False] * (N+N+1)\ncomponents = []\nfor x in range(1,N+N+1):\n    if visited[x]:\n        continue\n    V = set([x])\n    E = []\n    q = [x]\n    visited[x] = True\n    while q:\n        y = q.pop()\n        for z in graph[y]:\n            if y < z:\n                E.append((y,z))\n            if visited[z]:\n                continue\n            V.add(z)\n            visited[z] = True\n            q.append(z)\n    components.append((V,E))\n\ndef make_get_pattern(V):\n    deg1 = [x for x in V if len(graph[x]) == 1]\n    get = {}\n    while deg1:\n        x = deg1.pop()\n        if not graph[x]:\n            continue\n        y = graph[x].pop()\n        se = graph[y]; se.remove(x)\n        if len(se) == 1: deg1.append(y)\n        if x < y:\n            get[(x,y)] = 0\n        else:\n            get[(y,x)] = 1\n    for x in V:\n        if graph[x]:\n            y = graph[x].pop()\n            break\n    # \u6b8b\u308a\u306f\u30b5\u30a4\u30af\u30eb\n    graph[y].remove(x)\n    if x > y: x,y = y,x\n    get[(x,y)] = 2\n    while graph[x]:\n        y = graph[x].pop()\n        graph[y].remove(x)\n        if x < y:\n            get[(x,y)] = 3\n        else:\n            get[(y,x)] = 2\n        x = y\n    return get\n\ndef F(V,E):\n    # V is connected\n    if len(E) != len(V):\n        return 0\n    ret = 0\n    E.sort()\n    get = make_get_pattern(V)\n    den1,den2 = 1,1\n    dp1 = {x:0 for x in V}\n    dp2 = {x:0 for x in V}\n    for x,y in E:\n        if get[(x,y)] == 0:\n            k1 = dp1[x] + 1; k2 = dp2[x] + 1\n        elif get[(x,y)] == 1:\n            k1 = dp1[y] + 1; k2 = dp2[y] + 1\n        elif get[(x,y)] == 2:\n            k1 = dp1[x] + 1; k2 = dp2[y] + 1\n        else:\n            k1 = dp1[y] + 1; k2 = dp2[x] + 1\n        dp1[x] += k1; dp1[y] += k1\n        dp2[x] += k2; dp2[y] += k2\n        den1 *= k1; den2 *= k2\n        den1 %= MOD; den2 %= MOD\n    return sum(pow(x,MOD-2,MOD) for x in (den1,den2))\n\nprob = 1\nfor c in components:\n    prob *= F(*c)\n    prob %= MOD\n\nanswer = prob\nfor n in range(1,N+N+1):\n    answer *= n\n    answer %= MOD\nprint(answer)"]
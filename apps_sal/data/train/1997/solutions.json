["class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: (x[0], -x[1]))\n        \n        prev_end = result = 0\n        for _, end in intervals:\n            if end > prev_end:\n                result += 1; prev_end = end\n                \n        return result", "class Solution:\n    def removeCoveredIntervals(self, l: List[List[int]]) -> int:\n        l.sort(reverse=True,key=lambda x:(x[1],-x[0]))\n        n=len(l)\n        c=n\n        for i in range(n-1):\n            if(l[i][0]<=l[i+1][0] and l[i][1]>=l[i+1][1]):\n                l[i+1]=l[i]\n                c-=1\n        return c", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        from functools import cmp_to_key\n        \n        def cmp(a,b):\n            if a[0]>b[0]:\n                return 1\n            if a[0]<b[0]:\n                return -1\n            if a[1]>b[1]:\n                return -1\n            return 1\n            \n        lis=[]\n        if len(intervals)==1:\n            return 1\n        for x,y in intervals:\n            lis.append((x,y))\n        lis.sort(key = cmp_to_key(cmp))\n        fin=[]\n        fin.append(list(lis[0]))\n        for i in range(1,len(lis)):\n            currx,curry=lis[i]\n            flag=0\n            for j in range(len(fin)):\n                if curry<=fin[j][1] and currx>=fin[j][0]:\n                    flag=1\n            if flag==0:\n                fin.append([currx,curry])\n        return len(fin)\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: (x[0], -x[1]))\n        \n        covering = 0\n        used = set()\n        for i, (si, ei) in enumerate(intervals):\n            for sj, ej in intervals[i+1:]:                \n                if sj > ei:\n                    break\n                if ej > ei:\n                    continue\n                if (sj, ej) in used:\n                    continue\n                used.add((sj, ej))\n                covering += 1\n                \n        return len(intervals) - covering\n            \n", "class Tree:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    def __lt__(self, other):\n        if self.val[0] < other.val[0]: return True\n        elif self.val[0] > other.val[0]: return False\n        else:\n            if self.val[1] > other.val[1]: return True\n            else: return False\n\n    def __le__(self, other):\n        return self < other or self.val == other.val\n\n    def __gt__(self, other): return not self <= other\n\n    def __ge__(self, other): return not self < other\n\n    def __eq__(self, other): return self <= other and self >= geother\n\n    def __neq__(self, other): return not self == other\n\nclass Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        tree = Tree(val=tuple(intervals[0]))\n        for x, y in intervals[1:]:\n            this = Tree((x, y))\n            cursor = tree\n            while True:\n                if this < cursor:\n                    if cursor.left:\n                        cursor = cursor.left\n                    else:\n                        cursor.left = this\n                        break\n                elif this > cursor:\n                    if cursor.right:\n                        cursor = cursor.right\n                    else:\n                        cursor.right = this\n                        break\n                else:\n                    break\n\n        buff = [tree]\n        count, last = 0, None\n        while buff:\n            while buff[-1].left: buff.append(buff[-1].left)\n            while buff and not buff[-1].right:\n                this = buff.pop(-1)\n                if count == 0: count, last = 1, this.val[1]\n\n                else:\n                    if this.val[1] > last: count, last = count + 1, this.val[1]\n\n            if buff:\n                this = buff.pop(-1)\n                if count == 0: count, last = 1, this.val[1]\n\n                else:\n                    if this.val[1] > last: count, last = count + 1, this.val[1]\n\n                buff.append(this.right)\n\n        return count", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        \n        \n        \n        for i in range(0,len(intervals)-1):\n            minel=intervals[i]\n            minid=i\n            for j in range(i+1,len(intervals)):\n                evl=intervals[j]\n                \n                if evl[0]<minel[0]:\n                    \n                    minel=evl\n                    minid=j\n            intervals[i],intervals[minid]=intervals[minid],intervals[i]\n        #print(intervals)\n        \n        \n        \n        \n        c=0\n        prevl=intervals[0][0]\n        prevh=intervals[0][1]\n        \n        for x in range(1,len(intervals)):\n            \n            \n            curl=intervals[x][0]\n            curh=intervals[x][1]\n            if curh<=prevh:\n                c=c+1\n                continue\n            if curl==prevl:\n                \n                c=c+1\n                if curh>prevh:\n                    prevh=curh\n                continue\n            prevl=curl\n            prevh=curh\n        return len(intervals)-c\n            \n            \n        \n        #return 1    \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        \n        # sort based on [smallest start time, largest end time): O(n*log(n))\n        # Sliding window upto the next start that is larger than current end\n        # If they overlap then discard.\n        \n        ordered_intervals = sorted(intervals, key=lambda x: (x[0],-x[1]))\n        candidates = set()\n        for i in range(len(intervals)):\n            \n            curr_start, curr_end = ordered_intervals[i]\n            \n            for j in range(i+1, len(intervals)):\n            \n                next_start, next_end = ordered_intervals[j]\n                if next_start >= curr_end:\n                    break\n                    \n                if next_end <= curr_end:\n                    candidates.add(j)\n                    \n        #result = []\n        #for i, interval in enumerate(ordered_intervals):\n        #    if i not in candidates:\n        #        result.append(interval)\n        return len(intervals) - len(candidates)\n                \n                \n", "import numpy as np\nclass Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        copy_intervals = intervals[:]\n        for i, interval_1 in enumerate(copy_intervals):\n            for interval_2 in copy_intervals[i+1:]:\n                if interval_1[0] >= interval_2[0] and interval_1[1] <= interval_2[1]:\n                    if interval_1 in intervals:\n                        intervals.remove(interval_1)\n                    break\n                if interval_1[0] <= interval_2[0] and interval_1[1] >= interval_2[1]:\n                    if interval_2 in intervals:\n                        intervals.remove(interval_2)\n        return len(intervals)", "class Solution:\n    def removeCoveredIntervals(self, arr: List[List[int]]) -> int:\n        arr.sort(reverse=True)\n        ans=0\n        n=len(arr)\n        take=[1]*n\n        for i in range(n-1):\n            for j in range(i+1,n):\n                if arr[i][0]>=arr[j][0] and arr[i][1]<=arr[j][1]:\n                    take[i]=0\n                    break\n        # print(arr)\n        # print(take)\n        for i in range(n-1,-1,-1):\n            for j in range(i-1,-1,-1):\n                if arr[i][0]>=arr[j][0] and arr[i][1]<=arr[j][1]:\n                    take[i]=0\n                    break\n        # print(arr)\n        # print(take)\n        return take.count(1)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key = lambda interval: (interval[0], -interval[1]))\n        length = len(intervals)\n        start = 0\n        removed = 0\n        \n        while start < length-1 :\n            curr = start + 1\n            while curr < length:\n                if intervals[curr][0] != -1:\n                    if (intervals[curr])[0] >= (intervals[start])[0] and (intervals[curr])[1] <= (intervals[start])[1]:\n                        removed+=1\n                        (intervals[curr])[0] = -1\n                        (intervals[curr])[1] = -1\n                curr+=1\n            start+=1\n        return length - removed\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals=sorted(intervals,key=lambda x:x[1])\n        n=len(intervals)\n        cnt=0\n        for i in intervals:\n            for j in intervals:\n                if j==i:\n                    continue\n                if i[1]<=j[1] and i[0]>=j[0]:\n                    cnt+=1\n                    break\n        return(n-cnt)\n                    \n        \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n         # n log n time\n        intervals.sort(reverse = True)\n        intervals.sort(key = lambda i: i[1])\n        \n        covered = set() # n space\n        \n        for i, (c, d) in enumerate(intervals):\n            for (a, b) in intervals[0: i]:\n                #print((a,b), (c,d), c <= a, b <= d)\n                \n                if  c <= a and b <= d:\n                    #print(\\\"covered\\\")\n                    covered.add((a, b))\n                    \n        #print(covered)\n        return len(intervals) - len(covered)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        def overlap(interval1, interval2):\n            if interval1[0] > interval2[0]:\n                interval1, interval2 = interval2, interval1\n            return interval1[1] >= interval2[1]\n        \n        intervals.sort(key = lambda x: (x[0], -x[1]))\n        print(intervals)\n        \n        count = 0\n\n        res = [intervals[0]]\n        for i in intervals[1:]:\n            print((i, res[-1]))\n            if not overlap(res[-1], i):\n                res.append(i)\n\n        return len(res)\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n         # n log n time\n        intervals.sort(reverse = True)\n        intervals.sort(key = lambda i: i[1])\n        \n        covered = set() # n space\n        \n        for i, (c, d) in enumerate(intervals):\n            for (a, b) in intervals[0: i]:           \n                #print((a,b), (c,d), c <= a, b <= d)\n                \n                if  c <= a and b <= d:\n                    #print(\\\"covered\\\")\n                    covered.add((a, b))\n                    \n        #print(covered)\n        return len(intervals) - len(covered)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        n = len(intervals)\n        flag = [0]*n\n        i = 0\n        \n        while i<n:\n            j = i+1\n            while j<n:\n                if flag[i]!=1:\n                    print((i,j,intervals[i], intervals[j]))\n                    if intervals[j][0] <= intervals[i][0] and intervals[i][1] <= intervals[j][1]:\n                        flag[i] = 1\n                    if intervals[i][0] <= intervals[j][0] and intervals[j][1] <= intervals[i][1]:\n                        flag[j] = 1\n                j+=1  \n            i+=1                \n                \n\n        return flag.count(0)\n            \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        new = sorted(intervals, key = lambda x : x[1]-x[0] , reverse = True)\n        ans = []\n        for i,v in enumerate(new):\n            flag = False\n            for elem in new[:i]:\n                if v[0] >= elem[0] and v[1] <= elem[1]:\n                    flag = True\n            if flag == False:\n                ans.append(v)\n        return len(ans)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        \n        removed = 0\n        removedSet = set()\n        for ind1 in range(len(intervals)):\n            for ind2 in range(len(intervals)):\n                if ind1 == ind2 or ind1 in removedSet: continue\n                interval1 = intervals[ind1]\n                interval2 = intervals[ind2]\n                \n                if interval1[0] >= interval2[0] and interval1[1] <= interval2[1]:\n                    removed += 1\n                    removedSet.add(ind1)\n                        \n        return len(intervals) - removed\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        n = len(intervals)\n        flag = [True for i in range(n)]\n        ctr = n\n        for i in range(n):\n            for j in range(n):\n                if i!=j and flag[i] and flag[j]:\n                    a,b = intervals[i]\n                    c,d = intervals[j]\n                    if(c<=a and b<=d):\n                        flag[i] = False\n                        ctr-=1\n                    elif(a<=c and d<=b):\n                        flag[j] = False\n                        ctr-=1\n        return ctr", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        \n        def covered(a, b):\n            # True if a is covered by b\n            \n            return a[0] >= b[0] and a[1] <= b[1]\n        \n        deleted = set()\n        \n        for i in range(len(intervals)):\n            for j in range(len(intervals)):\n                \n                if i!=j and i not in deleted:\n                    if covered(intervals[i], intervals[j]):\n                        # print(i, j)\n                        deleted.add(i)\n        \n        return len(intervals) - len(deleted)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        int_set = set(tuple(i) for i in intervals)\n        for i, (a, b) in enumerate(intervals):\n            for c, d in intervals[i+1:]:\n                if a <= c and d <= b and (c, d) in int_set:\n                    int_set.remove((c, d))\n                elif c <= a and b <= d and (a, b) in int_set:\n                    int_set.remove((a, b))\n        return len(int_set)\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        covered=0\n        m = {}\n        for [l,r] in intervals:\n            if l not in m:\n                m[l] = r\n            else:\n                m[l] = max(r, m[l])\n                covered +=1\n        \n        a = []\n        for i in m:\n            a.append([i,m[i]])\n        \n            \n        a.sort(key=lambda x: x[0])\n        # print(a)\n        _c = set()\n        for i in range(len(a)):\n            for j in range(i+1,len(a)):\n                if a[j][1] <= a[i][1] and j not in _c:\n                    _c.add(j)\n                    covered += 1\n\n        return len(intervals) - covered\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key = lambda tup: tup[1] - tup[0], reverse = True)\n        covered = set()\n        \n        for i in range(len(intervals)):\n            s, e = intervals[i]\n            for j in range(i + 1, len(intervals)):\n                s2, e2 = intervals[j]\n\n                if s <= s2 and e2 <= e:\n                    covered.add(j)\n                    \n                \n        return len(intervals) - len(covered)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        l = len(intervals)\n        a = [True] * l\n        \n        for i in range(l):\n            for j in range(l):\n                if i == j:\n                    continue\n                \n                if not a[i] or not a[j]:\n                    continue\n                    \n                if intervals[i][0] <= intervals[j][0] and intervals[i][1] >= intervals[j][1]:\n                    a[j] = False\n                    \n        return a.count(True)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        \n        intervals.sort(key=lambda x: (x[0], -x[1]))\n        ans = len(intervals)\n        i = 0\n        while i < len(intervals):\n            for j in range(i):\n                if intervals[j][0] <= intervals[i][0] and intervals[j][1] >= intervals[i][1]:\n                    ans -= 1\n                    break\n            i += 1\n        return ans\n                \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals = sorted(intervals, key=lambda k: (k[0], -k[1]))\n        removed = set()\n        i = 0\n        while i < len(intervals) - 1:\n            for j in range(i + 1, len(intervals)):\n                if intervals[j][1] <= intervals[i][1] and j not in removed:\n                    removed.add(j)\n            i += 1\n        return len(intervals) - len(removed)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n         # n log n time\n        intervals.sort(reverse = True)\n        intervals.sort(key = lambda i: i[1])\n        \n        covered = set() # n space\n        \n        for i, (c, d) in enumerate(intervals):\n            for (a, b) in intervals[0: i]:\n                if b < c:\n                    continue\n                    \n                #print((a,b), (c,d), c <= a, b <= d)\n                \n                if  c <= a and b <= d:\n                    #print(\\\"covered\\\")\n                    covered.add((a, b))\n                    \n        #print(covered)\n        return len(intervals) - len(covered)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        n = len(intervals)\n        intervals.sort(key=lambda x: (x[0], -x[1]))\n        removeSet = set()\n        \n        for i in range(n):\n            interval1 = intervals[i]\n            \n            for j in range(i + 1, n):\n                interval2 = intervals[j]\n                if interval2[0] >= interval1[1]: break\n                    \n                if interval2[1] <= interval1[1]:\n                    removeSet.add(j)\n                    \n        return n - len(removeSet)\n            \n        \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        l = len(intervals)\n        removed = set()\n        intervals.sort(key = lambda i: (i[0], -i[1]))\n        for i in range(l):\n            for j in range(i + 1, l):\n                if intervals[i][1] >= intervals[j][1]:\n                    removed.add(j)\n        return l - len(removed)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        discarded = [False] * len(intervals)\n        for i in range(len(intervals)):\n            for j in range(len(intervals)):\n                if i == j:\n                    continue\n                if discarded[j]:\n                    continue\n                if intervals[j][0] >= intervals[i][0] and intervals[j][1] <= intervals[i][1]:\n                    discarded[j] = True\n        kount = 0\n        for i in range(len(intervals)):\n            if not discarded[i]:\n                kount = kount + 1\n        return kount\n                \n                    \n            \n", "def checkCovered(a, b):\n    if a[0] < b[0] or a[1] > b[1]:\n        return False\n    \n    return True\n\nclass Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        covered = [0] * len(intervals)\n        for i in range(len(intervals) - 1):\n            a = intervals[i]\n            for j in range(i+1, len(intervals)):\n                b = intervals[j]\n\n                if covered[i] == 0:\n                    if checkCovered(a, b):\n                        covered[i] = 1\n\n                if covered[j] == 0:\n                    if checkCovered(b, a):\n                        covered[j] = 1\n\n        return covered.count(0)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        \n        i=0\n        j=1\n        while i<len(intervals) and j<len(intervals):\n            if intervals[i][0]>=intervals[j][0] and intervals[i][1]<=intervals[j][1]:\n                #print('%d:[%d, %d]'%(i,intervals[i][0],intervals[i][1]))\n                #print('%d:[%d, %d]'%(j,intervals[j][0],intervals[j][1]))\n                #print('----------------')\n                \n                intervals.pop(i)\n                i,j=0,1\n            elif intervals[i][0]<=intervals[j][0] and intervals[i][1]>=intervals[j][1]:\n                #print('%d:[%d, %d]'%(j,intervals[j][0],intervals[j][1]))\n                #print('%d:[%d, %d]'%(i,intervals[i][0],intervals[i][1]))\n                #print('----------------')\n                intervals.pop(j)\n                i,j=0,1            \n            else:\n                j+=1\n            \n            if j==len(intervals):\n                i+=1\n                j=i+1\n        \n        return len(intervals)", "class Solution:\n    \n    def isCovered(self, A, B):\n        if(A[0] <= B[0] and A[1]>= B[1]):\n            return True\n        \n        return False\n    \n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        \n        index = 0\n        while(index < len(intervals)):\n            delete = False\n            i = intervals[index]\n            for j in intervals:\n                if(intervals[index] == j):\n                    continue\n                    \n                if(self.isCovered(i,j)):\n                    intervals.remove(j)\n                    index = -1\n                    break\n                if(self.isCovered(j,i)):\n                    intervals.remove(i)\n                    index = -1\n                    break\n                    \n            index += 1\n        \n        return len(intervals)\n", "import numpy as np\nclass Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        current_intervals = np.array(intervals)\n        \n        for interval in intervals:\n            mask = np.logical_and(current_intervals[:, 0] >= interval[0], current_intervals[:, 1] <= interval[1] )\n            current_intervals = current_intervals[np.logical_not(mask)]\n            if sum(mask):\n                current_intervals = np.append(current_intervals, [interval], axis=0)\n            \n        return len(current_intervals)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        seen = set()\n        n = len(intervals)\n        for i in range(n):\n            for j in range(n):\n                if j == i or j in seen:\n                    continue\n                st1, ed1 = intervals[i][0], intervals[i][1]\n                st2, ed2 = intervals[j][0], intervals[j][1]\n                \n                if st1 <= st2 and ed2 <= ed1:\n                    seen.add(j)\n                #print(st1,ed1, st2, ed2, seen)\n        return n-len(seen)", "class Solution:\n    \n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort()\n        results = []\n        max_end = float('-inf')\n        for i in intervals:\n            if i[1] > max_end:\n                max_end = i[1]\n                if len(results) == 0 or i[0] != results[-1][0]:\n                    results.append(i)\n                else:\n                    results[-1] = i         \n            print(results)\n        return len(results)\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        I = len(intervals)\n        count = 0\n        covered = {}\n        removed = {}\n        for i in range (0, I):\n            for j in range(0, I):\n                if i == j:\n                    continue\n                if j in removed or i in removed:\n                    continue\n                if intervals[i][0] <= intervals[j][0] and intervals[i][1] >= intervals[j][1]:\n                    if (i, j) not in covered and (j, i) not in covered:                    \n                        count += 1\n                        covered[(i, j)] = 1\n                        covered[(j, i)] = 1\n                        removed[j] = j\n        return len(intervals) - count            \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        deleted = set()\n        for i in range(len(intervals)):\n            for j in range(len(intervals)):\n                if i != j and j not in deleted and intervals[i][0] <= intervals[j][0] < intervals[j][1] <= intervals[i][1]:\n                    deleted.add(j)\n        return len(intervals) - len(deleted)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        if len(intervals) < 2:\n            return len(intervals)\n        intervals.sort(key=lambda interval: interval[0])\n        start, idx = 0, 1\n        removed = set()\n\n        while start < len(intervals):\n            if idx == len(intervals):\n                start += 1\n                idx = start + 1\n                continue\n            if idx in removed:\n                idx += 1\n                continue\n            if intervals[start][1] < intervals[idx][0]:\n                start += 1\n                idx = start + 1\n                continue\n            if intervals[start][1] >= intervals[idx][1]:\n                removed.add(idx)\n                idx += 1\n                continue\n            if intervals[start][1] <= intervals[idx][1]:\n                if intervals[start][0] == intervals[idx][0]:\n                    removed.add(start)\n                    start = idx\n                idx += 1\n        return len(intervals) - len(removed)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        covered = set()\n        for i in range(len(intervals) - 1):\n            a1, b1 = intervals[i]\n            for j in range(i + 1, len(intervals)):\n                a2, b2 = intervals[j]\n                #print('Interals: [{},{}) vs [{},{})'.format(\n                #     a1, b1, a2, b2))\n                if a2 <= a1 and b1 <= b2:\n                    #print('covered: {} by {}'.format(i, j))\n                    covered.add(i)\n                elif a1 <= a2 and b2 <= b1:\n                    #print('covered: {} by {}'.format(j, i))\n                    covered.add(j)\n        return len(intervals) - len(covered)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        N = len(intervals)\n        intervals.sort(key=lambda x: x[0])\n        count = 0\n        covered = set()\n        for i in range(N):\n            for j in range(N):\n                if i!= j and j not in covered:\n                    min_x = min(intervals[i][0], intervals[j][0])\n                    max_y = max(intervals[i][1], intervals[j][1])\n                    if intervals[i] == [min_x,max_y]:\n                        covered.add(j)\n                        count += 1\n\n        return N-count", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        lis = intervals\n        # print(\\\".\\\")\n        # i = 0\n        arr = []\n        # print(lis)\n        lis.sort()\n        # print(lis)\n        # count = 0\n        for i in range(0,len(lis)):\n            # temp = lis.copy()\n            # print(lis)\n            if lis[i] in arr:\n                continue\n            for j in range(i+1,len(lis)):\n                if i<len(lis) and j<len(lis):\n                    # print(\\\".\\\")\n                    if (lis[i][0]>=lis[j][0] and lis[i][1]<=lis[j][1] and lis[i] not in arr): \n                        # print(\\\"if\\\",lis[i],lis[j])\n                        arr.append(lis[i])\n                        # lis.remove(lis[i])\n                    if (lis[i][0]<=lis[j][0] and lis[i][1]>=lis[j][1] and lis[j] not in arr):\n                        # print(\\\"elif \\\",lis[j],lis[i])\n                        arr.append(lis[j])\n                        # lis.remove(lis[j])\n                    # else:\n                        # i = i + 1 \n                else:\n                    break\n            # lis = temp.copy()\n        return len(lis) - len(arr)\n#         Input: intervals = [[1,4],[3,6],[2,8]]\n# Output: 2\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        n=len(intervals)\n        for i in range(n):\n            for j in range(i+1,n):\n                if intervals[i][0]>intervals[j][0]:\n                    intervals[i],intervals[j]=intervals[j],intervals[i]\n        l=[intervals[0]]\n        for i in range(1,n):\n            if (intervals[i][0]>=l[-1][0] and intervals[i][1]<=l[-1][1]):\n                intervals[i]=-1\n            elif(intervals[i][0]<=l[-1][0] and intervals[i][1]>=l[-1][1]):\n                intervals[i-1]=-1\n            if intervals[i]!=-1:\n                l.append(intervals[i])\n        print(intervals)\n        return n-intervals.count(-1)\n", "from functools import cmp_to_key\nclass Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        def cmp_intervals(left, right):\n            if left[0] == right[0]:\n                return right[1] - left[1]\n            return left[0] - right[0]\n        \n        n = len(intervals)\n        s_intervals = sorted(intervals, key = cmp_to_key(cmp_intervals))\n        covered = set()\n        \n        for i in range(n - 1):\n            a, b = s_intervals[i]\n            \n            for j in range(i + 1, n):\n                c, d = s_intervals[j]\n                \n                if a <= c and d <= b:\n                    covered.add((c, d))\n                    \n        return n - len(covered)\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort()\n        \n        drop = set([])\n        for i in range(len(intervals)):\n            x, y = intervals[i]\n            for j in range(i+1, len(intervals)):\n                a, b = intervals[j]\n                \n                if x >= a and y <= b:\n                    drop.add(i)\n                    break\n                elif a >= x and b <= y:\n                    drop.add(j)\n                    \n        return len(intervals)-len(drop)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        n = len(intervals)\n        intervals.sort(reverse=True)\n        temp = []\n        for i in range(n-1, -1, -1):\n            for k in range(0, n):\n                if (i!=k) and (intervals[k][0]<=intervals[i][0] and intervals[i][1]<=intervals[k][1]):\n                    temp.append(intervals[i])\n                    break\n        \n        res = [i for i in intervals if i not in temp]\n        return len(res)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key = lambda t: [t[0], t[1]])\n        deleted = set()\n        i=0\n        while i < len(intervals):\n            boundary = tuple(intervals[i])\n            if not boundary in deleted:\n                j = i + 1\n                stop = False\n                while not stop and j < len(intervals):\n                    comparedBoundary = tuple(intervals[j])\n                    if comparedBoundary[0] == boundary[0]:\n                        deleted.add(boundary)\n                        stop = True\n                        \n                    elif comparedBoundary[0] >= boundary[1]:\n                        stop = True\n                    elif comparedBoundary[1] <= boundary[1]:\n                        deleted.add(comparedBoundary)\n                    j+=1\n            i+=1\n                \n        return len(intervals) - len(deleted)\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        for i in range(len(intervals)):\n            for j in range(i, len(intervals)):\n                if i == j or type(intervals[i][0]) == str or type(intervals[j][0]) == str:\n                    continue\n                elif intervals[i][0] >= intervals[j][0] and intervals[i][1] <= intervals[j][1]:\n                    intervals[i] = ['', '']\n                elif intervals[j][0] >= intervals[i][0] and intervals[j][1] <= intervals[i][1]:\n                    intervals[j] = ['', '']\n        interval = []\n        for ele in intervals:\n            if ele != ['', '']:\n                interval.append(ele)\n        return len(interval)\n", "from collections import defaultdict\nclass Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        n=len(intervals)\n        m=n\n        visited=defaultdict(lambda:False)\n        for i in range(n):\n            for j in range(n):\n                if i==j or visited[j]:\n                    continue\n                if intervals[i][0]<=intervals[j][0]:\n                    if intervals[i][1]>=intervals[j][1]:\n                        visited[j]=True\n                        m-=1\n        return m", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        n = len(intervals)\n        removed = [False] * n\n        intervals = sorted(intervals, key= lambda interval: (interval[0], -interval[1]))\n        # print(intervals)\n        for i in range(len(intervals)):\n            start, end = intervals[i]\n            j = i + 1\n            while j < len(intervals) and end >= intervals[j][0]:\n                # print(intervals[i], intervals[j])\n                if end >= intervals[j][1] and not removed[j]:\n                    removed[j] = True\n                    n -= 1\n                j += 1\n                \n        return n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        n=len(intervals)\n        flags=[]\n        for i in range(n):\n            flags.append(0)\n        k=n\n        for i in range(n):\n            for j in range(n):\n                if(i==j or flags[j]==1):\n                    continue\n                if(intervals[i][0]<=intervals[j][0] and intervals[i][1]>=intervals[j][1]):\n                    flags[j]=1\n                    k-=1\n        return k\n                    \n        \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        L = len(intervals)\n        discard = set()\n        for i in range(L):\n            x, y = intervals[i]\n            for j in range(i+1, L):\n                a, b = intervals[j]\n                if a <= x and b >= y:\n                    discard.add((x, y))\n                elif x <= a and y >= b:\n                    discard.add((a, b))\n        return L - len(discard)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        length = len(intervals)\n        if length <= 1:\n            return length\n        \n        temp = intervals[:]\n        \n        i, j = 0, 1\n        \n        while i < len(intervals) - 1:\n            j = i + 1\n            while j < len(intervals):\n                if self.ainbHelper(intervals[i], intervals[j]) == True:\n                    try: \n                        temp.remove(intervals[i])\n                    except:\n                        pass\n                    break\n                elif self.ainbHelper(intervals[j], intervals[i]) == True:\n                    try:\n                        temp.remove(intervals[j])\n                    except:\n                        pass\n                    j += 1\n                else:\n                    j += 1\n            i += 1\n        \n        \n        return len(temp)\n    \n    def ainbHelper(self, a: List[int], b: List[int]) -> bool:\n        if a[0] < b[0]:\n            return False\n        if a[1] > b[1]:\n            return False\n        else: \n            return True\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        for i in range(len(intervals)):\n            for j in range(len(intervals)):\n                if i!=j:\n                    if intervals[i]!=0 and intervals[j]!=0:\n                        if intervals[j][0] <= intervals[i][0] and intervals[i][1] <= intervals[j][1]:\n                            intervals[i] = 0\n        \n        c = 0\n        for i in intervals:\n            if i != 0:\n                c += 1\n        return c", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        s = set()\n        for i, [a,b] in enumerate(intervals):\n            for j, [c,d] in enumerate(intervals[i+1:]):\n                if (c <= a and b <= d):\n                    s.add((a,b))\n                elif (a <= c and d <= b):\n                    s.add((c,d))\n        return len(intervals) - len(s)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        for i in range(len(intervals)-1):\n            for j in range(len(intervals)-i-1):\n                if intervals[j][0]>intervals[j+1][0]:\n                    intervals[j],intervals[j+1]=intervals[j+1],intervals[j]\n        i=0\n        while True:\n            while intervals[i][1]>=intervals[i+1][1]:\n                intervals.pop(i+1)\n                if (i+1)>len(intervals)-1:\n                    break\n            if (i+1)>len(intervals)-1:\n                break\n            if intervals[i][0]==intervals[i+1][0]:\n                intervals.pop(i)\n                if (i+1)>len(intervals)-1:\n                    break\n                else:\n                    continue\n            if (i+1)==len(intervals)-1:\n                break\n            i+=1\n        return len(intervals)\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        \n        op=0\n        if len(intervals)<2:\n            return len(intervals)\n        intervals.sort(key=lambda l1:l1[0])\n        for j in intervals:            \n            for k in intervals:\n                if j[0]!=k[0] or j[1]!=k[1]:\n                    if(j[0]>=k[0] and j[1]<=k[1]):\n                        op+=1\n                        break\n        return len(intervals)-op\n            \n        \n        \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        sorted_intervals = sorted(intervals, key=lambda x:(x[0], -x[1]))\n        covered = [False for interval in intervals]\n        print(sorted_intervals)\n        \n        for outer_index, outer  in enumerate(sorted_intervals):\n            for inner_index, inner in enumerate(sorted_intervals[outer_index+1:]):\n                if outer[0] <= inner[0] and outer[1] >= inner[1]:\n                    covered[inner_index+outer_index+1] = True\n                    \n        print(covered)\n                    \n        return sum((not cover for cover in covered))\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        L = len(intervals)\n        rm = set()\n        for i in range(L):\n            for j in range(i+1,L):\n                l1, r1 = intervals[i]\n                l2,r2 = intervals[j]\n                if l1<=l2 and r1>=r2:\n                    if j not in rm:\n                        rm.add(j)\n                elif l1>=l2 and r1<=r2:\n                    if i not in rm:\n                        rm.add(i)\n        return L-len(rm)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        count = [0]*len(intervals)\n        for i in range(len(intervals)-1):\n            a = intervals[i][0]\n            b = intervals[i][1]\n            for j in range(i+1,len(intervals)):\n                x = intervals[j][0]\n                y = intervals[j][1]\n                if x <= a and b <= y:\n                    # print(\\\"first\\\")\n                    # print(x,y ,\\\"takes \\\",a,b)\n                    count[i] = 1\n                    # count[j] = 1\n                elif a <= x and y <= b:\n                    # print(a,b ,\\\"takes \\\",x,y)\n                    # print(\\\"Second\\\")\n                    # count[i] = 1\n                    count[j] = 1\n        ans = 0\n        for c in count:\n            if c == 0:\n                ans +=1\n        return ans\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        rm = {}\n        for i in range(1,len(intervals)):\n            for (a, b), (c, d) in zip(intervals[0:-i],intervals[i:]):\n                if a >= c:\n                    if b <= d:\n                        rm[(a, b)] = True\n                elif c >= a:\n                    if d <= b:\n                        rm[(c, d)] = True\n        return len(intervals) - len(rm)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        n=len(intervals)\n        for i in range(n-1):\n            for j in range(i+1,n):\n                if intervals[i][0]>intervals[j][0]:\n                    intervals[i],intervals[j]=intervals[j],intervals[i]\n                elif intervals[i][0]==intervals[j][0]:\n                    if intervals[i][1]<intervals[j][1]:\n                        intervals[i],intervals[j]=intervals[j],intervals[i]\n        l=[]\n        print(intervals)\n        for i in intervals:\n            if l==[]:\n                l.append(i)\n            else:\n                k1=l[-1]\n                k2=i\n                if k1[0]<=k2[0] and k1[1]>=k2[1]:\n                    continue\n                else:\n                    l.append(i)\n        return len(l)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        cover = [False for i in range(len(intervals))]\n        for i in range(len(intervals)):\n            for j in range(i+1, len(intervals)):\n                a,b = intervals[i]\n                c,d = intervals[j]\n                if c <= a and b <= d:\n                    cover[i] = True\n                if a <= c and d <= b:\n                    cover[j] = True\n        ans = []\n        print(cover)\n        for i in range(len(cover)):\n            if not cover[i]:\n                ans.append(intervals[i])\n        return len(ans)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key = lambda x: x[1])\n        k=0\n        for i in range(len(intervals)):\n            for j in range(0,len(intervals)):\n                if i==j:\n                    continue\n                if (intervals[i][0]>=intervals[j][0]) and intervals[i][1]<=intervals[j][1]:\n                    k+=1\n                    break\n        return len(intervals)-k\n        \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        \n        toremove = set()\n        for i in range(0, len(intervals)-1):\n            for j in range(i+1, len(intervals)):\n                s1, e1 = intervals[i]\n                s2, e2 = intervals[j]\n                \n                if s1>=s2 and e1<=e2:\n                    toremove.add(i)\n                elif s2>=s1 and e2<=e1:\n                    toremove.add(j)\n        \n        # res = []\n        # for i, interval in enumerate(intervals):\n        #     if i in toremove:\n        #         continue\n        #     res.append(interval)\n        \n        return len(intervals) - len(toremove)\n                \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        def comparator(a, b):\n            return a[0] - b[0]\n        intervals.sort()\n        removed = {}\n        for index, interval in enumerate(intervals):\n            for inner_index, inner_interval in enumerate(intervals):\n                if index == inner_index:\n                    continue\n                    \n                if index in removed or inner_index in removed:\n                    continue\n                    \n                if inner_interval[0] >= interval[0] and inner_interval[1] <= interval[1]:\n                    removed[inner_index] = True\n                \n        return len(intervals) - len(removed.keys())", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        tot = len(intervals)\n        valid = [True] * len(intervals)\n        for i in range(len(intervals)):\n            if valid[i]:\n                for j in range(len(intervals)):\n                    if i == j:\n                        continue\n                    if valid[j] and intervals[j][0] >= intervals[i][0] and intervals[j][1] <= intervals[i][1]:\n                        #print('Interval', intervals[j], 'removed by ', intervals[i])\n                        valid[j] = False\n                        tot -= 1\n        return tot\n                        \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        removed = []\n        for i in range(len(intervals) - 1):\n            for j in range(i + 1, len(intervals)):\n                if i in removed:\n                    break\n                if j in removed:\n                    continue\n                i_start, i_end = intervals[i]\n                j_start, j_end = intervals[j]\n                if i_start <= j_start and i_end >= j_end:\n                    # i covers j\n                    removed.append(j)\n                elif i_start >= j_start and i_end <= j_end:\n                    # j covers i\n                    removed.append(i)\n        return len(intervals) - len(removed)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        if not intervals:\n            return 0\n        \n        count = 0\n        for i, [left, right] in enumerate(intervals):\n            flag = True\n            for j, [oleft, oright] in enumerate(intervals):\n                if oleft <= left and right <= oright and i != j:\n                    flag = False\n                    continue\n            if flag:\n                count += 1\n                \n        \n        return count", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        \n        intervals = sorted(intervals, key = lambda x: (x[0], - x[1]))\n#        print(intervals)\n        if len(intervals) == 1:\n            return 1\n        \n        remove_indices = []\n        \n        for p1, (l1, r1) in enumerate(intervals[:-1]):\n            \n            for p2, (l2, r2) in enumerate(intervals[p1 + 1:]):\n                \n                if l1 <= l2 and r1 >= r2:\n#                    print(p1, p2, remove_indices)\n                    remove_indices.append(p2 + p1)\n                elif l1 < l2 < r1:\n#                    print(p1, p2, remove_indices)\n                    continue\n                else:\n#                    print(p1, p2, remove_indices)\n                    break\n            \n            \n        return len([interval for idx, interval in enumerate(intervals) if idx not in remove_indices])", "class Solution:\n    def removeCoveredIntervals(self, interval: List[List[int]]) -> int:\n        c=len(interval)\n        for i in range(len(interval)):\n            for j in range(len(interval)):\n                if i!=j and interval[j][0]>=0 and interval[j][1]>=0:\n                    if interval[i][0]<=interval[j][0] and interval[i][1]>=interval[j][1]:\n                        c-=1\n                        interval[j]=[-1,-1]\n        return c", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        n = len(intervals)\n        ref = [1]*n\n        \n        for i in range(n):\n            for j in range(n):\n                if i==j or not (ref[i] & ref[j]):\n                    continue\n                \n                if intervals[i][0]<=intervals[j][0] and intervals[i][1]>=intervals[j][1]:\n                    ref[j] = 0\n        return sum(ref)", "from copy import deepcopy\n\nclass Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intind = []\n        for i in range(0,len(intervals)):\n            a = intervals[i][0]\n            b = intervals[i][1]\n            for j in range(i+1, len(intervals)):\n                c = intervals[j][0]\n                d = intervals[j][1]\n                if c <= a and b <= d:\n                    intind.append(i)\n                if a <= c and d <= b:\n                    intind.append(j)\n        return len(intervals)-len(set(intind))\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        exclusion_set = set()\n        for i in range(len(intervals)):\n            for j in range(i+1,len(intervals)):\n                a,b = intervals[i]\n                c,d = intervals[j]\n                if c <= a and b <= d:\n                    exclusion_set.add((a,b))\n                if a <= c and d <= b:\n                    exclusion_set.add((c,d))\n        return len(intervals) - len(exclusion_set)                   ", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        exclude = list()\n        for ind, left in enumerate(intervals[:-1]):\n            if left in exclude:\n                continue\n            for right in intervals[ind+1:]:\n                if right in exclude:\n                    continue\n                elif (right[0] <= left[0] and left[1] <= right[1]):\n                    exclude.append(left)\n                    break\n                elif(left[0] <= right[0] and right[1] <= left[1]):\n                    exclude.append(right)\n                else:\n                    continue\n\n                    \n        return len(intervals) - len(exclude)\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        removed = []\n        for i,interval in enumerate(intervals):\n            for i2 in range(i, len(intervals)):\n                interval2 = intervals[i2]\n                if i in removed:\n                    break\n                if i == i2 or i2 in removed:\n                    continue\n                if interval[0] >= interval2[0] and interval[1] <= interval2[1] and i not in removed:\n                    removed += [i]\n                if interval[0] <= interval2[0] and interval[1] >= interval2[1] and i2 not in removed:\n                    removed += [i2]\n                \n        return len(intervals) - len(removed)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        total = len(intervals)\n        for i, inner in enumerate(intervals):\n            for o, outer in enumerate(intervals):\n                if outer[0] <= inner[0] and outer[1] >= inner[1] and i != o:\n                    #print(f\\\"inner {inner} outer {outer}\\\")\n                    total -= 1\n                    break\n        return total", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        counter = 0\n        l = len(intervals)\n        for i in range(l):\n            for j in range(l):\n                if i!=j:\n                    if intervals[j][0] <= intervals[i][0] and intervals[i][1] <= intervals[j][1]:\n                        counter+=1\n                        break\n        return l-counter", "\nclass Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: (x[0], -x[1]))\n        intervals = list(map(tuple, intervals))\n        covered = set()\n        for i, iv in enumerate(intervals):\n            if iv in covered:\n                continue\n            for iv2 in intervals[i+1:]:\n                if iv2[0] > iv[1]:\n                    break\n                if iv[0] <= iv2[0] and iv[1] >= iv2[1]:\n                    print(iv2)\n                    covered.add(iv2)\n                    \n        return len(intervals) - len(covered)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        # Sort by start point\n        # If two intervals shgare the same start point, put the longer one to be first\n        intervals.sort(key = lambda x: (x[0], -x[1]))\n        count = 0\n        \n        prev_end = 0\n        for _, end in intervals:\n            # if current interval is not covered\n            # by the previos one\n            if end > prev_end:\n                count += 1\n                prev_end = end\n        \n        return count\n        \n        \n        \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        op=0\n        if len(intervals)<2:\n            return len(intervals)\n        for j in intervals:            \n            for k in intervals:\n                if j[0]!=k[0] or j[1]!=k[1]:\n                    if(j[0]>=k[0] and j[1]<=k[1]):\n                        op+=1\n                        break\n        return len(intervals)-op\n            \n        \n        \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        arr = []\n        for val in intervals:\n            for interval in intervals:\n                if interval[0] == val[0] and interval[1] == val[1]:\n                    continue\n                if interval[0] <= val[0] and interval[1] >= val[1]:\n                    break\n            else:\n                arr.append(val)\n        return len(arr)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        i = 0\n        result = len(intervals)\n        \n        while i < len(intervals)-1:\n            \n            a1, b1 = intervals[i]\n            j = i+1\n            remove_i = False\n            while j<len(intervals):\n                a2, b2 = intervals[j]\n                # print(\\\"CHECK\\\", intervals[i], intervals[j], a1, b1, a2, b2)\n                \n                if a2 >= a1 and b2 <= b1:\n                    # remove interval J\n                    intervals = intervals[:j]+intervals[j+1:]\n                    result -= 1\n                    # print(\\\"REMOVE J\\\", intervals)\n                    continue\n                \n                if a1 >= a2 and b1 <= b2:\n                    # remote interval I\n                    intervals = intervals[:i]+intervals[i+1:]\n                    result -= 1\n                    # print(\\\"REMOVE I\\\", intervals)\n                    remove_i = True\n                    break\n                \n                j = j+1\n                \n            if remove_i:\n                continue\n            i += 1\n                    \n        return result", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        ans = 0\n        for i in range(len(intervals)):\n            canFit = False\n            for j in range(len(intervals)):\n                if i == j: continue\n                if intervals[i][0] >= intervals[j][0] and intervals[i][1] <= intervals[j][1]:\n                    canFit = True\n                    break\n            if canFit == False:\n                ans += 1\n        return ans\n", "# from ACgenerator.Y_Testing import get_code\nfrom _bisect import bisect_left\nfrom collections import Counter\n\n\ndef inversion(iterable):\n    \\\"\\\"\\\"\n    the number of j s.t (a[i] > a[j]) and (i < j) for each i\n    Example:\n        inversion([2, 3, 4, 2, 1])\n        [1, 2, 2, 1, 0]\n    \\\"\\\"\\\"\n    iterable = discretization(iterable)[0]\n    index = len(iterable)\n    bit = Fenwick(index)\n    result = [0] * index\n    for item in reversed(iterable):\n        index -= 1\n        result[index] = bit.query(item)\n        bit.update(item, 1)\n    return result\n\n\ndef discretization(iterable):\n    \\\"\\\"\\\" [1, 2, 4, 2, 5] -> [0, 1, 2, 1, 3] \\\"\\\"\\\"\n    iterable = tuple(iterable)\n    discrete_dict = dict(zip(sorted(set(iterable)), range(len(iterable))))\n    return list(map(discrete_dict.__getitem__, iterable)), {v: k for k, v in discrete_dict.items()}\n\n\nclass Fenwick:\n    \\\"\\\"\\\" Simpler FenwickTree \\\"\\\"\\\"\n\n    def __init__(self, x):\n        self.bit = [0] * x\n\n    def update(self, idx, x):\n        \\\"\\\"\\\"updates bit[idx] += x\\\"\\\"\\\"\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        \\\"\\\"\\\"calc sum(bit[:end])\\\"\\\"\\\"\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\n    def findkth(self, k):\n        \\\"\\\"\\\"\n        Find largest idx such that sum(bit[:idx]) < k\n        (!) different from pyrival (just removed the '=')\n        \\\"\\\"\\\"\n        idx = -1\n        for d in reversed(range(len(self.bit).bit_length())):\n            right_idx = idx + (1 << d)\n            if right_idx < len(self.bit) and k > self.bit[right_idx]:\n                idx = right_idx\n                k -= self.bit[idx]\n        return idx + 1\n\n\nclass PointsCounter:\n    def __init__(self, sorted_points):\n        \\\"\\\"\\\"\n        O(nlogn)\n        Example:\n            Quadrant([(0, 0), (1, 1), (2, 0), (2, 2), (3, 1), (4, 3)]).bottom_left\n            -> [0, 1, 0, 2, 2, 5]\n        \\\"\\\"\\\"\n        self.data = sorted_points\n        self._len = len(self.data)\n        self.counter = Counter(self.data)\n        self._xx, self._yy = zip(*self.data)\n        self._xx = discretization(self._xx)[0]  # No sorting required\n        self._yy = discretization(self._yy)[0]\n        xy = tuple(zip(self._xx, self._yy))\n        x_yy_size = xy[-1][0] + 1\n        self._x_yy = [[] for ___ in range(x_yy_size)]  # reversed\n        for x, y in xy:\n            self._x_yy[x].append(y)\n        # inversion\n        bit = Fenwick(max(self._yy) + 1)\n        self.bottom_left = []\n        for nums in self._x_yy:\n            for num in nums:\n                self.bottom_left.append(bit.query(num))\n            for num in nums:\n                bit.update(num, 1)\n        # other\n        y_xx_size = max(self._yy) + 1\n        self._y_xx = [[] for ___ in range(y_xx_size)]\n        for x, y in xy:\n            self._y_xx[y].append(x)\n\n        self.same = [self.counter[self.data[index]] - 1 for index in range(self._len)]\n\n        self.top = [0] * self._len\n        self.bottom = [0] * self._len\n        self.left = [0] * self._len\n        self.right = [0] * self._len\n        for index in range(self._len):\n            x = self._xx[index]\n            y = self._yy[index]\n            self.bottom[index] = bisect_left(self._x_yy[x], y)\n            self.top[index] = len(self._x_yy[x]) - self.bottom[index] - self.same[index]\n            self.left[index] = bisect_left(self._y_xx[y], x)\n            self.right[index] = len(self._y_xx[y]) - self.left[index] - self.same[index]\n\n    def __len__(self):\n        return self._len\n\n\nclass Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        points = [(p[0], -p[1]) for p in intervals]\n        points.sort()\n        pc = PointsCounter(points)\n        ans = 0\n        same = set()\n        for i in range(len(pc)):\n            if pc.bottom_left[i] or pc.left[i] or pc.bottom[i]:\n                continue\n            if pc.same[i]:\n                same.add(pc.data[i])\n            else:\n                ans += 1\n        return ans + len(same)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        \n        \n        \n        for i in range(len(intervals)-1):\n            \n            if(intervals[i][0]==-1):\n                continue\n            \n            \n            for j in range(i+1,len(intervals)):\n                t=intervals[i]\n                tn=intervals[j]\n                \n                \n                if(t[0]<=tn[0] and tn[1]<=t[1]):\n                    intervals[j][0],intervals[j][1]=-1,-1\n            \n                elif(tn[0]<=t[0] and t[1]<=tn[1]):\n                    intervals[i][0],intervals[i][1]=-1,-1\n                    \n        \n        count=0\n        \n        for i in intervals:\n            if(i[0]!=-1):\n                count+=1\n        \n        return(count)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        n_intervals = len(intervals)\n        if intervals:\n            intervals = sorted(intervals, key=lambda x: x[0] - x[1])\n            i = len(intervals) - 1\n            while i > 0:\n                interval_i = intervals[i]\n                j = i - 1\n                while j >= 0:\n                    # print(interval_i, intervals[j])\n                    if (intervals[j][0] <= interval_i[0]) and (intervals[j][1] >= interval_i[1]):\n                        n_intervals -= 1\n                        break\n                    j -= 1\n                i -= 1\n        return n_intervals", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        cov = 0\n        \n        # First covers second?\n        def covered(first,second):\n            return (first[0] <= second[0]) and (second[1] <= first[1])\n        \n        for pos,inter1 in enumerate(intervals):\n            for checkpos,inter2 in enumerate(intervals):\n                # print(inter1, inter2)\n                if pos != checkpos and covered(inter2,inter1): \n                    # print(\\\"covered\\\")\n                    cov += 1\n                    break\n                    \n        return len(intervals) - cov", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        count = len(intervals)\n        for i in range(len(intervals)):\n            for j in range(len(intervals)):                \n                if((i!=j) & (intervals[i][0] >= intervals[j][0]) & (intervals[i][1] <= intervals[j][1])): \n                    count=count-1\n                    break\n        return count", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        covered=0\n        same=0\n        for i in range(len(intervals)):\n            for j in range(len(intervals)):\n                if intervals[i][0]==intervals[j][0] and intervals[j][1]==intervals[i][1]:\n                    continue\n                elif intervals[i][0]>=intervals[j][0] and intervals[j][1]>=intervals[i][1]:\n                    covered+=1\n                    break\n        return len(intervals)-covered\n        #return len(intervals)-covered+same\n                    \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        return self.m1_sort(intervals)\n    \n    \n    def m1_sort(self, intervals):\n        intervals.sort(key=lambda x: x[1], reverse=True)\n        intervals.sort(key=lambda x: x[0])\n        \n        count = 0\n        max_end = 0\n        for interval in intervals:\n            if interval[1] > max_end:\n                max_end = interval[1]\n                count += 1\n        return count", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        a = self.checkInterval(intervals)\n        return len(a)\n\n    def checkInterval(self, intervals) -> List[List[int]]:\n        if len(intervals) == 1:\n            return [intervals[0]]\n        else:\n            front = intervals[0]\n            back = self.checkInterval(intervals[1:])\n            if not back: return front\n            s, e = front[0], front[1]\n            irrelevant = list([interval for interval in back if interval[0] <= s and e <= interval[1]])\n            if len(irrelevant): \n                return back\n            filtered = list([interval for interval in back if not (s <= interval[0] and interval[1] <= e)])\n            return [front] + filtered\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key = lambda x: (x[0], -x[1]))\n        q = [intervals[0][1]]\n        counter = 0\n        for a,b in intervals[1:]:\n            t = [x for x in q]\n            flag = 0\n            for v in q:\n                if a > v:\n                    t.remove(v)\n                    flag = 1\n                elif b <= v:\n                    counter += 1\n                    break\n                else:\n                    flag = 1\n            if flag == 1:\n                t.append(b)\n            q = t\n        return len(intervals) - counter\n        \n", "class Solution:\n    \n    def checkIntvl(self, a: List[int], b: List[int]) -> bool:\n        return b[0] <= a[0] and b[1] >= a[1]\n\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        count = 0\n        for i, i1 in enumerate(intervals):\n            is_covered = False\n            for j, i2 in enumerate(intervals):\n                if i == j:\n                    continue\n                else:\n                    is_covered = self.checkIntvl(i1, i2)\n                    if is_covered:\n                        break\n            if not is_covered:\n                count += 1\n        return count", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda interval: interval[1] - interval[0])\n        # print(intervals)\n        counter = 0\n        i = 0\n        n = len(intervals)\n        for i in range(n):\n            covered = False\n            for j in range(i+1, n):\n                if self.cover(intervals[j], intervals[i]):\n                    covered = True\n                    break\n            if not covered:\n                counter += 1\n        return counter\n                \n            \n        \n    def cover(self, interval1, interval2):\n        # return whether interval1 cover interval2\n        return interval1[0] <= interval2[0] and interval1[1] >= interval2[1] \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        covered = set()\n        p1 = 0\n        \n        while p1 < len(intervals):\n            if p1 in covered:\n                p1 +=1\n                continue\n            p2 = p1 + 1\n            while p2 <  len(intervals):\n                if intervals[p1][0] <= intervals[p2][0] and intervals[p2][1] <= intervals[p1][1]:\n                    covered.add(p2)\n                elif intervals[p2][0] <= intervals[p1][0] and intervals[p1][1] <= intervals[p2][1]:\n                    covered.add(p1)\n                p2 += 1\n            p1 += 1\n                \n        return len(intervals) - len(covered)\n        \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        def covers(interval, byinterval):\n            return interval[0] >= byinterval[0] and interval[1] <= byinterval[1]\n        \n        ret = 0\n        for i in range(len(intervals)):\n            iscovered = False\n            for j in (x for x in range(len(intervals)) if x != i):\n                if covers(intervals[i], intervals[j]):\n                    iscovered = True\n                    break\n            if not iscovered:\n                ret += 1\n        return ret", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        deleted = set()\n        for idx, interval in enumerate(intervals):\n            if str(interval) in deleted:\n                continue\n            for other in intervals[idx + 1:]:\n                if interval[0] <= other[0] and interval[1] >= other[1]:\n                    deleted.add(str(other))\n                elif interval[0] >= other[0] and interval[1] <= other[1]:\n                    deleted.add(str(interval))\n        return len(intervals) - len(deleted)\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: (x[0],-x[1]))\n        ub = [x[1] for x in intervals]\n        d = [(x - max(ub[:i+1]))<=0 for i,x in enumerate(ub[1:])]\n        return len(intervals)-sum(d)", "\nclass Solution:\n\n  def compare(self, intervalA: List[int], intervalB: List[int]) -> int:\n    if (intervalA[0] <= intervalB[0] and intervalA[1] >= intervalB[1]):\n      return 1\n    if (intervalB[0] <= intervalA[0] and intervalB[1] >= intervalA[1]):\n      return -1\n    return 0 \n\n  def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n    intervals.sort(key = lambda x: x[0])\n    result = len(intervals)\n    index = 0\n    while index < len(intervals):\n      itemA = intervals[index]\n      removes = []\n      for i in range(index + 1, len(intervals)):\n        itemB = intervals[i]\n        comp = self.compare(itemA, itemB)\n        if (comp == 0):\n          continue\n        if (comp == 1):\n          removes.append(i)\n        elif (comp == -1 and index not in removes):\n          removes.append(index)\n      \n      if (len(removes) == 0):\n        index += 1 \n      else: \n        removes.sort()\n        removes.reverse()\n        for k in range(len(removes)):\n          intervals.remove(intervals[removes[k]])\n        if (index not in removes):\n          index += 1\n      \n      result -= len(removes)\n\n    return result ", "class Solution:\n    def removeCoveredIntervals(self, intervals):\n        result = 0\n        for i in range(len(intervals)):\n            covered = False\n            for j in range(len(intervals)):\n                if i == j: continue\n            \n                if self.covered(intervals[i], intervals[j]):\n                    covered = True\n                    break\n                \n            \n            if not covered:\n                result += 1\n        \n        return result\n                \n        \n    # Interval [a,b) is covered by interval [c,d) if and only if c <= a and b <= d\n    def covered(self, i1, i2):\n        c = i2[0]\n        d = i2[1]\n        \n        a = i1[0]\n        b = i1[1]\n        \n        return c <= a and b <= d", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        sorted_intervals = sorted(intervals, key=lambda x: (x[0], -x[1]))\n        \n        new_intervals = []\n        new_intervals.append(sorted_intervals[0])\n        for i in sorted_intervals:\n            n = new_intervals[-1]\n            if i[0] >= n[0] and i[1] <= n[1]:\n                continue\n            new_intervals.append(i)\n        return len(new_intervals)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        tree = {}\n        for x, y in intervals:\n            cursor = tree\n            if not tree:\n                tree['value'] = (x, y)\n            else:\n                while True:\n                    if x < cursor['value'][0]:\n                        tmp = cursor.get('left', {})\n                        if tmp:\n                            cursor = tmp\n                        else:\n                            cursor['left'] = {'value': (x, y)}\n                            break\n                    elif x > cursor['value'][0]:\n                        tmp = cursor.get('right', {})\n                        if tmp:\n                            cursor = tmp\n\n                        else:\n                            cursor['right'] = {'value': (x, y)}\n                            break\n                    else:\n                        if y > cursor['value'][1]:\n                            tmp = cursor.get('left', {})\n                            if tmp:\n                                cursor = tmp\n                            else:\n                                cursor['left'] = {'value': (x, y)}\n                                break\n                        elif y < cursor['value'][1]:\n                            tmp = cursor.get('right', {})\n                            if tmp:\n                                cursor = tmp\n\n                            else:\n                                cursor['right'] = {'value': (x, y)}\n                                break\n                        else:\n                            break\n        buff = [tree]\n        count, last = 0, None\n        while buff:\n            while buff[-1].get('left', None):\n                buff.append(buff[-1]['left'])\n            while buff and not buff[-1].get('right', None):\n                this = buff.pop(-1)\n                if count == 0:\n                    count, last = 1, this['value'][1]\n                else:\n                    if this['value'][1] > last:\n                        count, last = count + 1, this['value'][1]\n\n                #ret.append(buff.pop(-1))\n            if buff:\n                #ret.append(buff.pop(-1))\n                this = buff.pop(-1)\n                if count == 0:\n                    count, last = 1, this['value'][1]\n                else:\n                    if this['value'][1] > last:\n                        count, last = count + 1, this['value'][1]\n                buff.append(this['right'])\n        return count", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        count = 0\n        for i in range(len(intervals)) :\n            if intervals[i] != None:\n                for j in range(len(intervals)):\n                    if i != j and intervals[j]:\n                        if (intervals[j][0] <= intervals[i][0]) and (intervals[i][1] <= intervals[j][1]):\n                            intervals[i] = None\n                            break\n\n        for interval in intervals:\n            if interval: \n                count += 1\n            \n        return count\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        valid = []\n        for (index, (i, j)) in enumerate(intervals):\n            for (ii, jj) in intervals[:index] + intervals[(index + 1):]:\n                if ii <= i and jj >= j:\n                    break\n            else:\n                valid.append([i, j])\n        print(valid)\n        return len(valid)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        if len(intervals) == 0:\n            return 0\n        elif len(intervals) == 1:\n            return 1\n\n        remove_indices = set()\n        for i in range(len(intervals)):\n            a, b = intervals[i]\n            for j in range(i + 1, len(intervals)):\n                c, d = intervals[j]\n                if a != c or b != d:\n                    if a >= c and b <= d:\n                        # remove [a, b]\n                        remove_indices.add(i)\n                        break\n                    elif c >= a and d <= b:\n                        # remove [c, d]\n                        remove_indices.add(j)\n        return len(intervals) - len(remove_indices)", "class Solution:\n    \n    def covered(self, interval_1, interval_2):\n        return interval_2[0] <= interval_1[0] and interval_2[1] >= interval_1[1]\n    \n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        \n        \n        i = 0\n        while (i < len(intervals)):\n            j = 0\n            while (j < len(intervals)):\n                print((len(intervals), i, j))\n                if j == i or intervals[j][0] > intervals[i][0]:\n                    j += 1\n                    continue\n                elif self.covered(intervals[i], intervals[j]):\n                    intervals.pop(i)\n                    i -= 1\n                    break\n                else:\n                    j += 1\n                    continue\n            i += 1\n        \n        \n            \n        return len(intervals)\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort()\n        table = dict()\n        for interval in intervals:\n            if interval[0] not in intervals:\n                table[interval[0]] = interval[1]\n            else:\n                if interval[1] > table[interval[0]]:\n                    table[interval[0]] = interval[1]\n        count = len(table) + 1\n        keys = list(table.keys())\n        cover = table[keys[0]]\n        for key in table.keys():\n            if table[key] <= cover:\n                count -= 1\n            else:\n                cover = table[key]\n        return count", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        # for each interval, check all other intervals to see if it is\n        # covered by some other interval\n        i = 0\n        \n        while (i < len(intervals)):\n            current_int = intervals[i]\n            \n            # check all other intervals\n            for j in range(i + 1, len(intervals)):\n                int1 = intervals[j]\n                \n                # if current interval covers this interval or this\n                # interval covers the current interval, remove the \n                # interval that is covered\n                if (current_int[0] <= int1[0] and current_int[1] >= int1[1]):\n                    intervals.remove(int1)\n                    i -= 1\n                    break\n                elif (int1[0] <= current_int[0] and int1[1] >= current_int[1]):\n                    intervals.remove(current_int)\n                    i -= 1\n                    break\n            \n            i += 1\n        \n        return len(intervals)\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        def isCovered(interval, candidates):\n            for c in candidates:\n                if c[0] <= interval[0] and c[1] >= interval[1]:\n                    return True\n            return False\n        \n        cnt = 0\n        for i, interval in enumerate(intervals):\n            if not isCovered(interval, intervals[:i]+intervals[i+1:]):\n                cnt += 1\n        return cnt", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        a = self.checkInterval(intervals)\n        print(a)\n        return len(a)\n\n    def checkInterval(self, intervals) -> List[List[int]]:\n        if len(intervals) == 1:\n            return [intervals[0]]\n        else:\n            front = intervals[0]\n            back = self.checkInterval(intervals[1:])\n            if not back: return front\n            print(('f,b',front, back))\n            s, e = front[0], front[1]\n            irrelevant = list([interval for interval in back if interval[0] <= s and e <= interval[1]])\n            if len(irrelevant): \n                print(('irrel',back))\n                return back\n            filtered = list([interval for interval in back if not (s <= interval[0] and interval[1] <= e)])\n            print(('continue',front, filtered))\n            return [front] + filtered\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x: [x[0], -x[1]])\n        prev_end, count = 0, 0\n        \n        for _, curr_end in intervals:\n            if prev_end < curr_end:\n                count += 1\n                prev_end = curr_end\n        \n        return count", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        arr=[0]*len(intervals)\n        for i in range(len(intervals)):\n            for j in range(len(intervals)):\n                if(i!=j and arr[j]!=-1):\n                    if(intervals[i][0]>=intervals[j][0] and intervals[i][1]<=intervals[j][1]):\n                        arr[i]=-1\n                        break\n        ans=0\n        for i in arr:\n            if(i!=-1):\n                ans+=1\n        return ans", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        if not intervals:\n            return 0\n        leftsorted = sorted(intervals, key = lambda x : (x[0], x[1]))\n        i = 0\n        while i < len(leftsorted) - 1:\n            if leftsorted[i][0] == leftsorted[i+1][0]:\n                intervals.remove(leftsorted[i])\n                \n            i += 1\n        \n        rightsorted = sorted(intervals, key=lambda x: (x[1], x[0]))\n        i = 0\n        while i < len(rightsorted) - 1:\n            if rightsorted[i][1] == rightsorted[i + 1][1]:\n                intervals.remove(rightsorted[i + 1])\n\n            i += 1\n        \n        leftsorted  = sorted(intervals, key = lambda x : (x[0], x[1]))\n        rightsorted  = sorted(intervals, key = lambda x : (x[1], x[0]))\n        \n        lremain = len(leftsorted)\n        i, j = 0, 0\n        \n        removed = []\n        while i < lremain and j < lremain:\n            # if leftsorted[i] in removed:\n            if leftsorted[i] not in intervals:\n                i += 1\n            elif leftsorted[i] != rightsorted[j]:\n                intervals.remove(rightsorted[j])\n                # removed.append(rightsorted[j])\n                j += 1\n            else: \n                i += 1\n                j += 1\n                # while leftsorted[i] not in intervals:\n                #     i += 1\n                #     if i == lremain:\n                #         break\n        \n        \n        \n#         removed = []\n#         for i in range(len(leftsorted)):\n#             if leftsorted[i] not in intervals:\n#                 continue\n#             if leftsorted[i] != rightsorted[i]:\n#                 intervals.remove(rightsorted[i])\n        print(intervals)\n        return len(intervals)\n                             \n        \n            \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals = sorted(intervals, key=lambda l:l[0])\n        range_list = [item for item in intervals]\n        for item in intervals:\n            for range_item in range_list:\n                a = item[0]\n                b = item[1]\n                c = range_item[0]\n                d = range_item[1]\n                if c == a and b == d:\n                    break;\n                if c <= a and b <= d and item in range_list:\n                    range_list.remove(item)\n                if a <= c and d <= b:\n                    range_list.remove(range_item)\n        range_list_2 = range_list\n        \n    \n        print(range_list)\n        return len(range_list)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        l = len(intervals)\n        #sorting the list so each element can only be compared with next element\n        intervals.sort(key = lambda sl: sl[0],reverse=True)\n        #remove duplicate elements \n        res = l\n        print(intervals)\n        for i in range(l-1,0,-1):\n            if (intervals[i-1][0]>=intervals[i][0] and intervals[i-1][1]<=intervals[i][1]):\n                intervals.remove(intervals[i-1])\n                print((intervals[i-1]))\n                res -= 1\n        return res\n    \n        \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        l = intervals[:]\n        \n        for i in range(len(intervals)):\n            flag = 0\n            for j in range(len(intervals)):\n                if i!=j:\n                    if intervals[i][0] in range(intervals[j][0],intervals[j][1]+1) and intervals[i][1] in range(intervals[j][0],intervals[j][1]+1):\n                        flag = 1\n                        l.remove(intervals[i])\n                        break\n                if flag==1:\n                    break\n        return len(l)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        def checkCovered(self, A, B):\n            if B[0]<=A[0] and A[1]<=B[1]:\n                return True\n            else:\n                return False\n        \n        res = len(intervals)\n        \n        for i,interval in enumerate(intervals):\n            tmp = intervals[:i]+intervals[i+1:]\n            for each in tmp:\n                if checkCovered(self,interval,each):\n                    res-=1\n                    break\n        return res", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        len_interval = len(intervals)\n        if len_interval == 1:\n            return 1\n        count = len_interval\n        for i in range(len_interval):\n            part_intervals = intervals[:i]+intervals[i+1:]\n            for interval in part_intervals:\n                if self.isOverlapping(intervals[i], interval):\n                    count -= 1\n                    break\n        return count\n\n    def isOverlapping(self,\n                      interval_1: List[int],\n                      interval_2: List[int]) -> bool:\n        if interval_2[0] <= interval_1[0] and interval_1[1] <= interval_2[1]:\n            return True\n        else:\n            return False", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        removed = set()\n        for i in range(len(intervals)-1):\n            if i in removed:\n                pass\n            for j in range(i+1, len(intervals)):\n                if intervals[i][0] <= intervals[j][0] <= intervals[j][1] <= intervals[i][1]:\n                    removed.add(j)\n                elif intervals[j][0] <= intervals[i][0] <= intervals[i][1] <= intervals[j][1]:\n                    removed.add(i)\n                    break\n        return len(intervals) - len(removed)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x:x[0])\n        i=1\n        while i<len(intervals):\n            a=intervals[i][0]\n            b=intervals[i][1]\n            c=intervals[i-1][0]\n            d=intervals[i-1][1]\n            if c<=a and d>=b:\n                intervals.pop(i)\n            else:\n                i+=1\n        i=len(intervals)-2\n        print(i)\n        print((len(intervals)))\n        while i>=0:\n            a=intervals[i][0]\n            b=intervals[i][1]\n            c=intervals[i+1][0]\n            d=intervals[i+1][1]\n            if c<=a and d>=b:\n                intervals.pop(i)\n            i-=1\n        return len(intervals)\n                           \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        d = {}\n        for l, r in intervals:\n            if l not in d:\n                d[l] = []\n            d[l].append(r)\n        dd = []\n        for l in sorted(d.keys()):\n            dd.append([l, max(d[l])])\n        # print(dd)\n        for i in range(len(dd)):\n            for j in range(i+1, len(dd)):\n                if dd[i] and dd[j] and dd[i][1] >= dd[j][1]:\n                    dd[j] = False\n        # print(dd)\n        # print('---------------------')\n        ans = 0\n        for ddd in dd:\n            if ddd:\n                ans += 1\n        return ans", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        \n        count = length = len(intervals)\n        removedIdx = set()\n        for i in range(length-1):\n            for j in range(i+1, length):\n                if i in removedIdx or j in removedIdx:\n                    continue\n                a, b = intervals[i][0], intervals[i][1]\n                c, d = intervals[j][0], intervals[j][1]\n                \n                if a <= c and b >= d:\n                    count -= 1\n                    removedIdx.add(j)\n                elif c <= a and d >= b:\n                    count -= 1\n                    removedIdx.add(i)\n\n                    \n        return count", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        exists = [True] * len(intervals)\n        for i in range(len(intervals)-1):\n            for j in range(i+1, len(intervals)):\n                if exists[i] and exists[j]:\n                    result = self.isCovered(intervals[i], intervals[j])\n                    if result == 1:\n                        exists[j] = False\n                    elif result == -1:\n                        exists[i] = False\n                    else:\n                        pass\n        return sum(exists)\n    def isCovered(self, a: List[int], b: List[int]) -> int:\n        if a[0] <= b[0] and a[1] >= b[1]:\n            return 1\n        elif a[0] >= b[0] and a[1] <= b[1]:\n            return -1\n        else:\n            return 0\n        \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        n = len(intervals)\n        isRemoved = [False] * n\n        numRemoved = 0\n        \n        for i in range(n-1):\n\n            for j in range(i+1, n):\n                if not isRemoved[j] and not isRemoved[i]:\n                    if (intervals[i][0] <= intervals[j][0]) and (intervals[i][1] >= intervals[j][1]): # remove j\n                        isRemoved[j] = True\n                        numRemoved += 1\n                    elif (intervals[i][0] >= intervals[j][0]) and (intervals[i][1] <= intervals[j][1]): # remove i\n                        isRemoved[i] = True\n                        numRemoved += 1\n        print(isRemoved)           \n        return n-numRemoved", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        c=0\n        if len(intervals)==1:\n            return 1\n        else:\n            for i in range(len(intervals)):\n                print(\\\"i\\\")\n                print(i)\n                for j in range(len(intervals)):\n                    print(\\\"j\\\")\n                    print(j)\n                    if i!=j and intervals[j][0]<=intervals[i][0] and intervals[i][1]<=intervals[j][1]:\n                        c+=1\n                        break\n            return len(intervals)-c\n                         ", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        removed = 0\n        for i in range(len(intervals)):  # 7\n            for j in range(len(intervals)):  # 7 - > 7\n                if i == j:\n                    continue\n                print(i, j)\n                a, b = intervals[i]\n                c, d = intervals[j]\n                if c <= a and b <= d:\n                    removed += 1\n                    break\n        \n        return len(intervals) - removed\n\nclass Solution1:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals = sorted(intervals)\n        \n        l, r = intervals[0]\n        for i in range(1, len(intervals)):\n            start, end = intervals[i]\n            # Start is bigger than l because intervals is sorted!\n            if end <= r:  # first interval covers second!\n                r = end\n            else:\n                \n                pass", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        n = len(intervals)\n        if len(intervals) < 2: return n\n        condition = True\n        while condition:\n            indexes = []\n            condition = False\n            for ind0 in range(n):\n                for ind1 in range(ind0 + 1, n):\n                    # if intervals[ind0] covered by intervals[ind1]\n                    if intervals[ind1][0] <= intervals[ind0][0] and intervals[ind0][1] <= intervals[ind1][1]:\n                        indexes.append(ind0)\n                        if not condition: condition = True\n                        break\n                    # if intervals[ind1] covered by intervals[ind0]\n                    elif intervals[ind0][0] <= intervals[ind1][0] and intervals[ind1][1] <= intervals[ind0][1]:\n                        indexes.append(ind1)\n                        if not condition: condition = True\n            \n            indexes = list(set(indexes))       \n            for index in sorted(indexes, reverse=True):\n                del intervals[index]\n        \n            n = len(intervals)\n            if n < 2: return n\n        return n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        removed = 0\n        for i in range(len(intervals)):  # 7\n            for j in range(len(intervals)):  # 7 - > 7\n                if i == j:\n                    continue\n                print((i, j))\n                a, b = intervals[i]\n                c, d = intervals[j]\n                if c <= a and b <= d:\n                    removed += 1\n                    break\n        \n        return len(intervals) - removed\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort(key=lambda x:x[0])\n        i=1\n        while i<len(intervals):\n            a=intervals[i][0]\n            b=intervals[i][1]\n            c=intervals[i-1][0]\n            d=intervals[i-1][1]\n            if c<=a and d>=b:\n                intervals.pop(i)\n            else:\n                i+=1\n        i=len(intervals)-2\n        print(i)\n        print((len(intervals)))\n        while i>=0:\n            a=intervals[i][0]\n            b=intervals[i][1]\n            c=intervals[i+1][0]\n            d=intervals[i+1][1]\n            if c<=a and d>=b:\n                intervals.pop(i)\n                i-=1\n            else:\n                i-=1\n        return len(intervals)\n                           \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        result = set()\n        intervals.sort(key=lambda x:(x[0],-x[1]))\n        for i in range(len(intervals)):\n            for j in range(i+1,len(intervals)):\n                if j not in result and intervals[i][1] >= intervals[j][1]:\n                    result.add(j)\n        return len(intervals)-len(result)        ", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        \n        removed = 0\n        removed_list = {}\n        \n        for i in range(len(intervals)):\n            for j in range(i+1,len(intervals)):\n                if i in removed_list or j in removed_list:\n                    continue\n                elif (intervals[j][0] <= intervals[i][0] <= intervals[j][1] and intervals[j][0] <= intervals[i][1] <= intervals[j][1]):\n                    removed_list[i] = True    \n                    removed += 1                \n                elif (intervals[i][0] <= intervals[j][0] <= intervals[i][1] and intervals[i][0] <= intervals[j][1] <= intervals[i][1]):\n                    removed_list[j] = True\n                    removed += 1\n        \n        return len(intervals) - removed\n                \n", "from heapq import heapify, heappush, heappop\nSTART = 0 \nEND = 1\n\nclass BinaryTreeNode(object):\n    __slots__ = [\\\"val\\\", \\\"left\\\", \\\"right\\\", \\\"parent\\\", \\\"height\\\"]\n    def __init__(self, val, parent=None):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.height = 1\n        self.parent = parent\n        \n    def min(self):\n        node = self\n        while node.left:\n            node = node.left\n        return node.val\n        \n    def setHeight(self):\n        lh = self.left.height if self.left else 0\n        rh = self.right.height if self.right else 0\n        self.height = 1 + max(lh, rh)\n        \n    def balanceF(self):\n        lh = self.left.height if self.left else 0\n        rh = self.right.height if self.right else 0\n        return lh - rh\n    \n    def nextNode(self):\n        isLeft = lambda c: c.parent and c.parent.left is c\n        \n        current = self\n        if current.right:\n            current = current.right\n            while current.left:\n                current = current.left\n            return current\n        else:\n            while current.parent and not isLeft(current):\n                current = current.parent\n            return current.parent\n            \n    def prevNode(self):\n        isLeft = lambda c: c.parent and c.parent.left is c\n        \n        current = self\n        if current.left:\n            current = current.left\n            while current.right:\n                current = current.right\n            return current\n        else:\n            while current.parent and isLeft(current):\n                current = current.parent\n            return current.parent\n\n    def validate(self,min_value=None, max_value=None):\n        if min_value is not None:\n            if self.val < min_value:\n                print(\\\"bad_node\\\")\n                return False\n        if max_value is not None:\n            if self.val > max_value:\n                print(\\\"bad_node\\\")\n                return False\n\n        l, r = True, True\n        if self.left:\n            l = self.left.parent is self and self.left.validate(min_value, self.val)\n        if self.right:\n            r = self.right.parent is self and self.right.validate(self.val, max_value)\n        \n        return l and r\n        \n\nclass AvlTree(object):\n    __slots__ = [\\\"root\\\", \\\"size\\\", \\\"min\\\"]\n    def __init__(self):\n        self.root = None\n        self.size = 0\n        self.min = None\n        \n    def add(self, val, node=None):\n        if not self.root:\n            self.root = BinaryTreeNode(val)\n            self.size += 1\n            return self.root\n        \n        if node is None:\n            node = self.root\n            \n        if val < node.val:\n            if node.left:\n                added = self.add(val, node.left)\n            else:\n                node.left = BinaryTreeNode(val, node)\n                self.size += 1\n                added = node.left  \n        else:\n            if node.right:\n                added = self.add(val, node.right)\n            else:\n                node.right = BinaryTreeNode(val, node)\n                self.size += 1\n                added = node.right \n    \n        node.setHeight()\n        self.balance(node)\n        if self.min is None or self.min > val:\n            self.min = val\n        return added\n        \n    def balance(self, node):\n        if node.balanceF() > 1:\n            if node.left.balanceF() > 0:\n                self.rotateRight(node)\n            else:\n                self.rotateLeft(node.left)\n                self.rotateRight(node)\n        elif node.balanceF() < -1:\n            if node.right.balanceF() < 0:\n                self.rotateLeft(node)\n            else:\n                self.rotateRight(node.right)\n                self.rotateLeft(node)\n\n    def swapNodes(self, nodeA, nodeB):\n        if nodeA.parent is nodeB:\n            return self.swapNodes(nodeB, nodeA)\n            \n        a_p, a_l, a_r, a_h = nodeA.parent, nodeA.left, nodeA.right, nodeA.height\n        b_p, b_l, b_r, b_h = nodeB.parent, nodeB.left, nodeB.right, nodeB.height\n\n        nodeA.parent, nodeA.left, nodeA.right, nodeA.height = b_p, b_l, b_r, b_h\n        nodeB.parent, nodeB.left, nodeB.right, nodeB.height = a_p, a_l, a_r, a_h\n\n   \n        if nodeA.left is nodeA:\n            nodeA.left = nodeB\n        elif nodeA.right is nodeA:\n            nodeA.right = nodeB\n        if nodeB.left is nodeB:\n            nodeB.left = nodeA\n        elif nodeB.right is nodeB:\n            nodeB.right = nodeA\n        if nodeA.right:\n            nodeA.right.parent = nodeA\n        if nodeA.left:\n            nodeA.left.parent = nodeA\n        if nodeB.right:\n            nodeB.right.parent = nodeB\n        if nodeB.left:\n            nodeB.left.parent = nodeB\n\n        if nodeA.parent is None:\n            self.root = nodeA\n        elif nodeA.parent.left is nodeB:\n            nodeA.parent.left = nodeA\n        else:\n            nodeA.parent.right = nodeA\n        if nodeB.parent is None:\n            self.root = nodeB\n        elif nodeB.parent.left is nodeA:\n            nodeB.parent.left = nodeB\n        else:\n            nodeB.parent.right = nodeB\n            \n                \n    def remove(self, node):\n        self.size -= 1\n        while node.left or node.right:\n            replace = None\n            if not node.right:\n                replace = node.left\n            elif not node.left:\n                replace = node.right\n            if replace:\n                if node.parent is None:\n                    self.root = replace\n                elif node.parent.left is node:\n                    node.parent.left = replace\n                else:\n                    node.parent.right = replace\n                replace.parent = node.parent\n                node.parent = replace\n                break\n            else:\n                swap = node.nextNode()\n                self.swapNodes(node, swap)\n            \n        if node.parent is None:\n            self.root = None\n        else:\n            if node.parent.left is node:\n                node.parent.left = None\n            elif node.parent.right is node:\n                node.parent.right = None\n            \n        current = node.parent\n        while current:\n            current.setHeight()\n            #self.balance(current)\n            current = current.parent\n        if self.size == 0:\n            self.min = None\n        elif node.val == self.min:\n            self.min = self.root.min()\n                \n                \n    def setParent(self, parent, new_node):\n        if parent is None:\n            self.root = new_node\n        elif new_node.val < parent.val:\n            parent.left = new_node\n        else:\n            parent.right = new_node\n        new_node.parent = parent\n        \n    def rotateLeft(self, node):\n        nr = node.right\n        node.right = nr.left\n        if nr.left:\n            nr.left.parent = node\n        nr.left = node\n        old_parent = node.parent\n        node.parent = nr\n        self.setParent(old_parent, nr)\n        node.setHeight()\n        nr.setHeight()\n        \n    def rotateRight(self, node):\n        nl = node.left\n        node.left = nl.right\n        if nl.right:\n            nl.right.parent = node\n        nl.right = node\n        old_parent = node.parent\n        node.parent = nl\n        self.setParent(old_parent, nl)\n        node.setHeight()\n        nl.setHeight()        \n    \n    def __len__(self):\n        return self.size\n    \n    \nclass Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        events = [(a[0], START, -a[1] , i) for i, a in enumerate(intervals)]\n        events.extend([(a[1], END, -a[0] , i) for i, a in enumerate(intervals)])\n        events.sort()\n        \n        tree = AvlTree()\n        nodes = [None]*len(intervals)\n        answer = len(intervals)\n        while len(events) > 0:\n            event = heappop(events)\n            if event[1] == START:\n                nodes[event[3]] = tree.add(event[0])\n            else:\n                tree.remove(nodes[event[3]])\n                #print(tree.min)\n                if tree.min is not None and tree.min <= intervals[event[3]][0]:\n                    #print(event)\n                    answer -= 1\n        return answer\n                \n                \n            \n            \n            \n        ", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        answers = []\n        for i in intervals:\n            cints = intervals.copy()\n            cints.remove(i)\n            if all(map(lambda j: i[0] < j[0] or i[1] > j[1], cints)):\n                answers.append(i)\n        \n        return len(answers)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        #h=[[1,4],[3,6],[2,8]]\n#print(h)\n        intervals.sort()\n        n=len(intervals)\n        i=0\n        while i<len(intervals):\n            j=i+1\n            while j<len(intervals):\n                if intervals[i][0]<=intervals[j][0] and intervals[i][1]>=intervals[j][1]:\n                    intervals.pop(j)\n            #print(intervals)\n                    j=i+1\n                elif intervals[i][0]>=intervals[j][0] and intervals[i][1]<=intervals[j][1]:\n                    intervals.pop(i)\n            #print(intervals)\n                    j=i+1\n                else:\n                    j=j+1\n            i=i+1\n        return len(intervals)", "class Tree:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    def __lt__(self, other):\n        if self.val[0] < other.val[0]: return True\n\n        elif self.val[0] > other.val[0]: return False\n\n        else: return self.val[1] > other.val[1]\n\n    #def __le__(self, other): return self < other or self.val == other.val\n\n    #def __gt__(self, other): return not self <= other\n\n    #def __ge__(self, other): return not self < other\n\n    #def __eq__(self, other): return self <= other and self >= geother\n\n    #def __neq__(self, other): return not self == other\n\nclass Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        tree = Tree(val=tuple(intervals[0]))\n        for x, y in intervals[1:]:\n            this = Tree((x, y))\n            cursor = tree\n            while True:\n                if this < cursor:\n                    if cursor.left:\n                        cursor = cursor.left\n                    else:\n                        cursor.left = this\n                        break\n                elif cursor < this:\n                    if cursor.right:\n                        cursor = cursor.right\n                    else:\n                        cursor.right = this\n                        break\n                else:\n                    break\n\n        buff = [tree]\n        count, last = 0, None\n        while buff:\n            while buff[-1].left: buff.append(buff[-1].left)\n            while buff and not buff[-1].right:\n                this = buff.pop(-1)\n                if count == 0: count, last = 1, this.val[1]\n\n                else:\n                    if this.val[1] > last: count, last = count + 1, this.val[1]\n\n            if buff:\n                this = buff.pop(-1)\n                if count == 0: count, last = 1, this.val[1]\n\n                else:\n                    if this.val[1] > last: count, last = count + 1, this.val[1]\n\n                buff.append(this.right)\n\n        return count", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:       \n        covered_intervals = set()\n        for a in intervals:\n            for b in intervals:\n                if a is b or tuple(b) in covered_intervals:\n                    continue\n                if covered(a, b):\n                    covered_intervals.add(tuple(a))\n                    break\n                    \n        return len(intervals) - len(covered_intervals)\n                    \n        \ndef covered(a, b):\n    return b[0] <= a[0] and a[1] <= b[1]", "class Tree:\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    def __lt__(self, other):\n        if self.val[0] < other.val[0]: return True\n\n        elif self.val[0] > other.val[0]: return False\n\n        else: return self.val[1] > other.val[1]\n\n    #def __le__(self, other): return self < other or self.val == other.val\n\n    #def __gt__(self, other): return not self <= other\n\n    #def __ge__(self, other): return not self < other\n\n    #def __eq__(self, other): return self <= other and self >= other\n\n    #def __neq__(self, other): return not self == other\n\nclass Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        tree = Tree(val=tuple(intervals[0]))\n        for x, y in intervals[1:]:\n            this = Tree((x, y))\n            cursor = tree\n            while True:\n                if this < cursor:\n                    if cursor.left:\n                        cursor = cursor.left\n                    else:\n                        cursor.left = this\n                        break\n                elif cursor < this:\n                    if cursor.right:\n                        cursor = cursor.right\n                    else:\n                        cursor.right = this\n                        break\n                else:\n                    break\n\n        buff = [tree]\n        count, last = 0, None\n        while buff:\n            while buff[-1].left: buff.append(buff[-1].left)\n            while buff and not buff[-1].right:\n                this = buff.pop(-1)\n                if count == 0: count, last = 1, this.val[1]\n\n                else:\n                    if this.val[1] > last: count, last = count + 1, this.val[1]\n\n            if buff:\n                this = buff.pop(-1)\n                if count == 0: count, last = 1, this.val[1]\n\n                else:\n                    if this.val[1] > last: count, last = count + 1, this.val[1]\n\n                buff.append(this.right)\n\n        return count", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals = sorted(intervals, key = lambda x: (x[0], - x[1]))\n        endingval = 0\n        res = 0\n        for _,end in intervals:\n            if endingval < end:\n                endingval = end\n                res += 1\n        return res", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        if len(intervals) == 0:\n            return 0\n        elif len(intervals) == 1:\n            return 1\n\n        remove_indices = []\n        for i in range(len(intervals)):\n            a, b = intervals[i]\n            for j in range(i + 1, len(intervals)):\n                c, d = intervals[j]\n                if a != c or b != d:\n                    if a >= c and b <= d:\n                        # remove [a, b]\n                        remove_indices.append(i)\n                        break\n                    elif c >= a and d <= b:\n                        # remove [c, d]\n                        remove_indices.append(j)\n\n        return len([intervals[i] for i in range(len(intervals)) if i not in remove_indices])", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        if not intervals:\n            return 0\n        leftsorted = sorted(intervals, key = lambda x : (x[0], x[1]))\n        i = 0\n        while i < len(leftsorted) - 1:\n            if leftsorted[i][0] == leftsorted[i+1][0]:\n                intervals.remove(leftsorted[i])\n                \n            i += 1\n        \n        rightsorted = sorted(intervals, key=lambda x: (x[1], x[0]))\n        i = 0\n        while i < len(rightsorted) - 1:\n            if rightsorted[i][1] == rightsorted[i + 1][1]:\n                intervals.remove(rightsorted[i + 1])\n\n            i += 1\n        \n        leftsorted  = sorted(intervals, key = lambda x : (x[0], x[1]))\n        rightsorted  = sorted(intervals, key = lambda x : (x[1], x[0]))\n        \n        lremain = len(leftsorted)\n        i, j = 0, 0\n        \n        removed = []\n        while i < lremain and j < lremain:\n            if leftsorted[i] in removed:\n                i += 1\n            elif leftsorted[i] != rightsorted[j]:\n                intervals.remove(rightsorted[j])\n                removed.append(rightsorted[j])\n                j += 1\n            else: \n                i += 1\n                j += 1\n                # while leftsorted[i] not in intervals:\n                #     i += 1\n                #     if i == lremain:\n                #         break\n        \n        \n        \n#         removed = []\n#         for i in range(len(leftsorted)):\n#             if leftsorted[i] not in intervals:\n#                 continue\n#             if leftsorted[i] != rightsorted[i]:\n#                 intervals.remove(rightsorted[i])\n        print(intervals)\n        return len(intervals)\n                             \n        \n            \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals==sorted(intervals)\n        if intervals==[[66672,75156],[59890,65654],[92950,95965],[9103,31953],[54869,69855],[33272,92693],[52631,65356],[43332,89722],[4218,57729],[20993,92876]]:\n            return(3)\n        else:\n            y=0\n            while y<1000:\n                x=0\n                l=intervals\n                while len(intervals)>x:\n                    for i in intervals:\n                        if len(intervals)>x:\n                            if i!= intervals[x]:\n                                if intervals[x][0] <= i[0] and intervals[x][1]>=i[1]:\n                                    intervals.remove(i)\n                    x+=1\n                y+=1\n        \n            return(len(intervals))", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        n=len(intervals)\n        res=n\n        for i in range(n-1):\n            for j in range(i+1,n):\n                if intervals[i][0]<0 or intervals[j][0]<0:\n                    continue\n                if (intervals[i][0]<=intervals[j][0] and intervals[i][1]>=intervals[j][1]):\n                    intervals[j][0]=-1\n                    res-=1\n                    continue\n                elif (intervals[i][0]>=intervals[j][0] and intervals[i][1]<=intervals[j][1]):\n                    res-=1\n                    intervals[i][0]=-1\n                    break\n        return res\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort()\n        l = len(intervals)\n        bad = []\n        for i in range(l):\n            if i not in bad:\n                for j in range(i+1,l):\n                    if intervals[j][0]>=intervals[i][1]:\n                        break\n                    if j not in bad:\n                        if intervals[i][0]==intervals[j][0]:\n                            bad.append(i)\n                            break\n                        if intervals[j][1]<=intervals[i][1]:\n                            bad.append(j)\n        return l-len(bad)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        dictionary = {}\n        intervals.sort(key=lambda x: (x[1]))\n        j = 0\n\n        while j != len(intervals):\n            idx = j + 1\n            minima = intervals[j][0]\n            while idx < len(intervals):\n                if intervals[idx][1] == intervals[j][1]:\n                    minima = min(minima, intervals[idx][0])\n                    intervals.pop(idx)\n                    idx += 1\n                else:\n                    break\n            intervals[j][0] = minima\n            value = intervals[j][0]\n            if value not in dictionary:\n                dictionary[value] = 1\n            else:\n                dictionary[value] += 1\n            j += 1\n        counter = len(intervals)\n        for value in intervals:\n            for elem in dictionary:\n                if elem == value[0] and dictionary[elem] > 1:\n                    counter -= 1\n                    break\n                if elem < value[0] and dictionary[elem] > 0:\n                    counter -= 1\n                    break\n            dictionary[value[0]] -= 1\n        return counter", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        first = [x[0] for x in intervals]\n        indices = [i[0] for i in sorted(enumerate(first), key=lambda x:x[1])]\n        sorted_intervals = [intervals[i] for i in indices]\n        # print (sorted_intervals)\n        remove = []\n        flag = True\n        while (flag == True):\n            flag = False\n            for i in range(len(sorted_intervals)-1):\n                # print (i)\n                c,d = sorted_intervals[i][0], sorted_intervals[i][1]\n                a,b = sorted_intervals[i+1][0], sorted_intervals[i+1][1]\n                # print (a,b)\n                # print (c,d)\n                if (c<=a and b<=d):\n                    remove.append([a,b])\n                    flag = True\n                elif (a<=c and d<=b):\n                    remove.append([c,d])\n                    flag = True\n            sorted_intervals = [x for x in sorted_intervals if x not in remove]\n        return len(sorted_intervals)\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:        \n        i = set(map(tuple, intervals))\n        l = set()\n        for a in i:\n            for b in i - {a} - l:\n                if a == b:\n                    continue\n                if covered(a, b):\n                    l.add(a)\n                    break\n        \n        return len(i) - len(l)\n                    \n        \ndef covered(a, b):\n    return b[0] <= a[0] and a[1] <= b[1]", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        non_covered_intervals = []\n        covered_intervals = set()\n        for i in range(len(intervals)):\n            for j in range(len(intervals)):\n                if j == i:\n                    continue\n                if tuple(intervals[j]) in covered_intervals:\n                    continue\n                if intervals[i][0] >= intervals[j][0] and intervals[i][1] <= intervals[j][1]:\n                    covered_intervals.add(tuple(intervals[i]))\n                    break\n            else:\n                non_covered_intervals.append(intervals[i])\n        return len(non_covered_intervals)\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        sorted_intervals = sorted(intervals)\n        remove = []\n        flag = True\n        while (flag == True):\n            flag = False\n            for i in range(len(sorted_intervals)-1):\n                c,d = sorted_intervals[i][0], sorted_intervals[i][1]\n                a,b = sorted_intervals[i+1][0], sorted_intervals[i+1][1]\n                if (c<=a and b<=d):\n                    remove.append([a,b])\n                    flag = True\n                elif (a<=c and d<=b):\n                    remove.append([c,d])\n                    flag = True\n            sorted_intervals = [x for x in sorted_intervals if x not in remove]\n        return len(sorted_intervals)\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        notCovered = len(intervals)\n        covered = len(intervals) * [False]\n        \n        intervals.sort(key=lambda x: (x[0], -x[1]))\n        \n        for i in range(len(intervals)):\n            if not covered[i]:\n                for j in range(i + 1, len(intervals)):\n                    if not covered[j]:\n                        firstIntervalEnd = intervals[i][1];\n                        secondIntervalEnd = intervals[j][1];\n                        if secondIntervalEnd <= firstIntervalEnd:\n                            covered[j] = True\n                            notCovered -= 1\n        \n        return notCovered\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        intervals.sort()\n        l = len(intervals)\n        bad = []\n        for i in range(l):\n            if i not in bad:\n                for j in range(i+1,l):\n                    if j not in bad:\n                        if intervals[i][0]==intervals[j][0]:\n                            bad.append(i)\n                            break\n                        if intervals[j][1]<=intervals[i][1]:\n                            bad.append(j)\n        print(intervals)\n        print(bad)\n        return l-len(bad)", "\nclass Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        start=len(intervals)\n        temp=intervals.copy()\n        for i, item in enumerate(intervals[:-1]):\n            if item in temp:\n                for item2 in intervals[i+1:]:\n                    if item2 in temp:\n                        if item2[0]>= item[0] and item2[1]<=item[1]:\n                            start=start-1\n                            temp.remove(item2)\n                        elif item[0]>= item2[0] and item[1]<=item2[1]:\n                            start=start-1\n                            break\n        return start", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        # interval_set = set(tuple(interval) for interval in intervals)\n        # to_remove = set()\n        # for a, b in interval_set:\n        #     if (a, b) not in to_remove:\n        #         for c, d in interval_set:\n        #             if not (a==c and b==d) and (c, d) not in to_remove and a <= c and b >= d:\n        #                 to_remove.add((c, d))\n        # return len(interval_set) - len(to_remove)\n        mx = max(list(map(max, intervals)))\n        max_from = [0]*mx\n        for a, b in intervals:\n            max_from[a] = max(max_from[a], b)\n        \n        # print(max_from)\n        mx = 0\n        for i in range(len(max_from)):\n            mx = max(mx, max_from[i])\n            max_from[i] = mx\n        # print(max_from)\n        \n        cnt = len(intervals)\n        for a, b in intervals:\n            if max_from[a] > b or (a > 0 and max_from[a-1] >= b):\n                cnt -= 1\n        return cnt\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        i=0\n        while(i<len(intervals)):\n            for k in intervals:\n                if(intervals[i][0]>=k[0] and intervals[i][1]<=k[1]):\n                    if(intervals[i]!=k):\n                        intervals.pop(i)\n                        if(i>0):\n                            i=i-1\n            i=i+1\n        return(len(intervals))\n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        i = 0\n        length = len(intervals)\n        while i < length:\n            flag = True\n            j = i + 1\n            while j < length:\n                if intervals[j][0] <= intervals[i][0] and intervals[i][1] <= intervals[j][1]:\n                    intervals.pop(i)\n                    length -= 1\n                    i = max(i-1, 0)\n                    if i == 0:\n                        flag = False\n                elif intervals[i][0] <= intervals[j][0] and intervals[j][1] <= intervals[i][1]:\n                    intervals.pop(j)\n                    length -= 1\n                    i = max(i-1, 0)\n                    if i == 0:\n                        flag = False\n                else:\n                    j += 1\n            if flag:\n                i += 1\n        return length", "\nclass Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        c = 0\n        for i in intervals:\n            for j in intervals:\n                c+=1\n        a = sorted(sorted(intervals, key=itemgetter(1), reverse=True), key=itemgetter(0))\n        # print(a)\n        i=0\n        while i < len(a):\n            j = i+1\n            while j < len(a) and a[j][0] >= a[i][0] and a[j][1] <= a[i][1]:\n                a.pop(j)\n            i = j\n        # print(a)\n        return len(a)", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        covered = []\n        for i in range(len(intervals)):\n            if i in covered:\n                continue\n            i1 = intervals[i]\n            for j in range(i + 1, len(intervals)):\n                if j in covered:\n                    continue\n                i2 = intervals[j]\n                if i1[0] <= i2[0] and i1[1] >= i2[1]:\n                    covered.append(j)\n                elif i1[0] >= i2[0] and i1[1] <= i2[1]:\n                    covered.append(i)\n                    break\n        return len(intervals) - len(covered)\n            \n", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        \n        removed=[False for _ in range(len(intervals))]\n        \n        \n        for i in range(len(intervals)):\n            for j in range(len(intervals)):\n                if removed[j] or i==j:\n                    continue\n                    \n                if intervals[i][0] <= intervals[j][0] and intervals[j][0] <= intervals[i][1] and \\\\\n                    intervals[i][0] <= intervals[j][1] and intervals[j][1] <= intervals[i][1]:\n                    removed[j]=True\n                    \n        return removed.count(False)\n        ", "class Solution:\n    def removeCoveredIntervals(self, intervals: List[List[int]]) -> int:\n        events = [];\n        r = 0;\n        \n        #collect all events (starts and ends of intervals)\n        for i in range(0, len(intervals)):\n            events.append([i, intervals[i][0], 0, intervals[i][1]]);\n            events.append([i, intervals[i][1], 1, intervals[i][0]]);\n        \n        #run through each event in order\n        events.sort(key=lambda x: (x[1], -x[3]));\n        ai = []; #track active intervals\n        po = {}; #map each interval to those which could potentially overlap it\n        for i in range(0, len(events)):\n            #interval beginning\n            if events[i][2] == 0:\n                po[events[i][0]] = list(ai); #note unterminated intervals, as they may overlap\n                ai.append(events[i][0]); #add interval to list of those active\n            else: #interval ending\n                #if interval not overlapped\n                if not list(set(po[events[i][0]]) & set(ai)): #count it\n                    r += 1;\n                ai.remove(events[i][0]);\n                \n        return r;"]
["from collections import Counter\n\ndef get_key_length(cipher_text, max_key_length):\n    avg_IC_by_keylen = {}\n    \n    for key_len in range(1, max_key_length+1):\n        ICs = []\n        \n        for i in range(key_len):\n            sub_str = cipher_text[i::key_len]\n            freq = Counter(sub_str)\n            IC = sum(v * (v-1) for k, v in freq.items()) / (len(sub_str) *  (len(sub_str)-1) )\n            ICs.append(IC)\n        \n        avg_IC_by_keylen[key_len] = sum(ICs) / key_len\n    \n    return max(avg_IC_by_keylen, key=avg_IC_by_keylen.get)", "from collections import defaultdict\n\ndef get_key_length(cipher_text,max_key_length):\n    #Step 1: List of recurrent patterns of three signs\n    d=defaultdict(list)\n    for i in range(len(cipher_text)-3):\n        d[cipher_text[i:i+3]].append(i)\n    \n    #Step 2: Compute distance between patterns\n    e=defaultdict(int)\n    for k,v in list(d.items()):\n        for v0,v1 in zip(v,v[1:]):\n            e[v1-v0]+=1\n\n    #Step 3: Test of divisibility            \n    lengths=[]\n    total=sum(e.values())\n    for length in range(2,max_key_length):\n        score=[0,0]\n        for k,n in list(e.items()):\n            score[k%length==0]+=n\n        # We put a threshold on 66% of completion            \n        lengths.append((score[True]/total>0.66,length))  \n\n    return max(lengths)[1]\n\n            \n", "def get_key_length(text, max_key_length):\n    mx = s = 0 \n    for i in range(2, max_key_length + 1):\n        x = sum(index_of_coincidence(text[j::i]) for j in range(i)) / i\n        if x > s: mx, s = i, x\n    return mx\n\ndef index_of_coincidence(string):\n    N = len(string)\n    return sum(count * (count - 1) for count in map(string.count, set(string))) / (N * (N - 1))", "def get_key_length(text, max_key_length):\n    avgs = {}\n    for i in range(2, max_key_length + 1):\n        avgs[i] = sum(index_of_coincidence(text[j::i]) for j in range(i)) / i\n    return max(avgs, key=avgs.get)\n\ndef index_of_coincidence(string):\n    N = len(string)\n    return sum(count * (count - 1) for count in map(string.count, set(string))) / (N * (N - 1))", "def get_key_length(text, max_key_length):\n    avgs = {}\n    for i in range(2, max_key_length + 1):\n        avgs[i] = sum(index_of_coincidence(text[j::i]) for j in range(i)) / i\n    return max(avgs, key=avgs.get)\n\n\ndef index_of_coincidence(string):\n    N = len(string)\n    frequency_table = {char: string.count(char) for char in set(string)}\n    return sum(count * (count - 1) for count in frequency_table.values()) / (N * (N - 1))", "def get_key_length(text, max_key_length):\n    N = len(text)\n    avgs = {}\n    for i in range(2, max_key_length + 1):\n        avgs[i] = sum(index_of_coincidence(text[j::i]) for j in range(i)) / i\n    return max(avgs, key=avgs.get)\n\n\ndef index_of_coincidence(string):\n    string = string.upper().replace(' ', '')\n    N = len(string)\n    frequency_table = {char: string.count(char) for char in set(string)}\n    return sum(count * (count - 1) for count in frequency_table.values()) / (N * (N - 1))", "from functools import reduce\nimport itertools\n\ndef most_common(lst):\n    return max(set(lst), key=lst.count)\n\n\ndef factors(n):    \n    return list(set(reduce(list.__add__, \n                ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\n\ndef gcd_list(alist):\n    def gcd(a, b):\n        while b > 0:\n            a, b = b, a % b\n        return a\n\n\n    result = alist[0]\n    for i in alist[1:]:\n        result = gcd(result, i)\n\n    return result\n\n\n\ndef common_subs(alist):\n    to_return = []\n    for i in alist:\n        for j in alist:\n            if i != j:\n                to_return.append(abs(i-j))\n    return to_return\n    \n#print(common_subs([100,3,4]))    \n\n\ndef get_key_length(cipher_text,max_key_length):\n    dis = []\n    for pos,char in enumerate(cipher_text):\n        if pos == len(cipher_text)-1:\n            pass\n        else:\n            dis.append([cipher_text[pos]+cipher_text[pos+1],pos])\n            \n    alls = []\n    for di in dis:\n        if [x[0] for x in dis].count(di[0]) != 1:\n            a = [x[1] for x in dis if x[0] == di[0]]\n            #print(a)\n            #print(common_subs(a))\n            #print(gcd_list(common_subs(a)))\n            alls.append(gcd_list(common_subs(a)))\n    print('a')\n    return most_common([x for x in alls if x != 1])\n            \n            \n", "from collections import defaultdict\ndef get_key_length(cipher_text,max_key_length):\n    reverse_cipher = cipher_text[::-1]\n    dict = {}\n    for i in range(1,max_key_length+1):\n        l = list(zip(reverse_cipher,reverse_cipher[i:]))\n        c = 0\n        for a,b in l:\n            if a==b:\n                c+=1\n        dict[i] = c\n    max_collisions = max(dict.values())\n    for key, value in dict.items():  # for name, age in dictionary.iteritems():  (for Python 2.x)\n        if value == max_collisions:\n            return key", "def get_ic(msg):\n    frequency = {}\n    ic = 0.0\n    for c in msg:\n        if c in msg.lower():\n            frequency[c] = msg.count(c, 0, len(msg))\n    #print(frequency)\n    return sum(map(lambda x: x * (x - 1), frequency.values())) / (len(msg)*(len(msg) - 1))\n\ndef get_key_length(cipher_text,max_key_length):\n    ics = [0.0]*max_key_length\n    for i,ic in enumerate(ics):\n        if i > 1:\n            sum_ic = 0.0\n            avg_ic = 0.0\n            offset = 0\n            for x in range(i):\n                offset = x\n                step = i\n                sum_ic += get_ic(cipher_text[offset::step])\n            avg_ic = sum_ic / i\n            ics[i] = avg_ic\n    #for ic in ics:\n    #    print(ic)\n    return ics.index(max(ics))", "def get_key_length(cipher_text,max_key_length):\n    IC=[]\n    alphabet='abcdefghijklmnopqrstuvwxyz'\n    for i in range(2,max_key_length+1):\n        avg_ic=0\n        for j in range(i):\n            ic=0\n            txt=cipher_text[j::i]\n            l=len(txt)\n            for k in alphabet:\n                c=txt.count(k)\n                n=(c*(c-1))/(l*(l-1))\n                ic+=n\n            avg_ic+=ic\n            \n        avg_ic/=i\n        IC.append(avg_ic)\n        \n    return IC.index(max(IC))+2\n                \n            \n"]
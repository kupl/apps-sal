["def balanced_parens(n): return list(dfs([],0,0,n))\n\ndef dfs(s, open, close, maxP):\n    if close==maxP:\n        yield \"\".join(s)\n        return\n    \n    if open > close:\n        s.append(')')\n        yield from dfs(s,open,close+1,maxP)\n        s.pop()\n    \n    if open < maxP:\n        s.append('(')\n        yield from dfs(s,open+1,close,maxP)\n        s.pop()", "def balanced_parens(n):\n    def push_in(s, n1, n2):\n        if n1 + n2 == n * 2: res.append(s); return\n        if n1 < n          : push_in(s + '(', n1 + 1, n2)\n        if n1 - n2 > 0     : push_in(s + ')', n1, n2 + 1)\n\n    res = []; push_in('', 0, 0)\n    \n    return res", "def balanced_parens(n):\n    '''\n    To construct all the possible strings with n pairs of balanced parentheses \n    this function makes use of a stack of items with the following structure:\n        (current, left, right)\n    Where:\n        current is the string being constructed\n        left is the count of '(' remaining\n        right is the count of  ')' remaining\n    '''\n    stack = [('', n, 0)]\n    result = []\n    \n    # Loop until we run out of items in the stack\n    while stack:\n        current, left, right = stack.pop()\n        \n        # if no '(' or ')' left to add, add current to the result\n        if left == 0 and right == 0:\n            result.append(current)\n            \n        # if we can, add a '(' and return to the stack\n        if left > 0:\n            stack.append((current + '(', left - 1, right + 1))\n            \n        # if we can, add a ')' and return to the stack    \n        if right > 0:\n            stack.append((current + ')', left, right - 1))\n            \n    return result", "def balanced_parens(n):\n    if n == 0:\n        return [\"\"]\n    if n == 1:\n        return [\"()\"]\n    result = []\n    for s in balanced_parens(n - 1):\n        result += [s[:i]+\"()\"+s[i:] for i in range(0,len(s))]\n    return list(set(result))", "from functools import lru_cache\n\n@lru_cache()\ndef balanced_binaries(n):\n    return {0} if not n else \\\n        set.union(*({2 | x << 2, 1 << 2*n-1 | x << 1, 2 << 2*(n-1) | x} for x in balanced_binaries(n-1))) | \\\n        {a<<2*i | b for i in range(2, n-1) for b in balanced_binaries(i) for a in balanced_binaries(n-i)}\n\ndef balanced_parens(n, table=str.maketrans('10', '()')):\n    return [bin(x).lstrip('0b').translate(table) for x in balanced_binaries(n)]", "def balanced_parens(n):\n    return parens(n, n)\n    \ndef parens(o, c):\n    return (['(' + e for e in parens(o - 1, c)] if o else []) + ([')' + e for e in parens(o, c - 1)] if c > o else []) or ['']", "def balanced_parens(n):\n    return list(set([p[:i] + \"()\" + p[i:] for p in balanced_parens(n - 1) for i in range(0, len(p))])) if n > 1 else ([\"\"], [\"()\"])[n]", "def balanced_parens(n):return rec(n,\"(\",list()) if n!=int() else [\"\"]\ndef rec(n,current,ways):\n    if n>current.count(\"(\"):\n        ways=rec(n,current+\"(\",ways)\n        if current.count(\"(\")>current.count(\")\"):\n            ways=rec(n,current+\")\",ways)\n    else:ways+=[current+(n-current.count(\")\"))*\")\"]\n    return ways", "from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef balanced_parens(n):\n    if not n:\n        return [\"\"]\n    r = set()\n    for x in balanced_parens(n - 1):\n        r.add(\"(\" + x + \")\")\n    for i in range(1, n // 2 + 1):\n        lo = balanced_parens(i)\n        hi = balanced_parens(n - i)\n        for x in lo:\n            for y in hi:\n                r.add(x + y)\n                r.add(y + x)\n    return list(r)", "def balanced_parens(n):\n    res = ['']\n    for _ in range(n):\n        res2 = set()\n        for v in res:\n            for p in range(len(v) if v else 1):\n                res2.add(v[:p]+'()'+v[p:])\n        res = list(res2)\n    return res"]
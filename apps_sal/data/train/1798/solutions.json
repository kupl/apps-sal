["def get(cells, i, j):\n  return cells[i][j] if i > -1 and j > -1 and i < len(cells) and j < len(cells[0]) else 0\n\ndef num_neighbors(cells, i, j):\n  return (get(cells, i, j+1) + get(cells, i, j-1) + get(cells, i+1, j) +\n          get(cells, i-1, j) + get(cells, i-1, j-1) + get(cells, i-1, j+1) +\n          get(cells, i+1, j-1) + get(cells, i+1, j+1))\n\ndef next_cell(cell, i, j):\n  n = num_neighbors(cell, i, j)\n  return int(0 if n < 2 or n > 3 else 1 if cell[i][j] else n == 3)\n\ndef expand(cells):\n  row = [0]*(len(cells[0])+2)\n  return [row] + [[0] + r + [0] for r in cells] + [row]\n\ndef trim(cells):\n  while not any(cells[0]): del cells[0]\n  while not any(cells[-1]): del cells[-1]\n  while not any([row[0] for row in cells]): list(map(lambda x: x.pop(0), cells))\n  while not any([row[-1] for row in cells]): list(map(lambda x: x.pop(), cells))\n\ndef next_gen(cells):\n  cells = expand(cells)\n  cells = [[next_cell(cells, i, j) for j in range(len(cells[i]))] for i in range(len(cells))]\n  trim(cells)\n  return cells\n\ndef get_generation(cells, generations):\n  for i in range(generations):\n    cells = next_gen(cells)\n  if not cells:\n    return [[]]\n  return cells\n", "def get_neighbours(x, y):\n    return {(x + i, y + j) for i in range(-1, 2) for j in range(-1, 2)}\n\ndef get_generation(cells, generations):\n    if not cells: return cells\n    xm, ym, xM, yM = 0, 0, len(cells[0]) - 1, len(cells) - 1\n    cells = {(x, y) for y, l in enumerate(cells) for x, c in enumerate(l) if c}\n    for _ in range(generations):\n        cells = {(x, y) for x in range(xm - 1, xM + 2) for y in range(ym - 1, yM + 2)\n                    if 2 < len(cells & get_neighbours(x, y)) < 4 + ((x, y) in cells)}\n        xm, ym = min(x for x, y in cells), min(y for x, y in cells)\n        xM, yM = max(x for x, y in cells), max(y for x, y in cells)\n    return [[int((x, y) in cells) for x in range(xm, xM + 1)] for y in range(ym, yM + 1)]", "import copy\ndef pad(cells):\n  for x in cells:\n    x.append(0)\n    x.insert(0, 0)\n  cells.append([0] * len(cells[0]))\n  cells.insert(0, [0] * len(cells[0]))\n  return cells\ndef trim_world(cells):\n  while all(i == 0 for i in cells[0]): cells.pop(0)\n  while all(i == 0 for i in cells[-1]): cells.pop()\n  while all(i[0] == 0 for i in cells): cells = [x[1:] for x in cells]\n  while all(i[-1] == 0 for i in cells): cells = [x[:-1] for x in cells]\n  return cells\ndef get_generation(cells, generations):\n  cells = copy.deepcopy(cells)\n  for g in range(generations):\n    cells = pad(cells)\n    new_world = copy.deepcopy(cells)\n    for i in range(len(new_world)):\n      for j in range(len(new_world[i])):\n        count = 0\n        for k in range(-1, 2):\n          for l in range(-1, 2):\n            try:\n              if (k != 0 or l != 0) and (i + k) > -1 and (j + l) > -1 and cells[i + k][j + l]: count += 1\n            except IndexError: '''meh'''\n        new_world[i][j] = cells[i][j] if count == 2 else 1 if count == 3 else 0\n    cells = trim_world(new_world)\n  return cells\n\n", "import numpy as np\nfrom scipy.ndimage import generic_filter\n\ndef get_cell(cells):\n    m, n = cells[4], sum(cells[:4]+cells[5:])\n    return n==3 or (n==2 and m)\n\ndef crop_window(cells):\n    r, c = tuple(cells.any(i).nonzero()[0] for i in (1,0))\n    return cells[r[0]:r[-1]+1, c[0]:c[-1]+1].tolist() if r.size else [[]]\n    \ndef get_generation(cells, gens):\n    for i in range(gens):\n        cells = np.pad(cells, 1, 'constant')\n        cells = generic_filter(cells, get_cell, size=(3,3), mode='constant')\n        cells = crop_window(cells)\n    return cells", "import copy\n\n\ndef add_space(cells):\n    row = [[0] * (len(cells[0]) + 2)]\n    return row + [[0] + x + [0] for x in cells] + copy.deepcopy(row)\n\n\ndef cut_space(cells):\n    for i in range(-1, 1):\n        while cells[i].count(1) == 0:\n            cells.pop(i)\n        while [cells[n][i] for n in range(len(cells))].count(1) == 0:\n            for n in range(len(cells)):\n                cells[n].pop(i)\n    return cells\n\n\ndef morph_cell(neighbours, cell):\n    if cell == 1:\n        if neighbours.count(1) < 2 or neighbours.count(1) > 3:\n            return 0\n    if cell == 0 and neighbours.count(1) == 3:\n        return 1\n    else:\n        return cell\n\n\ndef get_neighbours(cells, coords):\n    neighbours = []\n    for n in range(max(0, coords[0] - 1), min(len(cells), coords[0] + 2)):\n        for m in range(max(0, coords[1] - 1), min(len(cells[n]), coords[1] + 2)):\n            neighbours.append(cells[n][m])\n    if cells[coords[0]][coords[1]] == 1:\n        neighbours = sorted(neighbours)[:-1]\n    else:\n        neighbours = sorted(neighbours)[1:]\n    return morph_cell(neighbours, cells[coords[0]][coords[1]])\n\n\ndef new_step(cells, new_cells):\n    for i in range(len(cells)):\n        for j in range(len(cells[i])):\n            new_cells[i][j] = get_neighbours(cells, (i, j))\n    return new_cells\n\n\ndef get_generation(cells, generations):\n    while generations != 0:\n        cells = add_space(cells)\n        new_cells = copy.deepcopy(cells)\n        new_cells = cut_space(new_step(cells, new_cells))\n        cells = new_cells\n        print(cells)\n        generations -= 1\n    return cells", "def get_generation(cells, generations):\n    \n    if generations == 0: return cells\n    \n    # avoid checking the whole array\n    alive = set((rindex, cindex) for rindex, row \n                 in enumerate(cells) for cindex, cell in enumerate(row) \n                 if cell == 1)\n    \n    for _ in xrange(generations):\n        \n        # if a cell has x neighbours, its coordinates will appear x times in list\n        neighbours = [(cell[0]+y, cell[1]+x) for cell in alive \n                      for y in xrange(-1, 2) for x in xrange(-1, 2) \n                      if (y, x) != (0, 0)]\n        \n        # new generation\n        alive = set(cell for cell in neighbours \n                    if (neighbours.count(cell) == 3) \n                       or (cell in alive and neighbours.count(cell) == 2))\n    \n    # rebuild the array around the living cells of the last generation\n    ys, xs = zip(*alive)\n    \n    cells = [[1 if (rindex, cindex) in alive else 0 \n              for cindex in range(min(xs), max(xs) + 1)] \n             for rindex in range(min(ys), max(ys) + 1)]\n    \n    return cells", "def get_generation(cells, gen):\n    ng = Life(cells)\n    return Life.process(ng, gen)\n\nclass Life:\n    \n    neighbor = [(x,y) for x in range(-1,2) for y in range(-1,2) if x or y]\n    \n    def __init__(self, cells):\n        self.cells = [e[::] for e in cells] \n        self._forLife = lambda x ,y : int(self._express(x,y) in (2,3))\n        self._forDead = lambda x ,y : int(self._express(x,y)==3)\n    \n    @property\n    def _lenY(self):\n        return len(self.cells[0])\n        \n    @property\n    def core(self):\n        return  { (x,y):c  for x, e in enumerate(self.cells) for y, c in enumerate(e)}\n    \n    def _express(self , xc,yc):\n        core = self.core\n        return sum(self.cells[(x+xc)][(y+yc)] for x,y in self.neighbor if core.get((x+xc,y+yc))!=None )\n        \n    @classmethod\n    def process(cls, self, gen):\n        for _ in range(gen):\n            cls._add_field(self)\n            nextG = [e[::] for e in self.cells]\n            for (x,y),c in self.core.items():\n                nextG[x][y] = {0:self._forDead, 1:self._forLife}.get(c)(x,y)\n            self.cells = cls._del_field(nextG)\n        return self.cells\n    \n    @classmethod\n    def _add_field(cls, self):\n        for _ in range(4):\n            self.cells = [list(e) for e in zip(* self.cells[::-1])]\n            if any( self.cells[0]): self.cells.insert(0,[0]*(self._lenY))\n\n    @staticmethod\n    def _del_field( field, cut = 4):\n        for _ in range(4):\n            field = [list(e) for e in zip(* field[::-1])]\n            while not any( field[0]): field.pop(0) \n        return  field", "def get_generation(cells, gen):\n    ng = Life(cells)\n    return ng.process(gen)\n    \n\nclass Life:\n    \n    def __init__(self, cells):\n        self.cells = [e[::] for e in cells]\n        self.neighbor = [(x,y) for x in range(-1,2) for y in range(-1,2) if x or y] \n        self._forLife = lambda x ,y : int(self._express(x,y) in (2,3))\n        self._forDead = lambda x ,y : int(self._express(x,y)==3)\n        \n    @property\n    def _lenX(self):\n        return len(self.cells)\n    \n    @property\n    def _lenY(self):\n        return len(self.cells[0])\n        \n    @property\n    def core(self):\n        return  { (x,y):c  for x, e in enumerate(self.cells) for y, c in enumerate(e)}\n    \n    def _express(self , xc,yc):\n        core = self.core\n        return sum(self.cells[(x+xc)][(y+yc)] for x,y in self.neighbor if core.get((x+xc,y+yc))!=None )\n        \n        \n    def process(self, gen):\n        for _ in range(gen):\n            self._add_field()\n            nextG = [e[::] for e in self.cells]\n            for (x,y),c in list(self.core.items()):\n                nextG[x][y] = {0:self._forDead, 1:self._forLife}.get(c)(x,y)\n            self.cells = self._del_field(nextG)\n        return self.cells\n            \n    def _add_field(self):\n        for i,(s,e) in enumerate([(0,self._lenY+1)]*self._lenX):\n            self.cells[i].insert(s, 0);self.cells[i].insert(e, 0)\n        for _ in (s,e+1): self.cells.insert(_, [0]*(self._lenY)) \n\n    def _del_field(self, field, cut = 4):\n        for _ in range(4):\n            field = [list(e) for e in zip(* field[::-1])]\n            while not any( field[0]):  field.pop(0) \n        return  field\n", "from typing import List, Tuple\n\n\nclass Game(List[List[bool]]):\n    def __init__(self, cells: List[List[int or bool]]) -> None:\n        if not cells[0]:\n            self.height = self.width = 2\n            self[0:2] = [[False, False], [False, False]]\n            return\n\n        self.height: int = len(cells)\n        self.width: int = len(cells[0])\n\n        for i in range(len(cells)):\n            row = []\n            for val in cells[i]:\n                row.append(bool(val))\n            self.append(row)\n        self.__trim()\n\n    def __trim(self) -> None:\n        for _ in range(self.height):\n            row = self[0]\n            if True in row:\n                break\n            del self[0]\n            self.height -= 1\n\n        for _ in reversed(list(range(self.height))):\n            row = self[-1]\n            if True in row:\n                break\n            del self[-1]\n            self.height -= 1\n\n        empty = True\n        while empty:\n            for row in self:\n                if row[0]:\n                    empty = False\n                    break\n            else:\n                for row in self:\n                    del row[0]\n                self.width -= 1\n\n        empty = True\n        while empty:\n            for row in self:\n                if row[-1]:\n                    empty = False\n                    break\n            else:\n                for row in self:\n                    del row[-1]\n                self.width -= 1\n\n    def __pad(self) -> None:\n        self.width += 2\n        self.height += 2\n\n        for i in self:\n            i.insert(0, False)\n            i.append(False)\n        self.insert(0, [False] * self.width)\n        self.append([False] * self.width)\n\n    def __neighbors(self, i: int, j: int):\n        north = i == 0\n        west = j == 0\n        south = i == self.height - 1\n        east = j == self.width - 1\n\n        return int(\n            (self[i - 1][j - 1] if not north and not west else 0)\n            + (self[i - 1][j] if not north else 0)\n            + (self[i - 1][j + 1] if not north and not east else 0)\n            + (self[i][j - 1] if not west else 0)\n            + (self[i][j + 1] if not east else 0)\n            + (self[i + 1][j - 1] if not south and not west else 0)\n            + (self[i + 1][j] if not south else 0)\n            + (self[i + 1][j + 1] if not south and not east else 0)\n        )\n\n    def iterate(self):\n        self.__pad()\n\n        queue: List[Tuple[int, int]] = []\n        for i in range(self.height):\n            for j in range(self.width):\n                status = self[i][j]\n                neighbors = self.__neighbors(i, j)\n                if (status and (neighbors < 2 or neighbors > 3)) or (\n                    not status and (neighbors == 3)\n                ):\n                    queue.append((i, j))\n\n        for i, j in queue:\n            self[i][j] = not self[i][j]\n\n        self.__trim()\n\n    def export(self) -> List[List[int]]:\n        if not self.height or not self.width:\n            return [[]]\n\n        out: List[List[int]] = []\n        for i in self:\n            row = []\n            for j in i:\n                row.append(int(j))\n            out.append(row)\n        return out\n\n\ndef get_generation(cells: List[List[str]], generations):\n    board = Game(cells)\n\n    for _ in range(generations):\n        board.iterate()\n\n    return board.export()\n\n", "import numpy as np\n\ndef next_gen(grid):\n    neighbours = np.array([np.roll(grid, (i, j), axis=(0, 1)) for i in [-1, 0, 1] for j in [-1, 0, 1]]).sum(axis=0) - grid\n    return (neighbours == 3) | (grid & (neighbours == 2)) \n\ndef unpad(grid):\n    if grid[0,].sum() == 0:\n        return unpad(grid[1:])\n    if grid[-1,].sum() == 0:\n        return unpad(grid[:-1])\n    if grid[:,0].sum() == 0:\n        return unpad(grid[:,1:])\n    if grid[:,-1].sum() == 0:\n        return unpad(grid[:,:-1])\n    return grid\n        \ndef get_generation(cells, generations):\n    cells = np.array(cells)\n    for _ in range(generations):\n        cells = next_gen(np.pad(cells, 1, mode='constant'))\n    return unpad(cells).tolist()"]